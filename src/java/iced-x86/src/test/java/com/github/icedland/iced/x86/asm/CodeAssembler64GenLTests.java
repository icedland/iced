// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// âš ï¸This file was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸

package com.github.icedland.iced.x86.asm;

import org.junit.jupiter.api.Test;

import com.github.icedland.iced.x86.*;
import static com.github.icedland.iced.x86.asm.AsmRegisters.*;

final class CodeAssembler64GenLTests extends CodeAssemblerTestsBase {
	CodeAssembler64GenLTests() {
		super(64);
	}

	@Test
	void lahf() {
		testAssembler(c -> c.lahf(), Instruction.create(Code.LAHF));
	}

	@Test
	void lar_r16_r16() {
		testAssembler(c -> c.lar(dx, bx), Instruction.create(Code.LAR_R16_RM16, ICRegisters.dx, ICRegisters.bx));
	}

	@Test
	void lar_r32_r32() {
		testAssembler(c -> c.lar(edx, ebx), Instruction.create(Code.LAR_R32_R32M16, ICRegisters.edx, ICRegisters.ebx));
	}

	@Test
	void lar_r64_r64() {
		testAssembler(c -> c.lar(rdx, rbx), Instruction.create(Code.LAR_R64_R64M16, ICRegisters.rdx, ICRegisters.rbx));
	}

	@Test
	void lar_r16_m() {
		testAssembler(c -> c.lar(dx, word_ptr(0x0L).base(rcx)), Instruction.create(Code.LAR_R16_RM16, ICRegisters.dx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lar_r32_m() {
		testAssembler(c -> c.lar(edx, dword_ptr(0x0L).base(rcx)), Instruction.create(Code.LAR_R32_R32M16, ICRegisters.edx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lddqu_xmm_m() {
		testAssembler(c -> c.lddqu(xmm2, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LDDQU_XMM_M128, ICRegisters.xmm2, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void ldmxcsr_m() {
		testAssembler(c -> c.ldmxcsr(mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LDMXCSR_M32, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void ldtilecfg_m() {
		testAssembler(c -> c.ldtilecfg(mem_ptr(0x0L).base(rcx)), Instruction.create(Code.VEX_LDTILECFG_M512, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lea_r16_m() {
		testAssembler(c -> c.lea(dx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LEA_R16_M, ICRegisters.dx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lea_r32_m() {
		testAssembler(c -> c.lea(edx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LEA_R32_M, ICRegisters.edx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lea_r64_m() {
		testAssembler(c -> c.lea(rdx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LEA_R64_M, ICRegisters.rdx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void leave() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.leave(), Instruction.create(Code.LEAVEQ));
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void lfence() {
		testAssembler(c -> c.lfence(), Instruction.create(Code.LFENCE));
	}

	@Test
	void lfs_r16_m() {
		testAssembler(c -> c.lfs(dx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LFS_R16_M1616, ICRegisters.dx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lfs_r32_m() {
		testAssembler(c -> c.lfs(edx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LFS_R32_M1632, ICRegisters.edx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lfs_r64_m() {
		testAssembler(c -> c.lfs(rdx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LFS_R64_M1664, ICRegisters.rdx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lgdt_m() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.lgdt(mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LGDT_M1664, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void lgs_r16_m() {
		testAssembler(c -> c.lgs(dx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LGS_R16_M1616, ICRegisters.dx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lgs_r32_m() {
		testAssembler(c -> c.lgs(edx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LGS_R32_M1632, ICRegisters.edx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lgs_r64_m() {
		testAssembler(c -> c.lgs(rdx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LGS_R64_M1664, ICRegisters.rdx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lidt_m() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.lidt(mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LIDT_M1664, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void lkgs_r16() {
		testAssembler(c -> c.lkgs(dx), Instruction.create(Code.LKGS_RM16, ICRegisters.dx));
	}

	@Test
	void lkgs_r32() {
		testAssembler(c -> c.lkgs(edx), Instruction.create(Code.LKGS_R32M16, ICRegisters.edx));
	}

	@Test
	void lkgs_r64() {
		testAssembler(c -> c.lkgs(rdx), Instruction.create(Code.LKGS_R64M16, ICRegisters.rdx));
	}

	@Test
	void lkgs_m() {
		{ /* if (getBitness() >= 32) */
			testAssembler(c -> c.lkgs(dword_ptr(0x0L).base(rcx)), Instruction.create(Code.LKGS_R32M16, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else skip !(getBitness() >= 32) not supported by this CodeAssembler bitness */
	}

	@Test
	void lldt_r16() {
		testAssembler(c -> c.lldt(dx), Instruction.create(Code.LLDT_RM16, ICRegisters.dx));
	}

	@Test
	void lldt_r32() {
		testAssembler(c -> c.lldt(edx), Instruction.create(Code.LLDT_R32M16, ICRegisters.edx));
	}

	@Test
	void lldt_r64() {
		testAssembler(c -> c.lldt(rdx), Instruction.create(Code.LLDT_R64M16, ICRegisters.rdx));
	}

	@Test
	void lldt_m() {
		{ /* if (getBitness() >= 32) */
			testAssembler(c -> c.lldt(dword_ptr(0x0L).base(rcx)), Instruction.create(Code.LLDT_R32M16, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else skip !(getBitness() >= 32) not supported by this CodeAssembler bitness */
	}

	@Test
	void llwpcb_r32() {
		testAssembler(c -> c.llwpcb(edx), Instruction.create(Code.XOP_LLWPCB_R32, ICRegisters.edx));
	}

	@Test
	void llwpcb_r64() {
		testAssembler(c -> c.llwpcb(rdx), Instruction.create(Code.XOP_LLWPCB_R64, ICRegisters.rdx));
	}

	@Test
	void lmsw_r16() {
		testAssembler(c -> c.lmsw(dx), Instruction.create(Code.LMSW_RM16, ICRegisters.dx));
	}

	@Test
	void lmsw_r32() {
		testAssembler(c -> c.lmsw(edx), Instruction.create(Code.LMSW_R32M16, ICRegisters.edx));
	}

	@Test
	void lmsw_r64() {
		testAssembler(c -> c.lmsw(rdx), Instruction.create(Code.LMSW_R64M16, ICRegisters.rdx));
	}

	@Test
	void lmsw_m() {
		{ /* if (getBitness() >= 32) */
			testAssembler(c -> c.lmsw(dword_ptr(0x0L).base(rcx)), Instruction.create(Code.LMSW_R32M16, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else skip !(getBitness() >= 32) not supported by this CodeAssembler bitness */
	}

	@Test
	void loadiwkey_xmm_xmm() {
		testAssembler(c -> c.loadiwkey(xmm2, xmm3), Instruction.create(Code.LOADIWKEY_XMM_XMM, ICRegisters.xmm2, ICRegisters.xmm3));
	}

	@Test
	void lodsb() {
		testAssembler(c -> c.lodsb(), Instruction.createLodsb(64));
	}

	@Test
	void lodsd() {
		testAssembler(c -> c.lodsd(), Instruction.createLodsd(64));
	}

	@Test
	void lodsq() {
		testAssembler(c -> c.lodsq(), Instruction.createLodsq(64));
	}

	@Test
	void lodsw() {
		testAssembler(c -> c.lodsw(), Instruction.createLodsw(64));
	}

	@Test
	void loop_l() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loop(createAndEmitLabel(c)), assignLabel(Instruction.createBranch(Code.LOOP_REL8_64_RCX, FIRST_LABEL_ID), FIRST_LABEL_ID), TestInstrFlags.BRANCH);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void loop_lu64() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loop(0x31D0L), Instruction.createBranch(Code.LOOP_REL8_64_RCX, 0x31D0L), TestInstrFlags.BRANCH_U64);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void loope_l() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loope(createAndEmitLabel(c)), assignLabel(Instruction.createBranch(Code.LOOPE_REL8_64_RCX, FIRST_LABEL_ID), FIRST_LABEL_ID), TestInstrFlags.BRANCH);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void loope_lu64() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loope(0x31D0L), Instruction.createBranch(Code.LOOPE_REL8_64_RCX, 0x31D0L), TestInstrFlags.BRANCH_U64);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void loopne_l() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loopne(createAndEmitLabel(c)), assignLabel(Instruction.createBranch(Code.LOOPNE_REL8_64_RCX, FIRST_LABEL_ID), FIRST_LABEL_ID), TestInstrFlags.BRANCH);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void loopne_lu64() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loopne(0x31D0L), Instruction.createBranch(Code.LOOPNE_REL8_64_RCX, 0x31D0L), TestInstrFlags.BRANCH_U64);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void loopnz_l() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loopnz(createAndEmitLabel(c)), assignLabel(Instruction.createBranch(Code.LOOPNE_REL8_64_RCX, FIRST_LABEL_ID), FIRST_LABEL_ID), TestInstrFlags.BRANCH);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void loopnz_lu64() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loopnz(0x31D0L), Instruction.createBranch(Code.LOOPNE_REL8_64_RCX, 0x31D0L), TestInstrFlags.BRANCH_U64);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void loopz_l() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loopz(createAndEmitLabel(c)), assignLabel(Instruction.createBranch(Code.LOOPE_REL8_64_RCX, FIRST_LABEL_ID), FIRST_LABEL_ID), TestInstrFlags.BRANCH);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void loopz_lu64() {
		{ /* if (getBitness() == 64) */
			testAssembler(c -> c.loopz(0x31D0L), Instruction.createBranch(Code.LOOPE_REL8_64_RCX, 0x31D0L), TestInstrFlags.BRANCH_U64);
		} /* else skip !(getBitness() == 64) not supported by this CodeAssembler bitness */
	}

	@Test
	void lsl_r16_r16() {
		testAssembler(c -> c.lsl(dx, bx), Instruction.create(Code.LSL_R16_RM16, ICRegisters.dx, ICRegisters.bx));
	}

	@Test
	void lsl_r32_r32() {
		testAssembler(c -> c.lsl(edx, ebx), Instruction.create(Code.LSL_R32_R32M16, ICRegisters.edx, ICRegisters.ebx));
	}

	@Test
	void lsl_r64_r64() {
		testAssembler(c -> c.lsl(rdx, rbx), Instruction.create(Code.LSL_R64_R64M16, ICRegisters.rdx, ICRegisters.rbx));
	}

	@Test
	void lsl_r16_m() {
		testAssembler(c -> c.lsl(dx, word_ptr(0x0L).base(rcx)), Instruction.create(Code.LSL_R16_RM16, ICRegisters.dx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lsl_r32_m() {
		testAssembler(c -> c.lsl(edx, dword_ptr(0x0L).base(rcx)), Instruction.create(Code.LSL_R32_R32M16, ICRegisters.edx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lss_r16_m() {
		testAssembler(c -> c.lss(dx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LSS_R16_M1616, ICRegisters.dx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lss_r32_m() {
		testAssembler(c -> c.lss(edx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LSS_R32_M1632, ICRegisters.edx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lss_r64_m() {
		testAssembler(c -> c.lss(rdx, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.LSS_R64_M1664, ICRegisters.rdx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void ltr_r16() {
		testAssembler(c -> c.ltr(dx), Instruction.create(Code.LTR_RM16, ICRegisters.dx));
	}

	@Test
	void ltr_r32() {
		testAssembler(c -> c.ltr(edx), Instruction.create(Code.LTR_R32M16, ICRegisters.edx));
	}

	@Test
	void ltr_r64() {
		testAssembler(c -> c.ltr(rdx), Instruction.create(Code.LTR_R64M16, ICRegisters.rdx));
	}

	@Test
	void ltr_m() {
		{ /* if (getBitness() >= 32) */
			testAssembler(c -> c.ltr(dword_ptr(0x0L).base(rcx)), Instruction.create(Code.LTR_R32M16, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else skip !(getBitness() >= 32) not supported by this CodeAssembler bitness */
	}

	@Test
	void lwpins_r32_r32_i() {
		testAssembler(c -> c.lwpins(edx, ebx, 0x7FFFFFFF), Instruction.create(Code.XOP_LWPINS_R32_RM32_IMM32, ICRegisters.edx, ICRegisters.ebx, 0x7FFFFFFF));
	}

	@Test
	void lwpins_r64_r32_i() {
		testAssembler(c -> c.lwpins(rdx, ebx, 0x7FFFFFFF), Instruction.create(Code.XOP_LWPINS_R64_RM32_IMM32, ICRegisters.rdx, ICRegisters.ebx, 0x7FFFFFFF));
	}

	@Test
	void lwpins_r32_m_i() {
		testAssembler(c -> c.lwpins(edx, dword_ptr(0x0L).base(rcx), 0x7FFFFFFF), Instruction.create(Code.XOP_LWPINS_R32_RM32_IMM32, ICRegisters.edx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE), 0x7FFFFFFF));
	}

	@Test
	void lwpins_r64_m_i() {
		testAssembler(c -> c.lwpins(rdx, dword_ptr(0x0L).base(rcx), 0x7FFFFFFF), Instruction.create(Code.XOP_LWPINS_R64_RM32_IMM32, ICRegisters.rdx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE), 0x7FFFFFFF));
	}

	@Test
	void lwpval_r32_r32_i() {
		testAssembler(c -> c.lwpval(edx, ebx, 0x7FFFFFFF), Instruction.create(Code.XOP_LWPVAL_R32_RM32_IMM32, ICRegisters.edx, ICRegisters.ebx, 0x7FFFFFFF));
	}

	@Test
	void lwpval_r64_r32_i() {
		testAssembler(c -> c.lwpval(rdx, ebx, 0x7FFFFFFF), Instruction.create(Code.XOP_LWPVAL_R64_RM32_IMM32, ICRegisters.rdx, ICRegisters.ebx, 0x7FFFFFFF));
	}

	@Test
	void lwpval_r32_m_i() {
		testAssembler(c -> c.lwpval(edx, dword_ptr(0x0L).base(rcx), 0x7FFFFFFF), Instruction.create(Code.XOP_LWPVAL_R32_RM32_IMM32, ICRegisters.edx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE), 0x7FFFFFFF));
	}

	@Test
	void lwpval_r64_m_i() {
		testAssembler(c -> c.lwpval(rdx, dword_ptr(0x0L).base(rcx), 0x7FFFFFFF), Instruction.create(Code.XOP_LWPVAL_R64_RM32_IMM32, ICRegisters.rdx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE), 0x7FFFFFFF));
	}

	@Test
	void lzcnt_r16_r16() {
		testAssembler(c -> c.lzcnt(dx, bx), Instruction.create(Code.LZCNT_R16_RM16, ICRegisters.dx, ICRegisters.bx));
	}

	@Test
	void lzcnt_r32_r32() {
		testAssembler(c -> c.lzcnt(edx, ebx), Instruction.create(Code.LZCNT_R32_RM32, ICRegisters.edx, ICRegisters.ebx));
	}

	@Test
	void lzcnt_r64_r64() {
		testAssembler(c -> c.lzcnt(rdx, rbx), Instruction.create(Code.LZCNT_R64_RM64, ICRegisters.rdx, ICRegisters.rbx));
	}

	@Test
	void lzcnt_r16_m() {
		testAssembler(c -> c.lzcnt(dx, word_ptr(0x0L).base(rcx)), Instruction.create(Code.LZCNT_R16_RM16, ICRegisters.dx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lzcnt_r32_m() {
		testAssembler(c -> c.lzcnt(edx, dword_ptr(0x0L).base(rcx)), Instruction.create(Code.LZCNT_R32_RM32, ICRegisters.edx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void lzcnt_r64_m() {
		testAssembler(c -> c.lzcnt(rdx, qword_ptr(0x0L).base(rcx)), Instruction.create(Code.LZCNT_R64_RM64, ICRegisters.rdx, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void vlddqu_xmm_m() {
		testAssembler(c -> c.vlddqu(xmm2, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.VEX_VLDDQU_XMM_M128, ICRegisters.xmm2, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void vlddqu_ymm_m() {
		testAssembler(c -> c.vlddqu(ymm2, mem_ptr(0x0L).base(rcx)), Instruction.create(Code.VEX_VLDDQU_YMM_M256, ICRegisters.ymm2, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	@Test
	void vldmxcsr_m() {
		testAssembler(c -> c.vldmxcsr(mem_ptr(0x0L).base(rcx)), Instruction.create(Code.VEX_VLDMXCSR_M32, new MemoryOperand(ICRegisters.rcx, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_1() {
		testAssemblerDeclareByte(c -> c.db((byte)1), new byte[] {(byte)1});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_2() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2), new byte[] {(byte)1, (byte)2});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_3() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3), new byte[] {(byte)1, (byte)2, (byte)3});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_4() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_5() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_6() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_7() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_8() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_9() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_10() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_11() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_12() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_13() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12, (byte)13), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12, (byte)13});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_14() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12, (byte)13, (byte)14), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12, (byte)13, (byte)14});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_15() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12, (byte)13, (byte)14, (byte)15), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12, (byte)13, (byte)14, (byte)15});
	}

	/**
	 * Creates a db asm directive with the type byte.<!-- -->
	 */
	@Test
	void testAssemblerDeclareByte_db_byte_16() {
		testAssemblerDeclareByte(c -> c.db((byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12, (byte)13, (byte)14, (byte)15, (byte)16), new byte[] {(byte)1, (byte)2, (byte)3, (byte)4, (byte)5, (byte)6, (byte)7, (byte)8, (byte)9, (byte)10, (byte)11, (byte)12, (byte)13, (byte)14, (byte)15, (byte)16});
	}
	/**
	 * Creates a dw asm directive with the type short.<!-- -->
	 */
	@Test
	void testAssemblerDeclareWord_dw_short_1() {
		testAssemblerDeclareWord(c -> c.dw((short)1), new short[] {(short)1});
	}

	/**
	 * Creates a dw asm directive with the type short.<!-- -->
	 */
	@Test
	void testAssemblerDeclareWord_dw_short_2() {
		testAssemblerDeclareWord(c -> c.dw((short)1, (short)2), new short[] {(short)1, (short)2});
	}

	/**
	 * Creates a dw asm directive with the type short.<!-- -->
	 */
	@Test
	void testAssemblerDeclareWord_dw_short_3() {
		testAssemblerDeclareWord(c -> c.dw((short)1, (short)2, (short)3), new short[] {(short)1, (short)2, (short)3});
	}

	/**
	 * Creates a dw asm directive with the type short.<!-- -->
	 */
	@Test
	void testAssemblerDeclareWord_dw_short_4() {
		testAssemblerDeclareWord(c -> c.dw((short)1, (short)2, (short)3, (short)4), new short[] {(short)1, (short)2, (short)3, (short)4});
	}

	/**
	 * Creates a dw asm directive with the type short.<!-- -->
	 */
	@Test
	void testAssemblerDeclareWord_dw_short_5() {
		testAssemblerDeclareWord(c -> c.dw((short)1, (short)2, (short)3, (short)4, (short)5), new short[] {(short)1, (short)2, (short)3, (short)4, (short)5});
	}

	/**
	 * Creates a dw asm directive with the type short.<!-- -->
	 */
	@Test
	void testAssemblerDeclareWord_dw_short_6() {
		testAssemblerDeclareWord(c -> c.dw((short)1, (short)2, (short)3, (short)4, (short)5, (short)6), new short[] {(short)1, (short)2, (short)3, (short)4, (short)5, (short)6});
	}

	/**
	 * Creates a dw asm directive with the type short.<!-- -->
	 */
	@Test
	void testAssemblerDeclareWord_dw_short_7() {
		testAssemblerDeclareWord(c -> c.dw((short)1, (short)2, (short)3, (short)4, (short)5, (short)6, (short)7), new short[] {(short)1, (short)2, (short)3, (short)4, (short)5, (short)6, (short)7});
	}

	/**
	 * Creates a dw asm directive with the type short.<!-- -->
	 */
	@Test
	void testAssemblerDeclareWord_dw_short_8() {
		testAssemblerDeclareWord(c -> c.dw((short)1, (short)2, (short)3, (short)4, (short)5, (short)6, (short)7, (short)8), new short[] {(short)1, (short)2, (short)3, (short)4, (short)5, (short)6, (short)7, (short)8});
	}
	/**
	 * Creates a dd asm directive with the type int.<!-- -->
	 */
	@Test
	void testAssemblerDeclareDword_dd_int_1() {
		testAssemblerDeclareDword(c -> c.dd((int)1), new int[] {(int)1});
	}

	/**
	 * Creates a dd asm directive with the type int.<!-- -->
	 */
	@Test
	void testAssemblerDeclareDword_dd_int_2() {
		testAssemblerDeclareDword(c -> c.dd((int)1, (int)2), new int[] {(int)1, (int)2});
	}

	/**
	 * Creates a dd asm directive with the type int.<!-- -->
	 */
	@Test
	void testAssemblerDeclareDword_dd_int_3() {
		testAssemblerDeclareDword(c -> c.dd((int)1, (int)2, (int)3), new int[] {(int)1, (int)2, (int)3});
	}

	/**
	 * Creates a dd asm directive with the type int.<!-- -->
	 */
	@Test
	void testAssemblerDeclareDword_dd_int_4() {
		testAssemblerDeclareDword(c -> c.dd((int)1, (int)2, (int)3, (int)4), new int[] {(int)1, (int)2, (int)3, (int)4});
	}

	/**
	 * Creates a dd asm directive with the type float.<!-- -->
	 */
	@Test
	void testAssemblerDeclareDword_dd_float_1() {
		testAssemblerDeclareDword(c -> c.dd((float)1), new float[] {(float)1});
	}

	/**
	 * Creates a dd asm directive with the type float.<!-- -->
	 */
	@Test
	void testAssemblerDeclareDword_dd_float_2() {
		testAssemblerDeclareDword(c -> c.dd((float)1, (float)2), new float[] {(float)1, (float)2});
	}

	/**
	 * Creates a dd asm directive with the type float.<!-- -->
	 */
	@Test
	void testAssemblerDeclareDword_dd_float_3() {
		testAssemblerDeclareDword(c -> c.dd((float)1, (float)2, (float)3), new float[] {(float)1, (float)2, (float)3});
	}

	/**
	 * Creates a dd asm directive with the type float.<!-- -->
	 */
	@Test
	void testAssemblerDeclareDword_dd_float_4() {
		testAssemblerDeclareDword(c -> c.dd((float)1, (float)2, (float)3, (float)4), new float[] {(float)1, (float)2, (float)3, (float)4});
	}
	/**
	 * Creates a dq asm directive with the type long.<!-- -->
	 */
	@Test
	void testAssemblerDeclareQword_dq_long_1() {
		testAssemblerDeclareQword(c -> c.dq((long)1), new long[] {(long)1});
	}

	/**
	 * Creates a dq asm directive with the type long.<!-- -->
	 */
	@Test
	void testAssemblerDeclareQword_dq_long_2() {
		testAssemblerDeclareQword(c -> c.dq((long)1, (long)2), new long[] {(long)1, (long)2});
	}

	/**
	 * Creates a dq asm directive with the type double.<!-- -->
	 */
	@Test
	void testAssemblerDeclareQword_dq_double_1() {
		testAssemblerDeclareQword(c -> c.dq((double)1), new double[] {(double)1});
	}

	/**
	 * Creates a dq asm directive with the type double.<!-- -->
	 */
	@Test
	void testAssemblerDeclareQword_dq_double_2() {
		testAssemblerDeclareQword(c -> c.dq((double)1, (double)2), new double[] {(double)1, (double)2});
	}
}
