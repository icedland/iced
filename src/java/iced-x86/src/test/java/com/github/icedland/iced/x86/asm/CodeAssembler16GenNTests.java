// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// âš ï¸This file was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸

package com.github.icedland.iced.x86.asm;

import org.junit.jupiter.api.Test;

import com.github.icedland.iced.x86.*;
import static com.github.icedland.iced.x86.asm.AsmRegisters.*;

@SuppressWarnings("cast")
final class CodeAssembler16GenNTests extends CodeAssemblerTestsBase {
	CodeAssembler16GenNTests() {
		super(16);
	}

	@Test
	void neg_r8() {
		testAssembler(c -> c.neg(dl), Instruction.create(Code.NEG_RM8, ICRegisters.dl));
	}

	@Test
	void neg_r16() {
		testAssembler(c -> c.neg(dx), Instruction.create(Code.NEG_RM16, ICRegisters.dx));
	}

	@Test
	void neg_r32() {
		testAssembler(c -> c.neg(edx), Instruction.create(Code.NEG_RM32, ICRegisters.edx));
	}

	@Test
	void neg_m() {
		{ /* if (dst.size == MemoryOperandSize.QWORD) */
			// Skipping NEG_RM64 - Not supported by current bitness
		} /* else */ { /* if (dst.size == MemoryOperandSize.DWORD) */
			testAssembler(c -> c.neg(dword_ptr(0x0L).base(di)), Instruction.create(Code.NEG_RM32, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else */ { /* if (dst.size == MemoryOperandSize.WORD) */
			testAssembler(c -> c.neg(word_ptr(0x0L).base(di)), Instruction.create(Code.NEG_RM16, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else */ { /* if (dst.size == MemoryOperandSize.BYTE) */
			testAssembler(c -> c.neg(byte_ptr(0x0L).base(di)), Instruction.create(Code.NEG_RM8, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		}
		{
			assertInvalid(() -> {
				testAssembler(c -> c.neg(zmmword_ptr(0x0L).base(di)), Instruction.create(Code.NEG_RM8, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
			});
		}
	}

	@Test
	void nop() {
		{ // skip (getBitness() >= 32) not supported by this CodeAssembler bitness
		} /* else */ testAssembler(c -> c.nop(), Instruction.create(Code.NOPW));
	}

	@Test
	void nop_r16() {
		testAssembler(c -> c.nop(dx), Instruction.create(Code.NOP_RM16, ICRegisters.dx));
	}

	@Test
	void nop_r32() {
		testAssembler(c -> c.nop(edx), Instruction.create(Code.NOP_RM32, ICRegisters.edx));
	}

	@Test
	void nop_m() {
		{ /* if (dst.size == MemoryOperandSize.QWORD) */
			// Skipping NOP_RM64 - Not supported by current bitness
		} /* else */ { /* if (dst.size == MemoryOperandSize.DWORD) */
			testAssembler(c -> c.nop(dword_ptr(0x0L).base(di)), Instruction.create(Code.NOP_RM32, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else */ { /* if (dst.size == MemoryOperandSize.WORD) */
			testAssembler(c -> c.nop(word_ptr(0x0L).base(di)), Instruction.create(Code.NOP_RM16, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		}
		{
			assertInvalid(() -> {
				testAssembler(c -> c.nop(zmmword_ptr(0x0L).base(di)), Instruction.create(Code.NOP_RM16, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
			});
		}
	}

	@Test
	void not_r8() {
		testAssembler(c -> c.not(dl), Instruction.create(Code.NOT_RM8, ICRegisters.dl));
	}

	@Test
	void not_r16() {
		testAssembler(c -> c.not(dx), Instruction.create(Code.NOT_RM16, ICRegisters.dx));
	}

	@Test
	void not_r32() {
		testAssembler(c -> c.not(edx), Instruction.create(Code.NOT_RM32, ICRegisters.edx));
	}

	@Test
	void not_m() {
		{ /* if (dst.size == MemoryOperandSize.QWORD) */
			// Skipping NOT_RM64 - Not supported by current bitness
		} /* else */ { /* if (dst.size == MemoryOperandSize.DWORD) */
			testAssembler(c -> c.not(dword_ptr(0x0L).base(di)), Instruction.create(Code.NOT_RM32, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else */ { /* if (dst.size == MemoryOperandSize.WORD) */
			testAssembler(c -> c.not(word_ptr(0x0L).base(di)), Instruction.create(Code.NOT_RM16, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		} /* else */ { /* if (dst.size == MemoryOperandSize.BYTE) */
			testAssembler(c -> c.not(byte_ptr(0x0L).base(di)), Instruction.create(Code.NOT_RM8, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
		}
		{
			assertInvalid(() -> {
				testAssembler(c -> c.not(zmmword_ptr(0x0L).base(di)), Instruction.create(Code.NOT_RM8, new MemoryOperand(ICRegisters.di, ICRegister.NONE, 1, 0x0L, 0, false, ICRegister.NONE)));
			});
		}
	}

}
