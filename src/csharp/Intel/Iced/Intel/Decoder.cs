// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

#if DECODER
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Iced.Intel.DecoderInternal;

namespace Iced.Intel {
	// GENERATOR-BEGIN: OpSize
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	enum OpSize : byte {
		Size16,
		Size32,
		Size64,
	}
	// GENERATOR-END: OpSize

	// GENERATOR-BEGIN: StateFlags
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	[Flags]
	enum StateFlags : uint {
		IpRel64 = 0x00000001,
		IpRel32 = 0x00000002,
		HasRex = 0x00000008,
		b = 0x00000010,
		z = 0x00000020,
		IsInvalid = 0x00000040,
		W = 0x00000080,
		NoImm = 0x00000100,
		Addr64 = 0x00000200,
		BranchImm8 = 0x00000400,
		Xbegin = 0x00000800,
		Lock = 0x00001000,
		AllowLock = 0x00002000,
		NoMoreBytes = 0x00004000,
		Has66 = 0x00008000,
		MvexSssMask = 0x00000007,
		MvexSssShift = 0x00000010,
		MvexEH = 0x00080000,
		EncodingMask = 0x00000007,
		EncodingShift = 0x0000001D,
	}
	// GENERATOR-END: StateFlags

	/// <summary>
	/// Decodes 16/32/64-bit x86 instructions
	/// </summary>
	public sealed class Decoder : IEnumerable<Instruction> {
		ulong instructionPointer;
		readonly CodeReader reader;
		readonly RegInfo2[] memRegs16;
		readonly OpCodeHandler[] handlers_MAP0;
#if !NO_VEX && MVEX
		readonly OpCodeHandler[] handlers_VEX_MAP0;
#endif
#if !NO_VEX
		readonly OpCodeHandler[] handlers_VEX_0F;
		readonly OpCodeHandler[] handlers_VEX_0F38;
		readonly OpCodeHandler[] handlers_VEX_0F3A;
#endif
#if !NO_EVEX
		readonly OpCodeHandler[] handlers_EVEX_0F;
		readonly OpCodeHandler[] handlers_EVEX_0F38;
		readonly OpCodeHandler[] handlers_EVEX_0F3A;
		readonly OpCodeHandler[] handlers_EVEX_MAP5;
		readonly OpCodeHandler[] handlers_EVEX_MAP6;
#endif
#if !NO_XOP
		readonly OpCodeHandler[] handlers_XOP_MAP8;
		readonly OpCodeHandler[] handlers_XOP_MAP9;
		readonly OpCodeHandler[] handlers_XOP_MAP10;
#endif
#if MVEX
		readonly OpCodeHandler[] handlers_MVEX_0F;
		readonly OpCodeHandler[] handlers_MVEX_0F38;
		readonly OpCodeHandler[] handlers_MVEX_0F3A;
#endif
		internal State state;
		internal uint displIndex;
		internal readonly DecoderOptions options;
		internal readonly uint invalidCheckMask;// All 1s if we should check for invalid instructions, else 0
		internal readonly uint is64bMode_and_W;// StateFlags.W if 64-bit mode, 0 if 16/32-bit mode
		internal readonly uint reg15Mask;// 7 in 16/32-bit mode, 15 in 64-bit mode
		readonly uint maskE0;
		readonly uint rexMask;
		internal readonly CodeSize defaultCodeSize;
		internal readonly OpSize defaultOperandSize;
		readonly OpSize defaultAddressSize;
		internal readonly OpSize defaultInvertedOperandSize;
		internal readonly OpSize defaultInvertedAddressSize;
		internal readonly bool is64bMode;

		// The fields were moved to a new struct so the jitter can efficiently clear all of them at once in Decode(out)
		internal struct ZState {
			public uint instructionLength;
			public uint extraRegisterBase;		// R << 3
			public uint extraIndexRegisterBase;	// X << 3
			public uint extraBaseRegisterBase;	// B << 3
			public uint extraIndexRegisterBaseVSIB;
			public StateFlags flags;
			public MandatoryPrefixByte mandatoryPrefix;
			// 0=ES/CS/SS/DS, 1=FS/GS
			public byte segmentPrio;
		}
		internal struct State {
			public uint modrm, mod, reg, rm;
			public ZState zs;
			public uint vvvv;// V`vvvv. Not stored in inverted form. If 16/32-bit mode, bits [4:3] are cleared
			public uint vvvv_invalidCheck;// vvvv bits, even in 16/32-bit mode.
			public uint aaa;
			public uint extraRegisterBaseEVEX;		// EVEX/MVEX.R' << 4
			public uint extraBaseRegisterBaseEVEX;	// EVEX/MVEX.XB << 3
			public uint vectorLength;
			public OpSize operandSize;
			public OpSize addressSize;
			public readonly EncodingKind Encoding => (EncodingKind)(((uint)zs.flags >> (int)StateFlags.EncodingShift) & (uint)StateFlags.EncodingMask);
#if MVEX
			public int Sss => ((int)zs.flags >> (int)StateFlags.MvexSssShift) & (int)StateFlags.MvexSssMask;
#endif
		}

		/// <summary>
		/// Current <c>IP</c>/<c>EIP</c>/<c>RIP</c> value.<br/>
		/// <br/>
		/// Writing to this property only updates the IP value, it does not change a <see cref="CodeReader"/>'s byte position.
		/// You can use <see cref="ByteArrayCodeReader.Position"/> to change its position.
		/// </summary>
		public ulong IP {
			get => instructionPointer;
			set => instructionPointer = value;
		}

		/// <summary>
		/// Gets the bitness (16, 32 or 64)
		/// </summary>
		public int Bitness { get; }

		static Decoder() {
			// Initialize cctors that are used by decoder related methods. It doesn't speed up
			// decoding much, but getting instruction info is a little faster.
			_ = OpCodeHandler_Invalid.Instance;
			_ = InstructionMemorySizes.SizesNormal;
#if !NO_D3NOW
			_ = OpCodeHandler_D3NOW.CodeValues;
#endif
			_ = InstructionOpCounts.OpCount;
			_ = MnemonicUtilsData.toMnemonic;
#if !HAS_SPAN
			_ = TupleTypeTable.tupleTypeData;
#endif
#if INSTR_INFO
			_ = RegisterExtensions.RegisterInfos;
			_ = MemorySizeExtensions.MemorySizeInfos;
			_ = InstructionInfoInternal.InstrInfoTable.Data;
			_ = InstructionInfoInternal.RflagsInfoConstants.flagsCleared;
			_ = InstructionInfoInternal.CpuidFeatureInternalData.ToCpuidFeatures;
			_ = InstructionInfoInternal.SimpleList<UsedRegister>.Empty;
			_ = InstructionInfoInternal.SimpleList<UsedMemory>.Empty;
#endif
		}

		Decoder(CodeReader reader, ulong ip, DecoderOptions options, int bitness) {
			this.reader = reader ?? throw new ArgumentNullException(nameof(reader));
			instructionPointer = ip;
			this.options = options;
			invalidCheckMask = (options & DecoderOptions.NoInvalidCheck) == 0 ? uint.MaxValue : 0;
			memRegs16 = s_memRegs16;
			Bitness = bitness;
			if (bitness == 64) {
				is64bMode = true;
				defaultCodeSize = CodeSize.Code64;
				defaultOperandSize = OpSize.Size32;
				defaultInvertedOperandSize = OpSize.Size16;
				defaultAddressSize = OpSize.Size64;
				defaultInvertedAddressSize = OpSize.Size32;
				maskE0 = 0xE0;
				rexMask = 0xF0;
			}
			else if (bitness == 32) {
				is64bMode = false;
				defaultCodeSize = CodeSize.Code32;
				defaultOperandSize = OpSize.Size32;
				defaultInvertedOperandSize = OpSize.Size16;
				defaultAddressSize = OpSize.Size32;
				defaultInvertedAddressSize = OpSize.Size16;
				maskE0 = 0;
				rexMask = 0;
			}
			else {
				Debug.Assert(bitness == 16);
				is64bMode = false;
				defaultCodeSize = CodeSize.Code16;
				defaultOperandSize = OpSize.Size16;
				defaultInvertedOperandSize = OpSize.Size32;
				defaultAddressSize = OpSize.Size16;
				defaultInvertedAddressSize = OpSize.Size32;
				maskE0 = 0;
				rexMask = 0;
			}
			is64bMode_and_W = is64bMode ? (uint)StateFlags.W : 0;
			reg15Mask = is64bMode ? 0xFU : 0x7;
			handlers_MAP0 = OpCodeHandlersTables_Legacy.Handlers_MAP0;
#if !NO_VEX && MVEX
			handlers_VEX_MAP0 = OpCodeHandlersTables_VEX.Handlers_MAP0;
#endif
#if !NO_VEX
			handlers_VEX_0F = OpCodeHandlersTables_VEX.Handlers_0F;
			handlers_VEX_0F38 = OpCodeHandlersTables_VEX.Handlers_0F38;
			handlers_VEX_0F3A = OpCodeHandlersTables_VEX.Handlers_0F3A;
#endif
#if !NO_EVEX
			handlers_EVEX_0F = OpCodeHandlersTables_EVEX.Handlers_0F;
			handlers_EVEX_0F38 = OpCodeHandlersTables_EVEX.Handlers_0F38;
			handlers_EVEX_0F3A = OpCodeHandlersTables_EVEX.Handlers_0F3A;
			handlers_EVEX_MAP5 = OpCodeHandlersTables_EVEX.Handlers_MAP5;
			handlers_EVEX_MAP6 = OpCodeHandlersTables_EVEX.Handlers_MAP6;
#endif
#if !NO_XOP
			handlers_XOP_MAP8 = OpCodeHandlersTables_XOP.Handlers_MAP8;
			handlers_XOP_MAP9 = OpCodeHandlersTables_XOP.Handlers_MAP9;
			handlers_XOP_MAP10 = OpCodeHandlersTables_XOP.Handlers_MAP10;
#endif
#if MVEX
			handlers_MVEX_0F = OpCodeHandlersTables_MVEX.Handlers_0F;
			handlers_MVEX_0F38 = OpCodeHandlersTables_MVEX.Handlers_0F38;
			handlers_MVEX_0F3A = OpCodeHandlersTables_MVEX.Handlers_0F3A;
#endif
		}

		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="reader">Code reader</param>
		/// <param name="ip"><c>RIP</c> value</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		public static Decoder Create(int bitness, CodeReader reader, ulong ip, DecoderOptions options = DecoderOptions.None) =>
			bitness switch {
				16 or 32 or 64 => new Decoder(reader, ip, options, bitness),
				_ => throw new ArgumentOutOfRangeException(nameof(bitness)),
			};

		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="data">Data to decode</param>
		/// <param name="ip"><c>RIP</c> value</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		public static Decoder Create(int bitness, byte[] data, ulong ip, DecoderOptions options = DecoderOptions.None) =>
			Create(bitness, new ByteArrayCodeReader(data), ip, options);

		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="reader">Code reader</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		public static Decoder Create(int bitness, CodeReader reader, DecoderOptions options = DecoderOptions.None) =>
			Create(bitness, reader, 0, options);

		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="data">Data to decode</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		public static Decoder Create(int bitness, byte[] data, DecoderOptions options = DecoderOptions.None) =>
			Create(bitness, new ByteArrayCodeReader(data), 0, options);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint ReadByte() {
			uint instrLen = state.zs.instructionLength;
			if (instrLen < IcedConstants.MaxInstructionLength) {
				uint b = (uint)reader.ReadByte();
				Debug.Assert(b <= byte.MaxValue || b > int.MaxValue);
				if (b <= byte.MaxValue) {
					state.zs.instructionLength = instrLen + 1;
					return b;
				}
				state.zs.flags |= StateFlags.NoMoreBytes;
			}
			state.zs.flags |= StateFlags.IsInvalid;
			return 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint ReadUInt16() => ReadByte() | (ReadByte() << 8);
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint ReadUInt32() => ReadByte() | (ReadByte() << 8) | (ReadByte() << 16) | (ReadByte() << 24);
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal ulong ReadUInt64() => (ulong)ReadUInt32() | ((ulong)ReadUInt32() << 32);

		/// <summary>
		/// Gets the last decoder error. Unless you need to know the reason it failed,
		/// it's better to check <see cref="Instruction.IsInvalid"/>.
		/// </summary>
		public DecoderError LastError {
			get {
				// NoMoreBytes error has highest priority
				if ((state.zs.flags & StateFlags.NoMoreBytes) != 0)
					return DecoderError.NoMoreBytes;
				if ((state.zs.flags & StateFlags.IsInvalid) != 0)
					return DecoderError.InvalidInstruction;
				return DecoderError.None;
			}
		}

		/// <summary>
		/// Decodes the next instruction, see also <see cref="Decode(out Instruction)"/> which is faster
		/// if you already have an <see cref="Instruction"/> local, array element or field.
		/// <br/>
		/// See also <see cref="LastError"/>
		/// </summary>
		/// <returns></returns>
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public Instruction Decode() {
			Decode(out var instr);
			return instr;
		}

		/// <summary>
		/// Decodes the next instruction, see also <see cref="LastError"/>
		/// </summary>
		/// <param name="instruction">Decoded instruction</param>
		public void Decode(out Instruction instruction) {
			instruction = default;
			state.zs = default;
			state.operandSize = defaultOperandSize;
			state.addressSize = defaultAddressSize;
			uint b = ReadByte();
			if ((b & rexMask) == 0x40) {
				var flags2 = state.zs.flags | StateFlags.HasRex;
				if ((b & 8) != 0) {
					flags2 |= StateFlags.W;
					state.operandSize = OpSize.Size64;
				}
				state.zs.flags = flags2;
				state.zs.extraRegisterBase = (b << 1) & 8;
				state.zs.extraIndexRegisterBase = (b << 2) & 8;
				state.zs.extraBaseRegisterBase = (b << 3) & 8;

				b = ReadByte();
			}
			DecodeTable(handlers_MAP0[b], ref instruction);

			instruction.InternalCodeSize = defaultCodeSize;
			uint instrLen = state.zs.instructionLength;
			Debug.Assert(0 <= instrLen && instrLen <= IcedConstants.MaxInstructionLength);// Could be 0 if there were no bytes available
			instruction.Length = (int)instrLen;
			var ip = instructionPointer;
			ip += instrLen;
			instructionPointer = ip;
			instruction.NextIP = ip;

			var flags = state.zs.flags;
			if ((flags & (StateFlags.IsInvalid | StateFlags.Lock | StateFlags.IpRel32 | StateFlags.IpRel64)) != 0) {
				var addr = instruction.MemoryDisplacement64 + ip;
				instruction.MemoryDisplacement64 = addr;
				// RIP rel ops are common, but invalid/lock bits are usually never set, so exit early if possible
				if ((flags & (StateFlags.IsInvalid | StateFlags.Lock | StateFlags.IpRel64)) == StateFlags.IpRel64)
					return;
				if ((flags & StateFlags.IpRel64) == 0) {
					// Undo what we did above
					instruction.MemoryDisplacement64 = addr - ip;
				}
				if ((flags & StateFlags.IpRel32) != 0)
					instruction.MemoryDisplacement64 = (uint)instruction.MemoryDisplacement64 + (uint)ip;

				if ((flags & StateFlags.IsInvalid) != 0 ||
					(((uint)(flags & (StateFlags.Lock | StateFlags.AllowLock)) & invalidCheckMask) == (uint)StateFlags.Lock)) {
					instruction = default;
					Static.Assert(Code.INVALID == 0 ? 0 : -1);
					//instruction.Code = Code.INVALID;
					state.zs.flags = flags | StateFlags.IsInvalid;

					instruction.InternalCodeSize = defaultCodeSize;
					instruction.Length = (int)instrLen;
					instruction.NextIP = ip;
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ResetRexPrefixState() {
			state.zs.flags &= ~(StateFlags.HasRex | StateFlags.W);
			if ((state.zs.flags & StateFlags.Has66) == 0)
				state.operandSize = defaultOperandSize;
			else
				state.operandSize = defaultInvertedOperandSize;
			state.zs.extraRegisterBase = 0;
			state.zs.extraIndexRegisterBase = 0;
			state.zs.extraBaseRegisterBase = 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void CallOpCodeHandlerXXTable(ref Instruction instruction) {
			var b = ReadByte();
			DecodeTable(handlers_MAP0[b], ref instruction);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint GetCurrentInstructionPointer32() => (uint)instructionPointer + state.zs.instructionLength;
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal ulong GetCurrentInstructionPointer64() => instructionPointer + state.zs.instructionLength;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearMandatoryPrefix(ref Instruction instruction) {
			Debug.Assert(state.Encoding == EncodingKind.Legacy);
			instruction.InternalClearHasRepeRepnePrefix();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SetXacquireXrelease(ref Instruction instruction) {
			if (instruction.HasLockPrefix) {
				if (state.zs.mandatoryPrefix == MandatoryPrefixByte.PF2) {
					ClearMandatoryPrefixF2(ref instruction);
					instruction.InternalSetHasXacquirePrefix();
				}
				else if (state.zs.mandatoryPrefix == MandatoryPrefixByte.PF3) {
					ClearMandatoryPrefixF3(ref instruction);
					instruction.InternalSetHasXreleasePrefix();
				}
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearMandatoryPrefixF3(ref Instruction instruction) {
			Debug.Assert(state.Encoding == EncodingKind.Legacy);
			Debug.Assert(state.zs.mandatoryPrefix == MandatoryPrefixByte.PF3);
			instruction.InternalClearHasRepePrefix();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearMandatoryPrefixF2(ref Instruction instruction) {
			Debug.Assert(state.Encoding == EncodingKind.Legacy);
			Debug.Assert(state.zs.mandatoryPrefix == MandatoryPrefixByte.PF2);
			instruction.InternalClearHasRepnePrefix();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SetInvalidInstruction() => state.zs.flags |= StateFlags.IsInvalid;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DecodeTable(OpCodeHandler[] table, ref Instruction instruction) => DecodeTable(table[(int)ReadByte()], ref instruction);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		void DecodeTable(OpCodeHandler handler, ref Instruction instruction) {
			if (handler.HasModRM) {
				uint m = ReadByte();
				state.modrm = m;
				state.mod = m >> 6;
				state.reg = (m >> 3) & 7;
				state.rm = m & 7;
			}
			handler.Decode(this, ref instruction);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadModRM() {
			uint m = ReadByte();
			state.modrm = m;
			state.mod = m >> 6;
			state.reg = (m >> 3) & 7;
			state.rm = m & 7;
		}

		internal void VEX2(ref Instruction instruction) {
#if NO_VEX
			SetInvalidInstruction();
#else
			if ((((uint)(state.zs.flags & StateFlags.HasRex) | (uint)state.zs.mandatoryPrefix) & invalidCheckMask) != 0)
				SetInvalidInstruction();
			// Undo what Decode() did if it got a REX prefix
			state.zs.flags &= ~StateFlags.W;
			state.zs.extraIndexRegisterBase = 0;
			state.zs.extraBaseRegisterBase = 0;

#if DEBUG
			state.zs.flags |= (StateFlags)((uint)EncodingKind.VEX << (int)StateFlags.EncodingShift);
#endif
			uint b = state.modrm;

			Static.Assert((int)VectorLength.L128 == 0 ? 0 : -1);
			Static.Assert((int)VectorLength.L256 == 1 ? 0 : -1);
			state.vectorLength = (b >> 2) & 1;

			Static.Assert((int)MandatoryPrefixByte.None == 0 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.P66 == 1 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF3 == 2 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF2 == 3 ? 0 : -1);
			state.zs.mandatoryPrefix = (MandatoryPrefixByte)(b & 3);

			b = ~b;
			state.zs.extraRegisterBase = (b >> 4) & 8;

			// Bit 6 can only be 1 if it's 16/32-bit mode, so we don't need to change the mask
			b = (b >> 3) & 0x0F;
			state.vvvv = b;
			state.vvvv_invalidCheck = b;

			DecodeTable(handlers_VEX_0F, ref instruction);
#endif
		}

		internal void VEX3(ref Instruction instruction) {
#if NO_VEX
			SetInvalidInstruction();
#else
			if ((((uint)(state.zs.flags & StateFlags.HasRex) | (uint)state.zs.mandatoryPrefix) & invalidCheckMask) != 0)
				SetInvalidInstruction();
			// Undo what Decode() did if it got a REX prefix
			state.zs.flags &= ~StateFlags.W;

#if DEBUG
			state.zs.flags |= (StateFlags)((uint)EncodingKind.VEX << (int)StateFlags.EncodingShift);
#endif
			uint b2 = ReadByte();

			Static.Assert((int)StateFlags.W == 0x80 ? 0 : -1);
			state.zs.flags |= (StateFlags)(b2 & 0x80);

			Static.Assert((int)VectorLength.L128 == 0 ? 0 : -1);
			Static.Assert((int)VectorLength.L256 == 1 ? 0 : -1);
			state.vectorLength = (b2 >> 2) & 1;

			Static.Assert((int)MandatoryPrefixByte.None == 0 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.P66 == 1 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF3 == 2 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF2 == 3 ? 0 : -1);
			state.zs.mandatoryPrefix = (MandatoryPrefixByte)(b2 & 3);

			b2 = (~b2 >> 3) & 0x0F;
			state.vvvv_invalidCheck = b2;
			state.vvvv = b2 & reg15Mask;
			uint b1 = state.modrm;
			uint b1x = ~b1 & maskE0;
			state.zs.extraRegisterBase = (b1x >> 4) & 8;
			state.zs.extraIndexRegisterBase = (b1x >> 3) & 8;
			state.zs.extraBaseRegisterBase = (b1x >> 2) & 8;

			OpCodeHandler[] handlers;
			var b = ReadByte();
			int table = (int)(b1 & 0x1F);
			if (table == 1)
				handlers = handlers_VEX_0F;
			else if (table == 2)
				handlers = handlers_VEX_0F38;
			else if (table == 3)
				handlers = handlers_VEX_0F3A;
#if MVEX
			else if (table == 0)
				handlers = handlers_VEX_MAP0;
#endif
			else {
				SetInvalidInstruction();
				return;
			}
			DecodeTable(handlers[b], ref instruction);
#endif
		}

		internal void XOP(ref Instruction instruction) {
#if NO_XOP
			SetInvalidInstruction();
#else
			if ((((uint)(state.zs.flags & StateFlags.HasRex) | (uint)state.zs.mandatoryPrefix) & invalidCheckMask) != 0)
				SetInvalidInstruction();
			// Undo what Decode() did if it got a REX prefix
			state.zs.flags &= ~StateFlags.W;

#if DEBUG
			state.zs.flags |= (StateFlags)((uint)EncodingKind.XOP << (int)StateFlags.EncodingShift);
#endif
			uint b2 = ReadByte();

			Static.Assert((int)StateFlags.W == 0x80 ? 0 : -1);
			state.zs.flags |= (StateFlags)(b2 & 0x80);

			Static.Assert((int)VectorLength.L128 == 0 ? 0 : -1);
			Static.Assert((int)VectorLength.L256 == 1 ? 0 : -1);
			state.vectorLength = (b2 >> 2) & 1;

			Static.Assert((int)MandatoryPrefixByte.None == 0 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.P66 == 1 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF3 == 2 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF2 == 3 ? 0 : -1);
			state.zs.mandatoryPrefix = (MandatoryPrefixByte)(b2 & 3);

			b2 = (~b2 >> 3) & 0x0F;
			state.vvvv_invalidCheck = b2;
			state.vvvv = b2 & reg15Mask;
			uint b1 = state.modrm;
			uint b1x = ~b1 & maskE0;
			state.zs.extraRegisterBase = (b1x >> 4) & 8;
			state.zs.extraIndexRegisterBase = (b1x >> 3) & 8;
			state.zs.extraBaseRegisterBase = (b1x >> 2) & 8;

			OpCodeHandler[] handlers;
			var b = ReadByte();
			int table = (int)(b1 & 0x1F);
			if (table == 8)
				handlers = handlers_XOP_MAP8;
			else if (table == 9)
				handlers = handlers_XOP_MAP9;
			else if (table == 10)
				handlers = handlers_XOP_MAP10;
			else {
				SetInvalidInstruction();
				return;
			}
			DecodeTable(handlers[b], ref instruction);
#endif
		}

		internal void EVEX_MVEX(ref Instruction instruction) {
#if NO_EVEX && !MVEX
			SetInvalidInstruction();
#else
			if ((((uint)(state.zs.flags & StateFlags.HasRex) | (uint)state.zs.mandatoryPrefix) & invalidCheckMask) != 0)
				SetInvalidInstruction();
			// Undo what Decode() did if it got a REX prefix
			state.zs.flags &= ~StateFlags.W;

			uint p0 = state.modrm;
			uint p1 = ReadByte();
			uint p2 = ReadByte();
			uint p3 = ReadByte();
			uint p4 = ReadByte();

			if ((p1 & 4) != 0) {
#if NO_EVEX
				SetInvalidInstruction();
#else
				if ((p0 & 8) == 0) {
#if DEBUG
					state.zs.flags |= (StateFlags)((uint)EncodingKind.EVEX << (int)StateFlags.EncodingShift);
#endif

					Static.Assert((int)MandatoryPrefixByte.None == 0 ? 0 : -1);
					Static.Assert((int)MandatoryPrefixByte.P66 == 1 ? 0 : -1);
					Static.Assert((int)MandatoryPrefixByte.PF3 == 2 ? 0 : -1);
					Static.Assert((int)MandatoryPrefixByte.PF2 == 3 ? 0 : -1);
					state.zs.mandatoryPrefix = (MandatoryPrefixByte)(p1 & 3);

					Static.Assert((int)StateFlags.W == 0x80 ? 0 : -1);
					state.zs.flags |= (StateFlags)(p1 & 0x80);

					uint aaa = p2 & 7;
					state.aaa = aaa;
					instruction.InternalOpMask = aaa;
					if ((p2 & 0x80) != 0) {
						// invalid if aaa == 0 and if we check for invalid instructions (it's all 1s)
						if ((aaa ^ invalidCheckMask) == uint.MaxValue)
							SetInvalidInstruction();
						state.zs.flags |= StateFlags.z;
						instruction.InternalSetZeroingMasking();
					}

					Static.Assert((int)StateFlags.b == 0x10 ? 0 : -1);
					state.zs.flags |= (StateFlags)(p2 & 0x10);

					Static.Assert((int)VectorLength.L128 == 0 ? 0 : -1);
					Static.Assert((int)VectorLength.L256 == 1 ? 0 : -1);
					Static.Assert((int)VectorLength.L512 == 2 ? 0 : -1);
					Static.Assert((int)VectorLength.Unknown == 3 ? 0 : -1);
					state.vectorLength = (p2 >> 5) & 3;

					p1 = (~p1 >> 3) & 0x0F;
					if (is64bMode) {
						uint tmp = (~p2 & 8) << 1;
						state.zs.extraIndexRegisterBaseVSIB = tmp;
						tmp += p1;
						state.vvvv = tmp;
						state.vvvv_invalidCheck = tmp;
						uint p0x = ~p0;
						state.zs.extraRegisterBase = (p0x >> 4) & 8;
						state.zs.extraIndexRegisterBase = (p0x >> 3) & 8;
						state.extraRegisterBaseEVEX = p0x & 0x10;
						p0x >>= 2;
						state.extraBaseRegisterBaseEVEX = p0x & 0x18;
						state.zs.extraBaseRegisterBase = p0x & 8;
					}
					else {
						state.vvvv_invalidCheck = p1;
						state.vvvv = p1 & 0x07;
						Static.Assert((int)StateFlags.IsInvalid == 0x40 ? 0 : -1);
						state.zs.flags |= (StateFlags)((~p2 & 8) << 3);
					}

					OpCodeHandler[] handlers;
					switch ((int)(p0 & 7)) {
					case 1: handlers = handlers_EVEX_0F; break;
					case 2: handlers = handlers_EVEX_0F38; break;
					case 3: handlers = handlers_EVEX_0F3A; break;
					case 5: handlers = handlers_EVEX_MAP5; break;
					case 6: handlers = handlers_EVEX_MAP6; break;
					default:
						SetInvalidInstruction();
						return;
					}
					var handler = handlers[(int)p3];
					Debug.Assert(handler.HasModRM);
					state.modrm = p4;
					state.mod = p4 >> 6;
					state.reg = (p4 >> 3) & 7;
					state.rm = p4 & 7;
					// Invalid if LL=3 and no rc
					Static.Assert((uint)StateFlags.b > 3 ? 0 : -1);
					if ((((uint)(state.zs.flags & StateFlags.b) | state.vectorLength) & invalidCheckMask) == 3)
						SetInvalidInstruction();
					handler.Decode(this, ref instruction);
				}
				else
					SetInvalidInstruction();
#endif
			}
			else {
#if !MVEX
				SetInvalidInstruction();
#else
				if ((options & DecoderOptions.KNC) == 0 || !is64bMode)
					SetInvalidInstruction();
				else {
#if DEBUG
					state.zs.flags |= (StateFlags)((uint)EncodingKind.MVEX << (int)StateFlags.EncodingShift);
#endif

					Static.Assert((int)MandatoryPrefixByte.None == 0 ? 0 : -1);
					Static.Assert((int)MandatoryPrefixByte.P66 == 1 ? 0 : -1);
					Static.Assert((int)MandatoryPrefixByte.PF3 == 2 ? 0 : -1);
					Static.Assert((int)MandatoryPrefixByte.PF2 == 3 ? 0 : -1);
					state.zs.mandatoryPrefix = (MandatoryPrefixByte)(p1 & 3);

					Static.Assert((int)StateFlags.W == 0x80 ? 0 : -1);
					state.zs.flags |= (StateFlags)(p1 & 0x80);

					uint aaa = p2 & 7;
					state.aaa = aaa;
					instruction.InternalOpMask = aaa;

					Static.Assert((int)StateFlags.MvexSssShift == 16 ? 0 : -1);
					Static.Assert((int)StateFlags.MvexSssMask == 7 ? 0 : -1);
					Static.Assert((int)StateFlags.MvexEH == 1 << ((int)StateFlags.MvexSssShift + 3) ? 0 : -1);
					state.zs.flags |= (StateFlags)((p2 & 0xF0) << ((int)StateFlags.MvexSssShift - 4));

					p1 = (~p1 >> 3) & 0x0F;
					uint tmp = (~p2 & 8) << 1;
					state.zs.extraIndexRegisterBaseVSIB = tmp;
					tmp += p1;
					state.vvvv = tmp;
					state.vvvv_invalidCheck = tmp;
					uint p0x = ~p0;
					state.zs.extraRegisterBase = (p0x >> 4) & 8;
					state.zs.extraIndexRegisterBase = (p0x >> 3) & 8;
					state.extraRegisterBaseEVEX = p0x & 0x10;
					p0x >>= 2;
					state.extraBaseRegisterBaseEVEX = p0x & 0x18;
					state.zs.extraBaseRegisterBase = p0x & 8;

					OpCodeHandler[] handlers;
					switch ((int)(p0 & 0xF)) {
					case 1: handlers = handlers_MVEX_0F; break;
					case 2: handlers = handlers_MVEX_0F38; break;
					case 3: handlers = handlers_MVEX_0F3A; break;
					default:
						SetInvalidInstruction();
						return;
					}
					var handler = handlers[(int)p3];
					Debug.Assert(handler.HasModRM);
					state.modrm = p4;
					state.mod = p4 >> 6;
					state.reg = (p4 >> 3) & 7;
					state.rm = p4 & 7;
					handler.Decode(this, ref instruction);
				}
#endif
			}
#endif
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal Register ReadOpSegReg() {
			uint reg = state.reg;
			if (reg < 6)
				return Register.ES + (int)reg;
			SetInvalidInstruction();
			return Register.None;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal bool ReadOpMem(ref Instruction instruction) {
			Debug.Assert(state.Encoding != EncodingKind.EVEX && state.Encoding != EncodingKind.MVEX);
			if (state.addressSize == OpSize.Size64)
				return ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, TupleType.N1, false);
			else if (state.addressSize == OpSize.Size32)
				return ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, TupleType.N1, false);
			else {
				ReadOpMem16(ref instruction, TupleType.N1);
				return false;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadOpMemSib(ref Instruction instruction) {
			Debug.Assert(state.Encoding != EncodingKind.EVEX && state.Encoding != EncodingKind.MVEX);
			bool isValid;
			if (state.addressSize == OpSize.Size64)
				isValid = ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, TupleType.N1, false);
			else if (state.addressSize == OpSize.Size32)
				isValid = ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, TupleType.N1, false);
			else {
				ReadOpMem16(ref instruction, TupleType.N1);
				isValid = false;
			}
			if (invalidCheckMask != 0 && !isValid)
				SetInvalidInstruction();
		}

		// All MPX instructions in 64-bit mode force 64-bit addressing, and
		// all MPX instructions in 16/32-bit mode require 32-bit addressing
		// (see SDM Vol 1, 17.5.1 Intel MPX and Operating Modes)
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadOpMem_MPX(ref Instruction instruction) {
			Debug.Assert(state.Encoding != EncodingKind.EVEX && state.Encoding != EncodingKind.MVEX);
			if (is64bMode) {
				state.addressSize = OpSize.Size64;
				ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, TupleType.N1, false);
			}
			else if (state.addressSize == OpSize.Size32)
				ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, TupleType.N1, false);
			else {
				ReadOpMem16(ref instruction, TupleType.N1);
				if (invalidCheckMask != 0)
					SetInvalidInstruction();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadOpMem(ref Instruction instruction, TupleType tupleType) {
			Debug.Assert(state.Encoding == EncodingKind.EVEX || state.Encoding == EncodingKind.MVEX);
			if (state.addressSize == OpSize.Size64)
				ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, tupleType, false);
			else if (state.addressSize == OpSize.Size32)
				ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, tupleType, false);
			else
				ReadOpMem16(ref instruction, tupleType);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadOpMem_VSIB(ref Instruction instruction, Register vsibIndex, TupleType tupleType) {
			bool isValid;
			if (state.addressSize == OpSize.Size64)
				isValid = ReadOpMem32Or64(ref instruction, Register.RAX, vsibIndex, tupleType, true);
			else if (state.addressSize == OpSize.Size32)
				isValid = ReadOpMem32Or64(ref instruction, Register.EAX, vsibIndex, tupleType, true);
			else {
				ReadOpMem16(ref instruction, tupleType);
				isValid = false;
			}
			if (invalidCheckMask != 0 && !isValid)
				SetInvalidInstruction();
		}

		readonly struct RegInfo2 {
			public readonly Register baseReg;
			public readonly Register indexReg;
			public RegInfo2(Register baseReg, Register indexReg) {
				this.baseReg = baseReg;
				this.indexReg = indexReg;
			}
			public void Deconstruct(out Register baseReg, out Register indexReg) {
				baseReg = this.baseReg;
				indexReg = this.indexReg;
			}
		}
		static readonly RegInfo2[] s_memRegs16 = new RegInfo2[8] {
			new RegInfo2(Register.BX, Register.SI),
			new RegInfo2(Register.BX, Register.DI),
			new RegInfo2(Register.BP, Register.SI),
			new RegInfo2(Register.BP, Register.DI),
			new RegInfo2(Register.SI, Register.None),
			new RegInfo2(Register.DI, Register.None),
			new RegInfo2(Register.BP, Register.None),
			new RegInfo2(Register.BX, Register.None),
		};
		void ReadOpMem16(ref Instruction instruction, TupleType tupleType) {
			Debug.Assert(state.addressSize == OpSize.Size16);
			var (baseReg, indexReg) = memRegs16[(int)state.rm];
			switch ((int)state.mod) {
			case 0:
				if (state.rm == 6) {
					instruction.InternalSetMemoryDisplSize(2);
					displIndex = state.zs.instructionLength;
					instruction.MemoryDisplacement64 = ReadUInt16();
					baseReg = Register.None;
					Debug.Assert(indexReg == Register.None);
				}
				break;

			case 1:
				instruction.InternalSetMemoryDisplSize(1);
				displIndex = state.zs.instructionLength;
				if (tupleType == TupleType.N1)
					instruction.MemoryDisplacement64 = (ushort)(sbyte)ReadByte();
				else
					instruction.MemoryDisplacement64 = (ushort)(GetDisp8N(tupleType) * (uint)(sbyte)ReadByte());
				break;

			default:
				Debug.Assert(state.mod == 2);
				instruction.InternalSetMemoryDisplSize(2);
				displIndex = state.zs.instructionLength;
				instruction.MemoryDisplacement64 = ReadUInt16();
				break;
			}

			instruction.InternalMemoryBase = baseReg;
			instruction.InternalMemoryIndex = indexReg;
		}

		// Returns true if the SIB byte was read
		bool ReadOpMem32Or64(ref Instruction instruction, Register baseReg, Register indexReg, TupleType tupleType, bool isVsib) {
			Debug.Assert(state.addressSize == OpSize.Size32 || state.addressSize == OpSize.Size64);
			uint sib;
			uint displSizeScale, displ;
			switch ((int)state.mod) {
			case 0:
				if (state.rm == 4) {
					sib = ReadByte();
					displSizeScale = 0;
					displ = 0;
					break;
				}
				else if (state.rm == 5) {
					displIndex = state.zs.instructionLength;
					if (state.addressSize == OpSize.Size64) {
						instruction.MemoryDisplacement64 = (ulong)(int)ReadUInt32();
						instruction.InternalSetMemoryDisplSize(4);
					}
					else {
						instruction.MemoryDisplacement64 = ReadUInt32();
						instruction.InternalSetMemoryDisplSize(3);
					}
					if (is64bMode) {
						if (state.addressSize == OpSize.Size64) {
							state.zs.flags |= StateFlags.IpRel64;
							instruction.InternalMemoryBase = Register.RIP;
						}
						else {
							state.zs.flags |= StateFlags.IpRel32;
							instruction.InternalMemoryBase = Register.EIP;
						}
					}
					return false;
				}
				else {
					Debug.Assert(0 <= state.rm && state.rm <= 7 && state.rm != 4 && state.rm != 5);
					instruction.InternalMemoryBase = (int)(state.zs.extraBaseRegisterBase + state.rm) + baseReg;
					return false;
				}

			case 1:
				if (state.rm == 4) {
					sib = ReadByte();
					displSizeScale = 1;
					displIndex = state.zs.instructionLength;
					if (tupleType == TupleType.N1)
						displ = (uint)(sbyte)ReadByte();
					else
						displ = GetDisp8N(tupleType) * (uint)(sbyte)ReadByte();
					break;
				}
				else {
					Debug.Assert(0 <= state.rm && state.rm <= 7 && state.rm != 4);
					instruction.InternalSetMemoryDisplSize(1);
					displIndex = state.zs.instructionLength;
					if (state.addressSize == OpSize.Size64) {
						if (tupleType == TupleType.N1)
							instruction.MemoryDisplacement64 = (ulong)(sbyte)ReadByte();
						else
							instruction.MemoryDisplacement64 = (ulong)GetDisp8N(tupleType) * (ulong)(sbyte)ReadByte();
					}
					else {
						if (tupleType == TupleType.N1)
							instruction.MemoryDisplacement64 = (uint)(sbyte)ReadByte();
						else
							instruction.MemoryDisplacement64 = GetDisp8N(tupleType) * (uint)(sbyte)ReadByte();
					}
					instruction.InternalMemoryBase = (int)(state.zs.extraBaseRegisterBase + state.rm) + baseReg;
					return false;
				}

			default:
				Debug.Assert(state.mod == 2);
				if (state.rm == 4) {
					sib = ReadByte();
					displSizeScale = state.addressSize == OpSize.Size64 ? 4U : 3;
					displIndex = state.zs.instructionLength;
					displ = ReadUInt32();
					break;
				}
				else {
					Debug.Assert(0 <= state.rm && state.rm <= 7 && state.rm != 4);
					displIndex = state.zs.instructionLength;
					if (state.addressSize == OpSize.Size64) {
						instruction.MemoryDisplacement64 = (ulong)(int)ReadUInt32();
						instruction.InternalSetMemoryDisplSize(4);
					}
					else {
						instruction.MemoryDisplacement64 = ReadUInt32();
						instruction.InternalSetMemoryDisplSize(3);
					}
					instruction.InternalMemoryBase = (int)(state.zs.extraBaseRegisterBase + state.rm) + baseReg;
					return false;
				}
			}

			uint index = ((sib >> 3) & 7) + state.zs.extraIndexRegisterBase;
			uint @base = sib & 7;

			instruction.InternalMemoryIndexScale = (int)(sib >> 6);
			if (!isVsib) {
				if (index != 4)
					instruction.InternalMemoryIndex = (int)index + indexReg;
			}
			else
				instruction.InternalMemoryIndex = (int)(index + state.zs.extraIndexRegisterBaseVSIB) + indexReg;

			if (@base == 5 && state.mod == 0) {
				displIndex = state.zs.instructionLength;
				if (state.addressSize == OpSize.Size64) {
					instruction.MemoryDisplacement64 = (ulong)(int)ReadUInt32();
					instruction.InternalSetMemoryDisplSize(4);
				}
				else {
					instruction.MemoryDisplacement64 = ReadUInt32();
					instruction.InternalSetMemoryDisplSize(3);
				}
			}
			else {
				instruction.InternalMemoryBase = (int)(@base + state.zs.extraBaseRegisterBase) + baseReg;
				instruction.InternalSetMemoryDisplSize(displSizeScale);
				if (state.addressSize == OpSize.Size64)
					instruction.MemoryDisplacement64 = (ulong)(int)displ;
				else
					instruction.MemoryDisplacement64 = displ;
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		uint GetDisp8N(TupleType tupleType) =>
			TupleTypeTable.GetDisp8N(tupleType, (state.zs.flags & StateFlags.b) != 0);

		/// <summary>
		/// Gets the offsets of the constants (memory displacement and immediate) in the decoded instruction.
		/// The caller can check if there are any relocations at those addresses.
		/// </summary>
		/// <param name="instruction">The latest instruction that was decoded by this decoder</param>
		/// <returns></returns>
		public ConstantOffsets GetConstantOffsets(in Instruction instruction) {
			ConstantOffsets constantOffsets = default;

			int displSize = instruction.MemoryDisplSize;
			if (displSize != 0) {
				constantOffsets.DisplacementOffset = (byte)displIndex;
				if (displSize == 8 && (state.zs.flags & StateFlags.Addr64) == 0)
					constantOffsets.DisplacementSize = 4;
				else
					constantOffsets.DisplacementSize = (byte)displSize;
			}

			if ((state.zs.flags & StateFlags.NoImm) == 0) {
				int extraImmSub = 0;
				for (int i = instruction.OpCount - 1; i >= 0; i--) {
					switch (instruction.GetOpKind(i)) {
					case OpKind.Immediate8:
					case OpKind.Immediate8to16:
					case OpKind.Immediate8to32:
					case OpKind.Immediate8to64:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - extraImmSub - 1);
						constantOffsets.ImmediateSize = 1;
						goto after_imm_loop;

					case OpKind.Immediate16:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - extraImmSub - 2);
						constantOffsets.ImmediateSize = 2;
						goto after_imm_loop;

					case OpKind.Immediate32:
					case OpKind.Immediate32to64:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - extraImmSub - 4);
						constantOffsets.ImmediateSize = 4;
						goto after_imm_loop;

					case OpKind.Immediate64:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - extraImmSub - 8);
						constantOffsets.ImmediateSize = 8;
						goto after_imm_loop;

					case OpKind.Immediate8_2nd:
						constantOffsets.ImmediateOffset2 = (byte)(instruction.Length - 1);
						constantOffsets.ImmediateSize2 = 1;
						extraImmSub = 1;
						break;

					case OpKind.NearBranch16:
						if ((state.zs.flags & StateFlags.BranchImm8) != 0) {
							constantOffsets.ImmediateOffset = (byte)(instruction.Length - 1);
							constantOffsets.ImmediateSize = 1;
						}
						else if ((state.zs.flags & StateFlags.Xbegin) == 0) {
							constantOffsets.ImmediateOffset = (byte)(instruction.Length - 2);
							constantOffsets.ImmediateSize = 2;
						}
						else {
							Debug.Assert((state.zs.flags & StateFlags.Xbegin) != 0);
							if (state.operandSize != OpSize.Size16) {
								constantOffsets.ImmediateOffset = (byte)(instruction.Length - 4);
								constantOffsets.ImmediateSize = 4;
							}
							else {
								constantOffsets.ImmediateOffset = (byte)(instruction.Length - 2);
								constantOffsets.ImmediateSize = 2;
							}
						}
						break;

					case OpKind.NearBranch32:
					case OpKind.NearBranch64:
						if ((state.zs.flags & StateFlags.BranchImm8) != 0) {
							constantOffsets.ImmediateOffset = (byte)(instruction.Length - 1);
							constantOffsets.ImmediateSize = 1;
						}
						else if ((state.zs.flags & StateFlags.Xbegin) == 0) {
							constantOffsets.ImmediateOffset = (byte)(instruction.Length - 4);
							constantOffsets.ImmediateSize = 4;
						}
						else {
							Debug.Assert((state.zs.flags & StateFlags.Xbegin) != 0);
							if (state.operandSize != OpSize.Size16) {
								constantOffsets.ImmediateOffset = (byte)(instruction.Length - 4);
								constantOffsets.ImmediateSize = 4;
							}
							else {
								constantOffsets.ImmediateOffset = (byte)(instruction.Length - 2);
								constantOffsets.ImmediateSize = 2;
							}
						}
						break;

					case OpKind.FarBranch16:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - (2 + 2));
						constantOffsets.ImmediateSize = 2;
						constantOffsets.ImmediateOffset2 = (byte)(instruction.Length - 2);
						constantOffsets.ImmediateSize2 = 2;
						break;

					case OpKind.FarBranch32:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - (4 + 2));
						constantOffsets.ImmediateSize = 4;
						constantOffsets.ImmediateOffset2 = (byte)(instruction.Length - 2);
						constantOffsets.ImmediateSize2 = 2;
						break;
					}
				}
			}
after_imm_loop:

			return constantOffsets;
		}

		/// <summary>
		/// An <see cref="Instruction"/> enumerator
		/// </summary>
		public struct Enumerator : IEnumerator<Instruction> {
			readonly Decoder decoder;
			Instruction instruction;

			internal Enumerator(Decoder decoder) {
				this.decoder = decoder;
				instruction = default;
			}

			/// <summary>
			/// Gets the current instruction
			/// </summary>
			public Instruction Current => instruction; // Can't use `readonly ref`
			Instruction IEnumerator<Instruction>.Current => Current;
			object IEnumerator.Current => Current;

			/// <summary>
			/// Decodes the next instruction
			/// </summary>
			/// <returns></returns>
			public bool MoveNext() {
				decoder.Decode(out instruction);
				// If it has length 0, there was no more data
				return instruction.Length != 0;
			}

			void IEnumerator.Reset() => throw new InvalidOperationException();

			/// <summary>
			/// Disposes of this instance
			/// </summary>
			public void Dispose() { }
		}

		/// <summary>
		/// Gets the <see cref="Instruction"/> enumerator
		/// </summary>
		/// <returns></returns>
		public Enumerator GetEnumerator() => new Enumerator(this);
		IEnumerator<Instruction> IEnumerable<Instruction>.GetEnumerator() => GetEnumerator();
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}
}
#endif
