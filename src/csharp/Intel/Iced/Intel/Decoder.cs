// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

#if DECODER
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Iced.Intel.DecoderInternal;

namespace Iced.Intel {
	// GENERATOR-BEGIN: OpSize
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	enum OpSize : byte {
		Size16,
		Size32,
		Size64,
	}
	// GENERATOR-END: OpSize

	// GENERATOR-BEGIN: StateFlags
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	[Flags]
	enum StateFlags : uint {
		EncodingMask = 0x00000007,
		HasRex = 0x00000008,
		b = 0x00000010,
		z = 0x00000020,
		IsInvalid = 0x00000040,
		W = 0x00000080,
		NoImm = 0x00000100,
		Addr64 = 0x00000200,
		BranchImm8 = 0x00000400,
		Xbegin = 0x00000800,
		Lock = 0x00001000,
		AllowLock = 0x00002000,
		NoMoreBytes = 0x00004000,
		Has66 = 0x00008000,
		IpRel = 0x00010000,
	}
	// GENERATOR-END: StateFlags

	/// <summary>
	/// Decodes 16/32/64-bit x86 instructions
	/// </summary>
	public sealed class Decoder : IEnumerable<Instruction> {
		ulong instructionPointer;
		readonly CodeReader reader;
		readonly uint[] prefixes;
		readonly RegInfo2[] memRegs16;
		readonly OpCodeHandler[] handlers_XX;
		readonly OpCodeHandler[] handlers_0FXX;
#if !NO_VEX
		readonly OpCodeHandler[] handlers_VEX_0FXX;
		readonly OpCodeHandler[] handlers_VEX_0F38XX;
		readonly OpCodeHandler[] handlers_VEX_0F3AXX;
#endif
#if !NO_EVEX
		readonly OpCodeHandler[] handlers_EVEX_0FXX;
		readonly OpCodeHandler[] handlers_EVEX_0F38XX;
		readonly OpCodeHandler[] handlers_EVEX_0F3AXX;
#endif
#if !NO_XOP
		readonly OpCodeHandler[] handlers_XOP8;
		readonly OpCodeHandler[] handlers_XOP9;
		readonly OpCodeHandler[] handlers_XOPA;
#endif
		internal State state;
		internal uint displIndex;
		internal readonly DecoderOptions options;
		internal readonly uint invalidCheckMask;// All 1s if we should check for invalid instructions, else 0
		internal readonly uint is64bMode_and_W;// StateFlags.W if 64-bit mode, 0 if 16/32-bit mode
		internal readonly uint reg15Mask;// 7 in 16/32-bit mode, 15 in 64-bit mode
		internal readonly CodeSize defaultCodeSize;
		readonly OpSize defaultOperandSize;
		readonly OpSize defaultAddressSize;
		readonly OpSize defaultInvertedOperandSize;
		readonly OpSize defaultInvertedAddressSize;
		internal readonly bool is64bMode;

		internal struct State {
			public uint modrm, mod, reg, rm;
			public uint instructionLength;
			public uint extraRegisterBase;		// R << 3
			public uint extraIndexRegisterBase;	// X << 3
			public uint extraBaseRegisterBase;	// B << 3
			public uint extraIndexRegisterBaseVSIB;
			public StateFlags flags;
			public MandatoryPrefixByte mandatoryPrefix;
			public uint vvvv;// V`vvvv. Not stored in inverted form. If 16/32-bit mode, bits [4:3] are cleared
			public uint vvvv_invalidCheck;// vvvv bits, even in 16/32-bit mode.
			public uint aaa;
			public uint extraRegisterBaseEVEX;		// EVEX.R' << 4
			public uint extraBaseRegisterBaseEVEX;	// EVEX.XB << 3
			public uint vectorLength;
			public OpSize operandSize;
			public OpSize addressSize;
			public readonly EncodingKind Encoding => (EncodingKind)(flags & StateFlags.EncodingMask);
		}

		/// <summary>
		/// Current <c>IP</c>/<c>EIP</c>/<c>RIP</c> value.<br/>
		/// <br/>
		/// Writing to this property only updates the IP value, it does not change a <see cref="CodeReader"/>'s byte position.
		/// You can use <see cref="ByteArrayCodeReader.Position"/> to change its position.
		/// </summary>
		public ulong IP {
			get => instructionPointer;
			set => instructionPointer = value;
		}

		/// <summary>
		/// Gets the bitness (16, 32 or 64)
		/// </summary>
		public int Bitness { get; }

		// 0F,26,2E,36,3E,64,65,66,67,F0,F2,F3
		static readonly uint[] prefixes1632 = new uint[8] {
			0x00008000, 0x40404040, 0x00000000, 0x000000F0,
			0x00000000, 0x00000000, 0x00000000, 0x000D0000,
		};
		// 0F,26,2E,36,3E,64,65,66,67,F0,F2,F3 and 40-4F
		static readonly uint[] prefixes64 = new uint[8] {
			0x00008000, 0x40404040, 0x0000FFFF, 0x000000F0,
			0x00000000, 0x00000000, 0x00000000, 0x000D0000,
		};

		static Decoder() {
			// Initialize cctors that are used by decoder related methods. It doesn't speed up
			// decoding much, but getting instruction info is a little faster.
			_ = OpCodeHandler_Invalid.Instance;
			_ = InstructionMemorySizes.Sizes;
#if !NO_D3NOW
			_ = OpCodeHandler_D3NOW.CodeValues;
#endif
			_ = InstructionOpCounts.OpCount;
			_ = MnemonicUtilsData.toMnemonic;
#if !HAS_SPAN
			_ = TupleTypeTable.tupleTypeData;
#endif
#if INSTR_INFO
			_ = RegisterExtensions.RegisterInfos;
			_ = MemorySizeExtensions.MemorySizeInfos;
			_ = InstructionInfoInternal.InstrInfoTable.Data;
			_ = InstructionInfoInternal.RflagsInfoConstants.flagsCleared;
			_ = InstructionInfoInternal.CpuidFeatureInternalData.ToCpuidFeatures;
			_ = InstructionInfoInternal.SimpleList<UsedRegister>.Empty;
			_ = InstructionInfoInternal.SimpleList<UsedMemory>.Empty;
#endif
		}

		Decoder(CodeReader reader, ulong ip, DecoderOptions options, int bitness) {
			this.reader = reader ?? throw new ArgumentNullException(nameof(reader));
			instructionPointer = ip;
			this.options = options;
			invalidCheckMask = (options & DecoderOptions.NoInvalidCheck) == 0 ? uint.MaxValue : 0;
			memRegs16 = s_memRegs16;
			Bitness = bitness;
			if (bitness == 64) {
				is64bMode = true;
				defaultCodeSize = CodeSize.Code64;
				defaultOperandSize = OpSize.Size32;
				defaultInvertedOperandSize = OpSize.Size16;
				defaultAddressSize = OpSize.Size64;
				defaultInvertedAddressSize = OpSize.Size32;
				prefixes = prefixes64;
			}
			else if (bitness == 32) {
				is64bMode = false;
				defaultCodeSize = CodeSize.Code32;
				defaultOperandSize = OpSize.Size32;
				defaultInvertedOperandSize = OpSize.Size16;
				defaultAddressSize = OpSize.Size32;
				defaultInvertedAddressSize = OpSize.Size16;
				prefixes = prefixes1632;
			}
			else {
				Debug.Assert(bitness == 16);
				is64bMode = false;
				defaultCodeSize = CodeSize.Code16;
				defaultOperandSize = OpSize.Size16;
				defaultInvertedOperandSize = OpSize.Size32;
				defaultAddressSize = OpSize.Size16;
				defaultInvertedAddressSize = OpSize.Size32;
				prefixes = prefixes1632;
			}
			is64bMode_and_W = is64bMode ? (uint)StateFlags.W : 0;
			reg15Mask = is64bMode ? 0xFU : 0x7;
			handlers_XX = OpCodeHandlersTables_Legacy.OneByteHandlers;
			handlers_0FXX = OpCodeHandlersTables_Legacy.TwoByteHandlers_0FXX;
#if !NO_VEX
			handlers_VEX_0FXX = OpCodeHandlersTables_VEX.TwoByteHandlers_0FXX;
			handlers_VEX_0F38XX = OpCodeHandlersTables_VEX.ThreeByteHandlers_0F38XX;
			handlers_VEX_0F3AXX = OpCodeHandlersTables_VEX.ThreeByteHandlers_0F3AXX;
#endif
#if !NO_EVEX
			handlers_EVEX_0FXX = OpCodeHandlersTables_EVEX.TwoByteHandlers_0FXX;
			handlers_EVEX_0F38XX = OpCodeHandlersTables_EVEX.ThreeByteHandlers_0F38XX;
			handlers_EVEX_0F3AXX = OpCodeHandlersTables_EVEX.ThreeByteHandlers_0F3AXX;
#endif
#if !NO_XOP
			handlers_XOP8 = OpCodeHandlersTables_XOP.XOP8;
			handlers_XOP9 = OpCodeHandlersTables_XOP.XOP9;
			handlers_XOPA = OpCodeHandlersTables_XOP.XOPA;
#endif
		}

		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="reader">Code reader</param>
		/// <param name="ip"><c>RIP</c> value</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		public static Decoder Create(int bitness, CodeReader reader, ulong ip, DecoderOptions options = DecoderOptions.None) =>
			bitness switch {
				16 or 32 or 64 => new Decoder(reader, ip, options, bitness),
				_ => throw new ArgumentOutOfRangeException(nameof(bitness)),
			};

		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="data">Data to decode</param>
		/// <param name="ip"><c>RIP</c> value</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		public static Decoder Create(int bitness, byte[] data, ulong ip, DecoderOptions options = DecoderOptions.None) =>
			Create(bitness, new ByteArrayCodeReader(data), ip, options);

		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="reader">Code reader</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		public static Decoder Create(int bitness, CodeReader reader, DecoderOptions options = DecoderOptions.None) =>
			Create(bitness, reader, 0, options);

		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="data">Data to decode</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		public static Decoder Create(int bitness, byte[] data, DecoderOptions options = DecoderOptions.None) =>
			Create(bitness, new ByteArrayCodeReader(data), 0, options);

		internal uint ReadByte() {
			uint instrLen = state.instructionLength;
			if (instrLen < IcedConstants.MaxInstructionLength) {
				uint b = (uint)reader.ReadByte();
				Debug.Assert(b <= byte.MaxValue || b > int.MaxValue);
				if (b <= byte.MaxValue) {
					state.instructionLength = instrLen + 1;
					return b;
				}
				state.flags |= StateFlags.NoMoreBytes;
			}
			state.flags |= StateFlags.IsInvalid;
			return 0;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint ReadUInt16() => ReadByte() | (ReadByte() << 8);
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint ReadUInt32() => ReadByte() | (ReadByte() << 8) | (ReadByte() << 16) | (ReadByte() << 24);

		/// <summary>
		/// Gets the last decoder error. Unless you need to know the reason it failed,
		/// it's better to check <see cref="Instruction.IsInvalid"/>.
		/// </summary>
		public DecoderError LastError {
			get {
				// NoMoreBytes error has highest priority
				if ((state.flags & StateFlags.NoMoreBytes) != 0)
					return DecoderError.NoMoreBytes;
				if ((state.flags & StateFlags.IsInvalid) != 0)
					return DecoderError.InvalidInstruction;
				return DecoderError.None;
			}
		}

		/// <summary>
		/// Decodes the next instruction, see also <see cref="Decode(out Instruction)"/> which is faster
		/// if you already have an <see cref="Instruction"/> local, array element or field.
		/// <br/>
		/// See also <see cref="LastError"/>
		/// </summary>
		/// <returns></returns>
		public Instruction Decode() {
			Decode(out var instr);
			return instr;
		}

		/// <summary>
		/// Decodes the next instruction, see also <see cref="LastError"/>
		/// </summary>
		/// <param name="instruction">Decoded instruction</param>
		public void Decode(out Instruction instruction) {
			instruction = default;
			// JIT32: it's 9% slower decoding instructions if we clear the whole 'state'
			// 32-bit RyuJIT: not tested
			// 64-bit RyuJIT: diff is too small to care about
#if truex
			state = default;
#else
			state.instructionLength = 0;
			state.extraRegisterBase = 0;
			state.extraIndexRegisterBase = 0;
			state.extraBaseRegisterBase = 0;
			state.extraIndexRegisterBaseVSIB = 0;
			state.flags = 0;
			state.mandatoryPrefix = 0;
#endif
			state.operandSize = defaultOperandSize;
			state.addressSize = defaultAddressSize;
			var table = handlers_XX;
			var defaultDsSegment = (byte)Register.DS;
			uint rexPrefix = 0;
			uint b;
			for (;;) {
				b = ReadByte();
				// RyuJIT32: 2-5% faster, RyuJIT64: almost no improvement
				if (((prefixes[(int)(b / 32)] >> ((int)b & 31)) & 1) == 0)
					break;
				// Converting these prefixes to opcode handlers instead of a switch results in slightly worse perf
				// with JIT32, and about the same speed with 64-bit RyuJIT.
				switch (b) {
				case 0x0F:
					b = ReadByte();
					table = handlers_0FXX;
					goto afterPrefixLoop;

				case 0x26:
					if (!is64bMode || defaultDsSegment < (byte)Register.FS) {
						instruction.SegmentPrefix = Register.ES;
						defaultDsSegment = (byte)Register.ES;
					}
					rexPrefix = 0;
					break;

				case 0x2E:
					if (!is64bMode || defaultDsSegment < (byte)Register.FS) {
						instruction.SegmentPrefix = Register.CS;
						defaultDsSegment = (byte)Register.CS;
					}
					rexPrefix = 0;
					break;

				case 0x36:
					if (!is64bMode || defaultDsSegment < (byte)Register.FS) {
						instruction.SegmentPrefix = Register.SS;
						defaultDsSegment = (byte)Register.SS;
					}
					rexPrefix = 0;
					break;

				case 0x3E:
					if (!is64bMode || defaultDsSegment < (byte)Register.FS) {
						instruction.SegmentPrefix = Register.DS;
						defaultDsSegment = (byte)Register.DS;
					}
					rexPrefix = 0;
					break;

				case 0x64:
					instruction.SegmentPrefix = Register.FS;
					defaultDsSegment = (byte)Register.FS;
					rexPrefix = 0;
					break;

				case 0x65:
					instruction.SegmentPrefix = Register.GS;
					defaultDsSegment = (byte)Register.GS;
					rexPrefix = 0;
					break;

				case 0x66:
					state.flags |= StateFlags.Has66;
					state.operandSize = defaultInvertedOperandSize;
					if (state.mandatoryPrefix == MandatoryPrefixByte.None)
						state.mandatoryPrefix = MandatoryPrefixByte.P66;
					rexPrefix = 0;
					break;

				case 0x67:
					state.addressSize = defaultInvertedAddressSize;
					rexPrefix = 0;
					break;

				case 0xF0:
					instruction.InternalSetHasLockPrefix();
					state.flags |= StateFlags.Lock;
					rexPrefix = 0;
					break;

				case 0xF2:
					instruction.InternalSetHasRepnePrefix();
					state.mandatoryPrefix = MandatoryPrefixByte.PF2;
					rexPrefix = 0;
					break;

				case 0xF3:
					instruction.InternalSetHasRepePrefix();
					state.mandatoryPrefix = MandatoryPrefixByte.PF3;
					rexPrefix = 0;
					break;

				default:
					Debug.Assert(is64bMode);
					Debug.Assert(0x40 <= b && b <= 0x4F);
					rexPrefix = b;
					break;
				}
			}
afterPrefixLoop:
			if (rexPrefix != 0) {
				if ((rexPrefix & 8) != 0) {
					state.operandSize = OpSize.Size64;
					state.flags |= StateFlags.HasRex | StateFlags.W;
				}
				else
					state.flags |= StateFlags.HasRex;
				state.extraRegisterBase = (rexPrefix & 4) << 1;
				state.extraIndexRegisterBase = (rexPrefix & 2) << 2;
				state.extraBaseRegisterBase = (rexPrefix & 1) << 3;
			}
			DecodeTable(table[b], ref instruction);
			var flags = state.flags;
			if ((flags & (StateFlags.IsInvalid | StateFlags.Lock)) != 0) {
				if ((flags & StateFlags.IsInvalid) != 0 ||
					(((uint)(flags & (StateFlags.Lock | StateFlags.AllowLock)) & invalidCheckMask) == (uint)StateFlags.Lock)) {
					instruction = default;
					Static.Assert(Code.INVALID == 0 ? 0 : -1);
					//instruction.InternalCode = Code.INVALID;
					state.flags = flags | StateFlags.IsInvalid;
				}
			}
			instruction.InternalCodeSize = defaultCodeSize;
			uint instrLen = state.instructionLength;
			Debug.Assert(0 <= instrLen && instrLen <= IcedConstants.MaxInstructionLength);// Could be 0 if there were no bytes available
			instruction.InternalLength = instrLen;
			var ip = instructionPointer;
			ip += instrLen;
			instructionPointer = ip;
			instruction.NextIP = ip;
			if ((state.flags & StateFlags.IpRel) != 0) {
				if (state.addressSize == OpSize.Size64)
					instruction.MemoryDisplacement64 += ip;
				else
					instruction.InternalMemoryDisplacement64_lo = (uint)ip + instruction.MemoryDisplacement32;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal uint GetCurrentInstructionPointer32() => (uint)instructionPointer + state.instructionLength;
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal ulong GetCurrentInstructionPointer64() => instructionPointer + state.instructionLength;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearMandatoryPrefix(ref Instruction instruction) {
			Debug.Assert(state.Encoding == EncodingKind.Legacy);
			instruction.InternalClearHasRepeRepnePrefix();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SetXacquireXrelease(ref Instruction instruction, HandlerFlags flags) {
			if ((flags & HandlerFlags.XacquireXreleaseNoLock) != 0 || instruction.HasLockPrefix)
				SetXacquireXreleaseCore(ref instruction, flags);
		}

		void SetXacquireXreleaseCore(ref Instruction instruction, HandlerFlags flags) {
			Debug.Assert(!((flags & HandlerFlags.XacquireXreleaseNoLock) == 0 && !instruction.HasLockPrefix));
			switch (state.mandatoryPrefix) {
			case MandatoryPrefixByte.PF2:
				if ((flags & HandlerFlags.Xacquire) != 0) {
					ClearMandatoryPrefixF2(ref instruction);
					instruction.InternalSetHasXacquirePrefix();
				}
				break;

			case MandatoryPrefixByte.PF3:
				if ((flags & HandlerFlags.Xrelease) != 0) {
					ClearMandatoryPrefixF3(ref instruction);
					instruction.InternalSetHasXreleasePrefix();
				}
				break;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearMandatoryPrefixF3(ref Instruction instruction) {
			Debug.Assert(state.Encoding == EncodingKind.Legacy);
			Debug.Assert(state.mandatoryPrefix == MandatoryPrefixByte.PF3);
			instruction.InternalClearHasRepePrefix();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ClearMandatoryPrefixF2(ref Instruction instruction) {
			Debug.Assert(state.Encoding == EncodingKind.Legacy);
			Debug.Assert(state.mandatoryPrefix == MandatoryPrefixByte.PF2);
			instruction.InternalClearHasRepnePrefix();
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void SetInvalidInstruction() => state.flags |= StateFlags.IsInvalid;

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void DecodeTable(OpCodeHandler[] table, ref Instruction instruction) => DecodeTable(table[(int)ReadByte()], ref instruction);

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		void DecodeTable(OpCodeHandler handler, ref Instruction instruction) {
			if (handler.HasModRM) {
				uint m = ReadByte();
				state.modrm = m;
				state.mod = m >> 6;
				state.reg = (m >> 3) & 7;
				state.rm = m & 7;
			}
			handler.Decode(this, ref instruction);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadModRM() {
			uint m = ReadByte();
			state.modrm = m;
			state.mod = m >> 6;
			state.reg = (m >> 3) & 7;
			state.rm = m & 7;
		}

		internal void VEX2(ref Instruction instruction) {
#if NO_VEX
			SetInvalidInstruction();
#else
			if ((((uint)(state.flags & StateFlags.HasRex) | (uint)state.mandatoryPrefix) & invalidCheckMask) != 0)
				SetInvalidInstruction();
			// Undo what Decode() did if it got a REX prefix
			state.flags &= ~StateFlags.W;
			state.extraIndexRegisterBase = 0;
			state.extraBaseRegisterBase = 0;

#if DEBUG
			state.flags |= (StateFlags)EncodingKind.VEX;
#endif
			uint b = state.modrm;
			state.extraRegisterBase = ((b >> 4) ^ 8) & 8;

			Static.Assert((int)VectorLength.L128 == 0 ? 0 : -1);
			Static.Assert((int)VectorLength.L256 == 1 ? 0 : -1);
			state.vectorLength = (b >> 2) & 1;

			Static.Assert((int)MandatoryPrefixByte.None == 0 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.P66 == 1 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF3 == 2 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF2 == 3 ? 0 : -1);
			state.mandatoryPrefix = (MandatoryPrefixByte)(b & 3);

			// Bit 6 can only be 1 if it's 16/32-bit mode, so we don't need to change the mask
			b = (~b >> 3) & 0x0F;
			state.vvvv = b;
			state.vvvv_invalidCheck = b;

			DecodeTable(handlers_VEX_0FXX, ref instruction);
#endif
		}

		internal void VEX3(ref Instruction instruction) {
#if NO_VEX
			SetInvalidInstruction();
#else
			if ((((uint)(state.flags & StateFlags.HasRex) | (uint)state.mandatoryPrefix) & invalidCheckMask) != 0)
				SetInvalidInstruction();
			// Undo what Decode() did if it got a REX prefix
			state.flags &= ~StateFlags.W;

#if DEBUG
			state.flags |= (StateFlags)EncodingKind.VEX;
#endif
			uint b1 = state.modrm;
			uint b2 = ReadByte();

			Static.Assert((int)StateFlags.W == 0x80 ? 0 : -1);
			state.flags |= (StateFlags)(b2 & 0x80);

			Static.Assert((int)VectorLength.L128 == 0 ? 0 : -1);
			Static.Assert((int)VectorLength.L256 == 1 ? 0 : -1);
			state.vectorLength = (b2 >> 2) & 1;

			Static.Assert((int)MandatoryPrefixByte.None == 0 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.P66 == 1 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF3 == 2 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF2 == 3 ? 0 : -1);
			state.mandatoryPrefix = (MandatoryPrefixByte)(b2 & 3);

			b2 = (~b2 >> 3) & 0x0F;
			if (is64bMode) {
				state.vvvv = b2;
				state.vvvv_invalidCheck = b2;
				uint b1x = ~b1;
				state.extraRegisterBase = (b1x >> 4) & 8;
				state.extraIndexRegisterBase = (b1x >> 3) & 8;
				state.extraBaseRegisterBase = (b1x >> 2) & 8;
			}
			else {
				state.vvvv_invalidCheck = b2;
				state.vvvv = b2 & 0x07;
			}

			int table = (int)(b1 & 0x1F);
			if (table == 1)
				DecodeTable(handlers_VEX_0FXX, ref instruction);
			else if (table == 2)
				DecodeTable(handlers_VEX_0F38XX, ref instruction);
			else if (table == 3)
				DecodeTable(handlers_VEX_0F3AXX, ref instruction);
			else
				SetInvalidInstruction();
#endif
		}

		internal void XOP(ref Instruction instruction) {
#if NO_XOP
			SetInvalidInstruction();
#else
			if ((((uint)(state.flags & StateFlags.HasRex) | (uint)state.mandatoryPrefix) & invalidCheckMask) != 0)
				SetInvalidInstruction();
			// Undo what Decode() did if it got a REX prefix
			state.flags &= ~StateFlags.W;

#if DEBUG
			state.flags |= (StateFlags)EncodingKind.XOP;
#endif
			uint b1 = state.modrm;
			uint b2 = ReadByte();

			Static.Assert((int)StateFlags.W == 0x80 ? 0 : -1);
			state.flags |= (StateFlags)(b2 & 0x80);

			Static.Assert((int)VectorLength.L128 == 0 ? 0 : -1);
			Static.Assert((int)VectorLength.L256 == 1 ? 0 : -1);
			state.vectorLength = (b2 >> 2) & 1;

			Static.Assert((int)MandatoryPrefixByte.None == 0 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.P66 == 1 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF3 == 2 ? 0 : -1);
			Static.Assert((int)MandatoryPrefixByte.PF2 == 3 ? 0 : -1);
			state.mandatoryPrefix = (MandatoryPrefixByte)(b2 & 3);

			b2 = (~b2 >> 3) & 0x0F;
			if (is64bMode) {
				state.vvvv = b2;
				state.vvvv_invalidCheck = b2;
				uint b1x = ~b1;
				state.extraRegisterBase = (b1x >> 4) & 8;
				state.extraIndexRegisterBase = (b1x >> 3) & 8;
				state.extraBaseRegisterBase = (b1x >> 2) & 8;
			}
			else {
				state.vvvv_invalidCheck = b2;
				state.vvvv = b2 & 0x07;
			}

			int table = (int)(b1 & 0x1F);
			if (table == 8)
				DecodeTable(handlers_XOP8, ref instruction);
			else if (table == 9)
				DecodeTable(handlers_XOP9, ref instruction);
			else if (table == 10)
				DecodeTable(handlers_XOPA, ref instruction);
			else
				SetInvalidInstruction();
#endif
		}

		internal void EVEX_MVEX(ref Instruction instruction) {
#if NO_EVEX
			SetInvalidInstruction();
#else
			if ((((uint)(state.flags & StateFlags.HasRex) | (uint)state.mandatoryPrefix) & invalidCheckMask) != 0)
				SetInvalidInstruction();
			// Undo what Decode() did if it got a REX prefix
			state.flags &= ~StateFlags.W;

			uint p0 = state.modrm;
			uint p1 = ReadByte();
			uint p2 = ReadByte();

			if ((p1 & 4) != 0) {
				if ((p0 & 0x0C) == 0) {
#if DEBUG
					state.flags |= (StateFlags)EncodingKind.EVEX;
#endif

					Static.Assert((int)MandatoryPrefixByte.None == 0 ? 0 : -1);
					Static.Assert((int)MandatoryPrefixByte.P66 == 1 ? 0 : -1);
					Static.Assert((int)MandatoryPrefixByte.PF3 == 2 ? 0 : -1);
					Static.Assert((int)MandatoryPrefixByte.PF2 == 3 ? 0 : -1);
					state.mandatoryPrefix = (MandatoryPrefixByte)(p1 & 3);

					Static.Assert((int)StateFlags.W == 0x80 ? 0 : -1);
					state.flags |= (StateFlags)(p1 & 0x80);

					uint aaa = p2 & 7;
					state.aaa = aaa;
					instruction.InternalOpMask = aaa;
					if ((p2 & 0x80) != 0) {
						// invalid if aaa == 0 and if we check for invalid instructions (it's all 1s)
						if ((aaa ^ invalidCheckMask) == uint.MaxValue)
							SetInvalidInstruction();
						state.flags |= StateFlags.z;
						instruction.InternalSetZeroingMasking();
					}

					Static.Assert((int)StateFlags.b == 0x10 ? 0 : -1);
					state.flags |= (StateFlags)(p2 & 0x10);

					Static.Assert((int)VectorLength.L128 == 0 ? 0 : -1);
					Static.Assert((int)VectorLength.L256 == 1 ? 0 : -1);
					Static.Assert((int)VectorLength.L512 == 2 ? 0 : -1);
					Static.Assert((int)VectorLength.Unknown == 3 ? 0 : -1);
					state.vectorLength = (p2 >> 5) & 3;

					p1 = (~p1 >> 3) & 0x0F;
					if (is64bMode) {
						uint tmp = (~p2 & 8) << 1;
						state.extraIndexRegisterBaseVSIB = tmp;
						tmp += p1;
						state.vvvv = tmp;
						state.vvvv_invalidCheck = tmp;
						uint p0x = ~p0;
						state.extraRegisterBase = (p0x >> 4) & 8;
						state.extraIndexRegisterBase = (p0x >> 3) & 8;
						state.extraRegisterBaseEVEX = p0x & 0x10;
						p0x >>= 2;
						state.extraBaseRegisterBaseEVEX = p0x & 0x18;
						state.extraBaseRegisterBase = p0x & 8;
					}
					else {
						state.vvvv_invalidCheck = p1;
						state.vvvv = p1 & 0x07;
						Static.Assert((int)StateFlags.IsInvalid == 0x40 ? 0 : -1);
						state.flags |= (StateFlags)((~p2 & 8) << 3);
					}

					int table = (int)(p0 & 3);
					OpCodeHandler[] handlers;
					if (table == 1)
						handlers = handlers_EVEX_0FXX;
					else if (table == 2)
						handlers = handlers_EVEX_0F38XX;
					else if (table == 3)
						handlers = handlers_EVEX_0F3AXX;
					else {
						SetInvalidInstruction();
						return;
					}
					var handler = handlers[(int)ReadByte()];
					Debug.Assert(handler.HasModRM);
					uint m = ReadByte();
					state.modrm = m;
					state.mod = m >> 6;
					state.reg = (m >> 3) & 7;
					state.rm = m & 7;
					// Invalid if LL=3 and no rc
					Static.Assert((uint)StateFlags.b > 3 ? 0 : -1);
					if ((((uint)(state.flags & StateFlags.b) | state.vectorLength) & invalidCheckMask) == 3)
						SetInvalidInstruction();
					handler.Decode(this, ref instruction);
				}
				else
					SetInvalidInstruction();
			}
			else {
				//TODO: Support deprecated MVEX instructions: https://github.com/icedland/iced/issues/2
				SetInvalidInstruction();
			}
#endif
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal Register ReadOpSegReg() {
			uint reg = state.reg;
			if (reg < 6)
				return Register.ES + (int)reg;
			SetInvalidInstruction();
			return Register.None;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal bool ReadOpMem(ref Instruction instruction) {
			Debug.Assert(state.Encoding != EncodingKind.EVEX);
			if (state.addressSize == OpSize.Size64)
				return ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, TupleType.N1, false);
			else if (state.addressSize == OpSize.Size32)
				return ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, TupleType.N1, false);
			else {
				ReadOpMem16(ref instruction, TupleType.N1);
				return false;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadOpMemSib(ref Instruction instruction) {
			Debug.Assert(state.Encoding != EncodingKind.EVEX);
			bool isValid;
			if (state.addressSize == OpSize.Size64)
				isValid = ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, TupleType.N1, false);
			else if (state.addressSize == OpSize.Size32)
				isValid = ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, TupleType.N1, false);
			else {
				ReadOpMem16(ref instruction, TupleType.N1);
				isValid = false;
			}
			if (invalidCheckMask != 0 && !isValid)
				SetInvalidInstruction();
		}

		// All MPX instructions in 64-bit mode force 64-bit addressing, and
		// all MPX instructions in 16/32-bit mode require 32-bit addressing
		// (see SDM Vol 1, 17.5.1 Intel MPX and Operating Modes)
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadOpMem_MPX(ref Instruction instruction) {
			Debug.Assert(state.Encoding != EncodingKind.EVEX);
			if (is64bMode) {
				state.addressSize = OpSize.Size64;
				ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, TupleType.N1, false);
			}
			else if (state.addressSize == OpSize.Size32)
				ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, TupleType.N1, false);
			else {
				ReadOpMem16(ref instruction, TupleType.N1);
				if (invalidCheckMask != 0)
					SetInvalidInstruction();
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadOpMem(ref Instruction instruction, TupleType tupleType) {
			Debug.Assert(state.Encoding == EncodingKind.EVEX);
			if (state.addressSize == OpSize.Size64)
				ReadOpMem32Or64(ref instruction, Register.RAX, Register.RAX, tupleType, false);
			else if (state.addressSize == OpSize.Size32)
				ReadOpMem32Or64(ref instruction, Register.EAX, Register.EAX, tupleType, false);
			else
				ReadOpMem16(ref instruction, tupleType);
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal void ReadOpMem_VSIB(ref Instruction instruction, Register vsibIndex, TupleType tupleType) {
			bool isValid;
			if (state.addressSize == OpSize.Size64)
				isValid = ReadOpMem32Or64(ref instruction, Register.RAX, vsibIndex, tupleType, true);
			else if (state.addressSize == OpSize.Size32)
				isValid = ReadOpMem32Or64(ref instruction, Register.EAX, vsibIndex, tupleType, true);
			else {
				ReadOpMem16(ref instruction, tupleType);
				isValid = false;
			}
			if (invalidCheckMask != 0 && !isValid)
				SetInvalidInstruction();
		}

		readonly struct RegInfo2 {
			public readonly Register baseReg;
			public readonly Register indexReg;
			public RegInfo2(Register baseReg, Register indexReg) {
				this.baseReg = baseReg;
				this.indexReg = indexReg;
			}
			public void Deconstruct(out Register baseReg, out Register indexReg) {
				baseReg = this.baseReg;
				indexReg = this.indexReg;
			}
		}
		static readonly RegInfo2[] s_memRegs16 = new RegInfo2[8] {
			new RegInfo2(Register.BX, Register.SI),
			new RegInfo2(Register.BX, Register.DI),
			new RegInfo2(Register.BP, Register.SI),
			new RegInfo2(Register.BP, Register.DI),
			new RegInfo2(Register.SI, Register.None),
			new RegInfo2(Register.DI, Register.None),
			new RegInfo2(Register.BP, Register.None),
			new RegInfo2(Register.BX, Register.None),
		};
		void ReadOpMem16(ref Instruction instruction, TupleType tupleType) {
			Debug.Assert(state.addressSize == OpSize.Size16);
			var (baseReg, indexReg) = memRegs16[(int)state.rm];
			switch ((int)state.mod) {
			case 0:
				if (state.rm == 6) {
					instruction.InternalSetMemoryDisplSize(2);
					displIndex = state.instructionLength;
					instruction.InternalMemoryDisplacement64_lo = ReadUInt16();
					baseReg = Register.None;
					Debug.Assert(indexReg == Register.None);
				}
				break;

			case 1:
				instruction.InternalSetMemoryDisplSize(1);
				displIndex = state.instructionLength;
				if (tupleType == TupleType.N1)
					instruction.InternalMemoryDisplacement64_lo = (ushort)(sbyte)ReadByte();
				else
					instruction.InternalMemoryDisplacement64_lo = (ushort)(GetDisp8N(tupleType) * (uint)(sbyte)ReadByte());
				break;

			default:
				Debug.Assert(state.mod == 2);
				instruction.InternalSetMemoryDisplSize(2);
				displIndex = state.instructionLength;
				instruction.InternalMemoryDisplacement64_lo = ReadUInt16();
				break;
			}

			instruction.InternalMemoryBase = baseReg;
			instruction.InternalMemoryIndex = indexReg;
		}

		// Returns true if the SIB byte was read
		bool ReadOpMem32Or64(ref Instruction instruction, Register baseReg, Register indexReg, TupleType tupleType, bool isVsib) {
			Debug.Assert(state.addressSize == OpSize.Size32 || state.addressSize == OpSize.Size64);
			uint sib;
			uint displSizeScale, displ;
			switch ((int)state.mod) {
			case 0:
				if (state.rm == 4) {
					sib = ReadByte();
					displSizeScale = 0;
					displ = 0;
					break;
				}
				else if (state.rm == 5) {
					displIndex = state.instructionLength;
					if (state.addressSize == OpSize.Size64) {
						instruction.MemoryDisplacement64 = (ulong)(int)ReadUInt32();
						instruction.InternalSetMemoryDisplSize(4);
					}
					else {
						instruction.InternalMemoryDisplacement64_lo = ReadUInt32();
						instruction.InternalSetMemoryDisplSize(3);
					}
					if (is64bMode) {
						state.flags |= StateFlags.IpRel;
						if (state.addressSize == OpSize.Size64)
							instruction.InternalMemoryBase = Register.RIP;
						else
							instruction.InternalMemoryBase = Register.EIP;
					}
					return false;
				}
				else {
					Debug.Assert(0 <= state.rm && state.rm <= 7 && state.rm != 4 && state.rm != 5);
					instruction.InternalMemoryBase = (int)(state.extraBaseRegisterBase + state.rm) + baseReg;
					return false;
				}

			case 1:
				if (state.rm == 4) {
					sib = ReadByte();
					displSizeScale = 1;
					displIndex = state.instructionLength;
					if (tupleType == TupleType.N1)
						displ = (uint)(sbyte)ReadByte();
					else
						displ = GetDisp8N(tupleType) * (uint)(sbyte)ReadByte();
					break;
				}
				else {
					Debug.Assert(0 <= state.rm && state.rm <= 7 && state.rm != 4);
					instruction.InternalSetMemoryDisplSize(1);
					displIndex = state.instructionLength;
					if (state.addressSize == OpSize.Size64) {
						if (tupleType == TupleType.N1)
							instruction.MemoryDisplacement64 = (ulong)(sbyte)ReadByte();
						else
							instruction.MemoryDisplacement64 = (ulong)GetDisp8N(tupleType) * (ulong)(sbyte)ReadByte();
					}
					else {
						if (tupleType == TupleType.N1)
							instruction.InternalMemoryDisplacement64_lo = (uint)(sbyte)ReadByte();
						else
							instruction.InternalMemoryDisplacement64_lo = GetDisp8N(tupleType) * (uint)(sbyte)ReadByte();
					}
					instruction.InternalMemoryBase = (int)(state.extraBaseRegisterBase + state.rm) + baseReg;
					return false;
				}

			default:
				Debug.Assert(state.mod == 2);
				if (state.rm == 4) {
					sib = ReadByte();
					displSizeScale = state.addressSize == OpSize.Size64 ? 4U : 3;
					displIndex = state.instructionLength;
					displ = ReadUInt32();
					break;
				}
				else {
					Debug.Assert(0 <= state.rm && state.rm <= 7 && state.rm != 4);
					displIndex = state.instructionLength;
					if (state.addressSize == OpSize.Size64) {
						instruction.MemoryDisplacement64 = (ulong)(int)ReadUInt32();
						instruction.InternalSetMemoryDisplSize(4);
					}
					else {
						instruction.InternalMemoryDisplacement64_lo = ReadUInt32();
						instruction.InternalSetMemoryDisplSize(3);
					}
					instruction.InternalMemoryBase = (int)(state.extraBaseRegisterBase + state.rm) + baseReg;
					return false;
				}
			}

			uint index = ((sib >> 3) & 7) + state.extraIndexRegisterBase;
			uint @base = sib & 7;

			instruction.InternalMemoryIndexScale = (int)(sib >> 6);
			if (!isVsib) {
				if (index != 4)
					instruction.InternalMemoryIndex = (int)index + indexReg;
			}
			else
				instruction.InternalMemoryIndex = (int)(index + state.extraIndexRegisterBaseVSIB) + indexReg;

			if (@base == 5 && state.mod == 0) {
				displIndex = state.instructionLength;
				if (state.addressSize == OpSize.Size64) {
					instruction.MemoryDisplacement64 = (ulong)(int)ReadUInt32();
					instruction.InternalSetMemoryDisplSize(4);
				}
				else {
					instruction.InternalMemoryDisplacement64_lo = ReadUInt32();
					instruction.InternalSetMemoryDisplSize(3);
				}
			}
			else {
				instruction.InternalMemoryBase = (int)(@base + state.extraBaseRegisterBase) + baseReg;
				instruction.InternalSetMemoryDisplSize(displSizeScale);
				if (state.addressSize == OpSize.Size64)
					instruction.MemoryDisplacement64 = (ulong)(int)displ;
				else
					instruction.InternalMemoryDisplacement64_lo = displ;
			}
			return true;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		uint GetDisp8N(TupleType tupleType) =>
			TupleTypeTable.GetDisp8N(tupleType, (state.flags & StateFlags.b) != 0);

		/// <summary>
		/// Gets the offsets of the constants (memory displacement and immediate) in the decoded instruction.
		/// The caller can check if there are any relocations at those addresses.
		/// </summary>
		/// <param name="instruction">The latest instruction that was decoded by this decoder</param>
		/// <returns></returns>
		public ConstantOffsets GetConstantOffsets(in Instruction instruction) {
			ConstantOffsets constantOffsets = default;

			int displSize = instruction.MemoryDisplSize;
			if (displSize != 0) {
				constantOffsets.DisplacementOffset = (byte)displIndex;
				if (displSize == 8 && (state.flags & StateFlags.Addr64) == 0)
					constantOffsets.DisplacementSize = 4;
				else
					constantOffsets.DisplacementSize = (byte)displSize;
			}

			if ((state.flags & StateFlags.NoImm) == 0) {
				int extraImmSub = 0;
				for (int i = instruction.OpCount - 1; i >= 0; i--) {
					switch (instruction.GetOpKind(i)) {
					case OpKind.Immediate8:
					case OpKind.Immediate8to16:
					case OpKind.Immediate8to32:
					case OpKind.Immediate8to64:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - extraImmSub - 1);
						constantOffsets.ImmediateSize = 1;
						goto after_imm_loop;

					case OpKind.Immediate16:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - extraImmSub - 2);
						constantOffsets.ImmediateSize = 2;
						goto after_imm_loop;

					case OpKind.Immediate32:
					case OpKind.Immediate32to64:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - extraImmSub - 4);
						constantOffsets.ImmediateSize = 4;
						goto after_imm_loop;

					case OpKind.Immediate64:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - extraImmSub - 8);
						constantOffsets.ImmediateSize = 8;
						goto after_imm_loop;

					case OpKind.Immediate8_2nd:
						constantOffsets.ImmediateOffset2 = (byte)(instruction.Length - 1);
						constantOffsets.ImmediateSize2 = 1;
						extraImmSub = 1;
						break;

					case OpKind.NearBranch16:
						if ((state.flags & StateFlags.BranchImm8) != 0) {
							constantOffsets.ImmediateOffset = (byte)(instruction.Length - 1);
							constantOffsets.ImmediateSize = 1;
						}
						else if ((state.flags & StateFlags.Xbegin) == 0) {
							constantOffsets.ImmediateOffset = (byte)(instruction.Length - 2);
							constantOffsets.ImmediateSize = 2;
						}
						else {
							Debug.Assert((state.flags & StateFlags.Xbegin) != 0);
							if (state.operandSize != OpSize.Size16) {
								constantOffsets.ImmediateOffset = (byte)(instruction.Length - 4);
								constantOffsets.ImmediateSize = 4;
							}
							else {
								constantOffsets.ImmediateOffset = (byte)(instruction.Length - 2);
								constantOffsets.ImmediateSize = 2;
							}
						}
						break;

					case OpKind.NearBranch32:
					case OpKind.NearBranch64:
						if ((state.flags & StateFlags.BranchImm8) != 0) {
							constantOffsets.ImmediateOffset = (byte)(instruction.Length - 1);
							constantOffsets.ImmediateSize = 1;
						}
						else if ((state.flags & StateFlags.Xbegin) == 0) {
							constantOffsets.ImmediateOffset = (byte)(instruction.Length - 4);
							constantOffsets.ImmediateSize = 4;
						}
						else {
							Debug.Assert((state.flags & StateFlags.Xbegin) != 0);
							if (state.operandSize != OpSize.Size16) {
								constantOffsets.ImmediateOffset = (byte)(instruction.Length - 4);
								constantOffsets.ImmediateSize = 4;
							}
							else {
								constantOffsets.ImmediateOffset = (byte)(instruction.Length - 2);
								constantOffsets.ImmediateSize = 2;
							}
						}
						break;

					case OpKind.FarBranch16:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - (2 + 2));
						constantOffsets.ImmediateSize = 2;
						constantOffsets.ImmediateOffset2 = (byte)(instruction.Length - 2);
						constantOffsets.ImmediateSize2 = 2;
						break;

					case OpKind.FarBranch32:
						constantOffsets.ImmediateOffset = (byte)(instruction.Length - (4 + 2));
						constantOffsets.ImmediateSize = 4;
						constantOffsets.ImmediateOffset2 = (byte)(instruction.Length - 2);
						constantOffsets.ImmediateSize2 = 2;
						break;
					}
				}
			}
after_imm_loop:

			return constantOffsets;
		}

		/// <summary>
		/// An <see cref="Instruction"/> enumerator
		/// </summary>
		public struct Enumerator : IEnumerator<Instruction> {
			readonly Decoder decoder;
			Instruction instruction;

			internal Enumerator(Decoder decoder) {
				this.decoder = decoder;
				instruction = default;
			}

			/// <summary>
			/// Gets the current instruction
			/// </summary>
			public Instruction Current => instruction; // Can't use `readonly ref`
			Instruction IEnumerator<Instruction>.Current => Current;
			object IEnumerator.Current => Current;

			/// <summary>
			/// Decodes the next instruction
			/// </summary>
			/// <returns></returns>
			public bool MoveNext() {
				decoder.Decode(out instruction);
				// If it has length 0, there was no more data
				return instruction.HasNonZeroLength;
			}

			void IEnumerator.Reset() => throw new InvalidOperationException();

			/// <summary>
			/// Disposes of this instance
			/// </summary>
			public void Dispose() { }
		}

		/// <summary>
		/// Gets the <see cref="Instruction"/> enumerator
		/// </summary>
		/// <returns></returns>
		public Enumerator GetEnumerator() => new Enumerator(this);
		IEnumerator<Instruction> IEnumerable<Instruction>.GetEnumerator() => GetEnumerator();
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}
}
#endif
