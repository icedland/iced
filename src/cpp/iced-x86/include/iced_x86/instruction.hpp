// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once
#ifndef ICED_X86_INSTRUCTION_HPP
#define ICED_X86_INSTRUCTION_HPP

#include "iced_x86/code.hpp"
#include "iced_x86/register.hpp"
#include "iced_x86/op_kind.hpp"
#include "iced_x86/mnemonic.hpp"
#include "iced_x86/memory_size.hpp"
#include "iced_x86/code_size.hpp"
#include "iced_x86/rounding_control.hpp"
#include "iced_x86/mvex_reg_mem_conv.hpp"

#include <cstdint>
#include <cstddef>
#include <array>

namespace iced_x86 {

/// @brief A decoded x86/x64 instruction.
///
/// @details This struct contains all information about a decoded instruction.
/// It is designed to match the Rust implementation layout (40 bytes).
struct Instruction {
	// Internal fields - do not access directly
	uint64_t next_rip_ = 0;           ///< @private Address of next instruction
	uint64_t mem_displ_ = 0;          ///< @private Memory displacement / immediate64 high / branch target
	uint32_t flags1_ = 0;             ///< @private InstrFlags1 bitfield
	uint32_t immediate_ = 0;          ///< @private Immediate value / far branch offset
	Code code_ = Code::INVALID;       ///< @private Instruction code
	Register mem_base_reg_ = Register::NONE;  ///< @private Memory base register
	Register mem_index_reg_ = Register::NONE; ///< @private Memory index register
	std::array< Register, 4 > regs_ = {};     ///< @private Operand registers
	std::array< OpKind, 4 > op_kinds_ = {};   ///< @private Operand kinds
	uint8_t scale_ = 0;               ///< @private Memory index scale (0-3 = 1/2/4/8)
	uint8_t displ_size_ = 0;          ///< @private Displacement size encoding
	uint8_t len_ = 0;                 ///< @private Instruction length (0-15)
	uint8_t pad_ = 0;                 ///< @private Padding

	public:
	/// @brief Default constructor - creates an invalid instruction.
	constexpr Instruction() noexcept = default;

	// === Code and Mnemonic ===

	/// @brief Gets the instruction code.
	[[nodiscard]] constexpr Code code() const noexcept { return code_; }

	/// @brief Sets the instruction code.
	constexpr void set_code( Code value ) noexcept { code_ = value; }

	/// @brief Gets the mnemonic.
	[[nodiscard]] Mnemonic mnemonic() const noexcept;

	/// @brief Checks if this is an invalid instruction.
	[[nodiscard]] constexpr bool is_invalid() const noexcept { return code_ == Code::INVALID; }

	// === Instruction Pointer ===

	/// @brief Gets the 16-bit IP of this instruction.
	[[nodiscard]] constexpr uint16_t ip16() const noexcept { return static_cast< uint16_t >( next_rip_ - len_ ); }

	/// @brief Gets the 32-bit IP of this instruction.
	[[nodiscard]] constexpr uint32_t ip32() const noexcept { return static_cast< uint32_t >( next_rip_ - len_ ); }

	/// @brief Gets the 64-bit IP of this instruction.
	[[nodiscard]] constexpr uint64_t ip() const noexcept { return next_rip_ - len_; }

	/// @brief Sets the 64-bit IP of this instruction.
	constexpr void set_ip( uint64_t value ) noexcept { next_rip_ = value + len_; }

	/// @brief Gets the 16-bit IP of the next instruction.
	[[nodiscard]] constexpr uint16_t next_ip16() const noexcept { return static_cast< uint16_t >( next_rip_ ); }

	/// @brief Gets the 32-bit IP of the next instruction.
	[[nodiscard]] constexpr uint32_t next_ip32() const noexcept { return static_cast< uint32_t >( next_rip_ ); }

	/// @brief Gets the 64-bit IP of the next instruction.
	[[nodiscard]] constexpr uint64_t next_ip() const noexcept { return next_rip_; }

	/// @brief Sets the 64-bit IP of the next instruction.
	constexpr void set_next_ip( uint64_t value ) noexcept { next_rip_ = value; }

	/// @brief Gets the instruction length in bytes (1-15).
	[[nodiscard]] constexpr uint32_t length() const noexcept { return len_; }

	/// @brief Sets the instruction length in bytes.
	constexpr void set_length( uint32_t value ) noexcept { len_ = static_cast< uint8_t >( value ); }

	// === Operand Access ===

	/// @brief Gets the number of operands.
	[[nodiscard]] uint32_t op_count() const noexcept;

	/// @brief Gets the operand kind for the specified operand.
	/// @param operand Operand index (0-4)
	[[nodiscard]] OpKind op_kind( uint32_t operand ) const noexcept;

	/// @brief Sets the operand kind for the specified operand.
	void set_op_kind( uint32_t operand, OpKind kind ) noexcept;

	/// @brief Gets the register for the specified operand.
	/// @param operand Operand index (0-4)
	[[nodiscard]] Register op_register( uint32_t operand ) const noexcept;

	/// @brief Sets the register for the specified operand.
	void set_op_register( uint32_t operand, Register reg ) noexcept;

	/// @brief Gets the operand kind for operand 0.
	[[nodiscard]] constexpr OpKind op0_kind() const noexcept { return op_kinds_[0]; }

	/// @brief Gets the operand kind for operand 1.
	[[nodiscard]] constexpr OpKind op1_kind() const noexcept { return op_kinds_[1]; }

	/// @brief Gets the operand kind for operand 2.
	[[nodiscard]] constexpr OpKind op2_kind() const noexcept { return op_kinds_[2]; }

	/// @brief Gets the operand kind for operand 3.
	[[nodiscard]] constexpr OpKind op3_kind() const noexcept { return op_kinds_[3]; }

	/// @brief Gets the operand kind for operand 4.
	/// @details Operand 4 is always OpKind::IMMEDIATE8 when present.
	[[nodiscard]] constexpr OpKind op4_kind() const noexcept { return OpKind::IMMEDIATE8; }

	/// @brief Sets the operand kind for operand 0.
	constexpr void set_op0_kind( OpKind value ) noexcept { op_kinds_[0] = value; }

	/// @brief Sets the operand kind for operand 1.
	constexpr void set_op1_kind( OpKind value ) noexcept { op_kinds_[1] = value; }

	/// @brief Sets the operand kind for operand 2.
	constexpr void set_op2_kind( OpKind value ) noexcept { op_kinds_[2] = value; }

	/// @brief Sets the operand kind for operand 3.
	constexpr void set_op3_kind( OpKind value ) noexcept { op_kinds_[3] = value; }

	/// @brief Sets the operand kind for operand 4 (no-op, value must be IMMEDIATE8).
	/// @details Operand 4 kind is always IMMEDIATE8 and cannot be changed.
	constexpr void set_op4_kind( [[maybe_unused]] OpKind value ) noexcept { /* no-op, op4 is always IMMEDIATE8 */ }

	/// @brief Gets the register for operand 0.
	[[nodiscard]] constexpr Register op0_register() const noexcept { return regs_[0]; }

	/// @brief Gets the register for operand 1.
	[[nodiscard]] constexpr Register op1_register() const noexcept { return regs_[1]; }

	/// @brief Gets the register for operand 2.
	[[nodiscard]] constexpr Register op2_register() const noexcept { return regs_[2]; }

	/// @brief Gets the register for operand 3.
	[[nodiscard]] constexpr Register op3_register() const noexcept { return regs_[3]; }

	/// @brief Gets the register for operand 4.
	/// @details Operand 4 register is always Register::NONE.
	[[nodiscard]] constexpr Register op4_register() const noexcept { return Register::NONE; }

	/// @brief Sets the register for operand 0.
	constexpr void set_op0_register( Register value ) noexcept { regs_[0] = value; }

	/// @brief Sets the register for operand 1.
	constexpr void set_op1_register( Register value ) noexcept { regs_[1] = value; }

	/// @brief Sets the register for operand 2.
	constexpr void set_op2_register( Register value ) noexcept { regs_[2] = value; }

	/// @brief Sets the register for operand 3.
	constexpr void set_op3_register( Register value ) noexcept { regs_[3] = value; }

	/// @brief Sets the register for operand 4 (no-op, value must be NONE).
	/// @details Operand 4 register is always NONE and cannot be changed.
	constexpr void set_op4_register( [[maybe_unused]] Register value ) noexcept { /* no-op, op4 reg is always NONE */ }

	// === Memory Operand ===

	/// @brief Gets the memory operand base register.
	[[nodiscard]] constexpr Register memory_base() const noexcept { return mem_base_reg_; }

	/// @brief Sets the memory operand base register.
	constexpr void set_memory_base( Register value ) noexcept { mem_base_reg_ = value; }

	/// @brief Gets the memory operand index register.
	[[nodiscard]] constexpr Register memory_index() const noexcept { return mem_index_reg_; }

	/// @brief Sets the memory operand index register.
	constexpr void set_memory_index( Register value ) noexcept { mem_index_reg_ = value; }

	/// @brief Gets the memory operand index scale (1, 2, 4, or 8).
	[[nodiscard]] constexpr uint32_t memory_index_scale() const noexcept { return 1U << scale_; }

	/// @brief Sets the memory operand index scale (1, 2, 4, or 8).
	void set_memory_index_scale( uint32_t value ) noexcept;

	/// @brief Internal: Sets scale directly (0-3 maps to 1/2/4/8). For decoder use only.
	constexpr void set_scale_internal( uint8_t value ) noexcept { scale_ = value; }

	/// @brief Gets the 32-bit memory displacement.
	[[nodiscard]] constexpr uint32_t memory_displacement32() const noexcept { return static_cast< uint32_t >( mem_displ_ ); }

	/// @brief Sets the 32-bit memory displacement.
	constexpr void set_memory_displacement32( uint32_t value ) noexcept { mem_displ_ = value; }

	/// @brief Gets the 64-bit memory displacement.
	[[nodiscard]] constexpr uint64_t memory_displacement64() const noexcept { return mem_displ_; }

	/// @brief Sets the 64-bit memory displacement.
	constexpr void set_memory_displacement64( uint64_t value ) noexcept { mem_displ_ = value; }

	/// @brief Gets the memory operand displacement size in bytes (0, 1, 2, 4, or 8).
	/// @details Internal encoding: 0=0, 1=1, 2=2, 3=4, 4=8 (values 3 and 4 are mapped)
	[[nodiscard]] constexpr uint32_t memory_displ_size() const noexcept {
	    uint32_t size = displ_size_;
	    if ( size <= 2 ) return size;
	    return size == 3 ? 4 : 8;
	}

	/// @brief Sets the memory operand displacement size in bytes (0, 1, 2, 4, or 8).
	/// @details Valid values: 0 (none), 1 (byte), 2 (word/16-bit), 4 (dword/32-bit), 8 (qword/64-bit)
	constexpr void set_memory_displ_size( uint32_t value ) noexcept {
	    switch ( value ) {
	    case 0: displ_size_ = 0; break;
	    case 1: displ_size_ = 1; break;
	    case 2: displ_size_ = 2; break;
	    case 4: displ_size_ = 3; break;
	    default: displ_size_ = 4; break; // 8 or any other value
	    }
	}

	/// @brief Gets the memory operand size.
	[[nodiscard]] MemorySize memory_size() const noexcept;

	/// @brief Gets the segment prefix (or Register::NONE if none).
	[[nodiscard]] Register segment_prefix() const noexcept;

	/// @brief Sets the segment prefix.
	void set_segment_prefix( Register value ) noexcept;

	/// @brief Gets the effective segment register used for memory access.
	[[nodiscard]] Register memory_segment() const noexcept;

	/// @brief Checks if this is an IP-relative memory operand (RIP/EIP relative addressing).
	/// @return true if the memory base register is RIP or EIP
	[[nodiscard]] constexpr bool is_ip_rel_memory_operand() const noexcept {
	    return mem_base_reg_ == Register::RIP || mem_base_reg_ == Register::EIP;
	}

	/// @brief Gets the RIP/EIP relative address (the absolute address the instruction accesses).
	/// @details This method is only valid if is_ip_rel_memory_operand() returns true.
	/// For RIP-relative addressing, returns memory_displacement64().
	/// For EIP-relative addressing, returns memory_displacement32().
	/// @return The absolute target address of the RIP/EIP relative memory operand
	[[nodiscard]] constexpr uint64_t ip_rel_memory_address() const noexcept {
	    return mem_base_reg_ == Register::RIP ? mem_displ_ : static_cast< uint64_t >( static_cast< uint32_t >( mem_displ_ ) );
	}

	// === Immediate Values ===

	/// @brief Gets the immediate value for an 8-bit immediate operand.
	[[nodiscard]] constexpr uint8_t immediate8() const noexcept { return static_cast< uint8_t >( immediate_ ); }

	/// @brief Sets the immediate value for an 8-bit immediate operand.
	/// @details Preserves upper 24 bits of immediate_ for MVEX instruction flags (matches Rust with mvex feature)
	constexpr void set_immediate8( uint8_t value ) noexcept { immediate_ = ( immediate_ & 0xFFFFFF00u ) | value; }

	/// @brief Gets the second 8-bit immediate value (ENTER instruction).
	[[nodiscard]] constexpr uint8_t immediate8_2nd() const noexcept { return static_cast< uint8_t >( mem_displ_ ); }

	/// @brief Sets the second 8-bit immediate value (ENTER instruction).
	constexpr void set_immediate8_2nd( uint8_t value ) noexcept { mem_displ_ = value; }

	/// @brief Gets the immediate value for a 16-bit immediate operand.
	[[nodiscard]] constexpr uint16_t immediate16() const noexcept { return static_cast< uint16_t >( immediate_ ); }

	/// @brief Sets the immediate value for a 16-bit immediate operand.
	constexpr void set_immediate16( uint16_t value ) noexcept { immediate_ = value; }

	/// @brief Gets the immediate value for a 32-bit immediate operand.
	[[nodiscard]] constexpr uint32_t immediate32() const noexcept { return immediate_; }

	/// @brief Sets the immediate value for a 32-bit immediate operand.
	constexpr void set_immediate32( uint32_t value ) noexcept { immediate_ = value; }

	/// @brief Gets the immediate value for a 64-bit immediate operand.
	[[nodiscard]] constexpr uint64_t immediate64() const noexcept { return ( static_cast< uint64_t >( mem_displ_ ) << 32 ) | immediate_; }

	/// @brief Sets the immediate value for a 64-bit immediate operand.
	constexpr void set_immediate64( uint64_t value ) noexcept { immediate_ = static_cast< uint32_t >( value ); mem_displ_ = value >> 32; }

	/// @brief Gets the 8-bit immediate sign-extended to 16 bits.
	/// @details Use this if operand kind is OpKind::IMMEDIATE8TO16
	[[nodiscard]] constexpr int16_t immediate8to16() const noexcept { return static_cast< int16_t >( static_cast< int8_t >( immediate_ ) ); }

	/// @brief Sets the 8-bit immediate (sign-extended to 16 bits).
	constexpr void set_immediate8to16( int16_t value ) noexcept { immediate_ = static_cast< uint32_t >( static_cast< int8_t >( value ) ); }

	/// @brief Gets the 8-bit immediate sign-extended to 32 bits.
	/// @details Use this if operand kind is OpKind::IMMEDIATE8TO32
	[[nodiscard]] constexpr int32_t immediate8to32() const noexcept { return static_cast< int32_t >( static_cast< int8_t >( immediate_ ) ); }

	/// @brief Sets the 8-bit immediate (sign-extended to 32 bits).
	constexpr void set_immediate8to32( int32_t value ) noexcept { immediate_ = static_cast< uint32_t >( static_cast< int8_t >( value ) ); }

	/// @brief Gets the 8-bit immediate sign-extended to 64 bits.
	/// @details Use this if operand kind is OpKind::IMMEDIATE8TO64
	[[nodiscard]] constexpr int64_t immediate8to64() const noexcept { return static_cast< int64_t >( static_cast< int8_t >( immediate_ ) ); }

	/// @brief Sets the 8-bit immediate (sign-extended to 64 bits).
	constexpr void set_immediate8to64( int64_t value ) noexcept { immediate_ = static_cast< uint32_t >( static_cast< int8_t >( value ) ); }

	/// @brief Gets the 32-bit immediate sign-extended to 64 bits.
	/// @details Use this if operand kind is OpKind::IMMEDIATE32TO64
	[[nodiscard]] constexpr int64_t immediate32to64() const noexcept { return static_cast< int64_t >( static_cast< int32_t >( immediate_ ) ); }

	/// @brief Sets the 32-bit immediate (sign-extended to 64 bits).
	constexpr void set_immediate32to64( int64_t value ) noexcept { immediate_ = static_cast< uint32_t >( value ); }

	// === Branch Targets ===

	/// @brief Gets the near branch 16-bit target.
	[[nodiscard]] constexpr uint16_t near_branch16() const noexcept { return static_cast< uint16_t >( mem_displ_ ); }

	/// @brief Sets the near branch 16-bit target.
	constexpr void set_near_branch16( uint16_t value ) noexcept { mem_displ_ = value; }

	/// @brief Gets the near branch 32-bit target.
	[[nodiscard]] constexpr uint32_t near_branch32() const noexcept { return static_cast< uint32_t >( mem_displ_ ); }

	/// @brief Sets the near branch 32-bit target.
	constexpr void set_near_branch32( uint32_t value ) noexcept { mem_displ_ = value; }

	/// @brief Gets the near branch 64-bit target.
	[[nodiscard]] constexpr uint64_t near_branch64() const noexcept { return mem_displ_; }

	/// @brief Sets the near branch 64-bit target.
	constexpr void set_near_branch64( uint64_t value ) noexcept { mem_displ_ = value; }

	/// @brief Gets the near branch target address based on operand kind.
	/// @details Checks the first operand kind (or second for JKZD/JKNZD) and returns
	/// the appropriately sized branch target. Returns 0 if not a near branch.
	[[nodiscard]] uint64_t near_branch_target() const noexcept;

	/// @brief Gets the far branch 16-bit offset.
	[[nodiscard]] constexpr uint16_t far_branch16() const noexcept { return static_cast< uint16_t >( immediate_ ); }

	/// @brief Sets the far branch 16-bit offset.
	constexpr void set_far_branch16( uint16_t value ) noexcept { immediate_ = value; }

	/// @brief Gets the far branch 32-bit offset.
	[[nodiscard]] constexpr uint32_t far_branch32() const noexcept { return immediate_; }

	/// @brief Sets the far branch 32-bit offset.
	constexpr void set_far_branch32( uint32_t value ) noexcept { immediate_ = value; }

	/// @brief Gets the far branch selector.
	[[nodiscard]] constexpr uint16_t far_branch_selector() const noexcept { return static_cast< uint16_t >( mem_displ_ ); }

	/// @brief Sets the far branch selector.
	constexpr void set_far_branch_selector( uint16_t value ) noexcept { mem_displ_ = value; }

	// === Prefixes ===

	/// @brief Checks if the instruction has a LOCK prefix.
	[[nodiscard]] constexpr bool has_lock_prefix() const noexcept { return ( flags1_ & 0x8000'0000U ) != 0; }

	/// @brief Sets whether the instruction has a LOCK prefix.
	constexpr void set_has_lock_prefix( bool value ) noexcept { if ( value ) flags1_ |= 0x8000'0000U; else flags1_ &= ~0x8000'0000U; }

	/// @brief Checks if the instruction has a REP/REPE prefix.
	[[nodiscard]] constexpr bool has_rep_prefix() const noexcept { return ( flags1_ & 0x2000'0000U ) != 0; }
	/// @brief Alias for has_rep_prefix().
	[[nodiscard]] constexpr bool has_repe_prefix() const noexcept { return has_rep_prefix(); }

	/// @brief Sets whether the instruction has a REP/REPE prefix.
	constexpr void set_has_rep_prefix( bool value ) noexcept { if ( value ) flags1_ |= 0x2000'0000U; else flags1_ &= ~0x2000'0000U; }
	/// @brief Alias for set_has_rep_prefix().
	constexpr void set_has_repe_prefix( bool value ) noexcept { set_has_rep_prefix( value ); }

	/// @brief Checks if the instruction has a REPNE prefix.
	[[nodiscard]] constexpr bool has_repne_prefix() const noexcept { return ( flags1_ & 0x4000'0000U ) != 0; }

	/// @brief Sets whether the instruction has a REPNE prefix.
	constexpr void set_has_repne_prefix( bool value ) noexcept { if ( value ) flags1_ |= 0x4000'0000U; else flags1_ &= ~0x4000'0000U; }

	// === EVEX/VEX/XOP/MVEX Features ===

	/// @brief Checks if this is a broadcast instruction (EVEX.b).
	[[nodiscard]] constexpr bool is_broadcast() const noexcept { return ( flags1_ & 0x0400'0000U ) != 0; }

	/// @brief Sets the broadcast flag.
	constexpr void set_is_broadcast( bool value ) noexcept { if ( value ) flags1_ |= 0x0400'0000U; else flags1_ &= ~0x0400'0000U; }

	/// @brief Checks if suppress-all-exceptions is enabled (EVEX/MVEX).
	[[nodiscard]] constexpr bool suppress_all_exceptions() const noexcept { return ( flags1_ & 0x0800'0000U ) != 0; }

	/// @brief Sets the suppress-all-exceptions flag.
	constexpr void set_suppress_all_exceptions( bool value ) noexcept { if ( value ) flags1_ |= 0x0800'0000U; else flags1_ &= ~0x0800'0000U; }

	/// @brief Checks if zeroing-masking is used (EVEX.z).
	[[nodiscard]] constexpr bool zeroing_masking() const noexcept { return ( flags1_ & 0x1000'0000U ) != 0; }

	/// @brief Sets zeroing-masking mode.
	constexpr void set_zeroing_masking( bool value ) noexcept { if ( value ) flags1_ |= 0x1000'0000U; else flags1_ &= ~0x1000'0000U; }

	/// @brief Checks if merging-masking is used.
	[[nodiscard]] constexpr bool merging_masking() const noexcept { return !zeroing_masking(); }

	/// @brief Gets the rounding control.
	[[nodiscard]] RoundingControl rounding_control() const noexcept;

	/// @brief Sets the rounding control.
	void set_rounding_control( RoundingControl value ) noexcept;

	/// @brief Gets the opmask register (k1-k7) or Register::NONE.
	[[nodiscard]] Register op_mask() const noexcept;

	/// @brief Sets the opmask register.
	void set_op_mask( Register value ) noexcept;

	/// @brief Gets the code size used when decoding this instruction.
	[[nodiscard]] CodeSize code_size() const noexcept;

	/// @brief Sets the code size.
	void set_code_size( CodeSize value ) noexcept;

	// === Declare Data Methods ===

	/// @brief Gets the number of elements in a db/dw/dd/dq directive.
	/// Can only be called if code() is DeclareByte, DeclareWord, DeclareDword, or DeclareQword.
	[[nodiscard]] uint32_t declare_data_len() const noexcept;

	/// @brief Sets the number of elements in a db/dw/dd/dq directive.
	/// @param value New value: db: 1-16; dw: 1-8; dd: 1-4; dq: 1-2
	void set_declare_data_len( uint32_t value ) noexcept;

	/// @brief Gets a db value at the specified index.
	/// @param index Index (0-15)
	[[nodiscard]] uint8_t get_declare_byte_value( uint32_t index ) const noexcept;

	/// @brief Sets a db value at the specified index.
	/// @param index Index (0-15)
	/// @param value New value
	void set_declare_byte_value( uint32_t index, uint8_t value ) noexcept;

	/// @brief Gets a dw value at the specified index.
	/// @param index Index (0-7)
	[[nodiscard]] uint16_t get_declare_word_value( uint32_t index ) const noexcept;

	/// @brief Sets a dw value at the specified index.
	/// @param index Index (0-7)
	/// @param value New value
	void set_declare_word_value( uint32_t index, uint16_t value ) noexcept;

	/// @brief Gets a dd value at the specified index.
	/// @param index Index (0-3)
	[[nodiscard]] uint32_t get_declare_dword_value( uint32_t index ) const noexcept;

	/// @brief Sets a dd value at the specified index.
	/// @param index Index (0-3)
	/// @param value New value
	void set_declare_dword_value( uint32_t index, uint32_t value ) noexcept;

	/// @brief Gets a dq value at the specified index.
	/// @param index Index (0-1)
	[[nodiscard]] uint64_t get_declare_qword_value( uint32_t index ) const noexcept;

	/// @brief Sets a dq value at the specified index.
	/// @param index Index (0-1)
	/// @param value New value
	void set_declare_qword_value( uint32_t index, uint64_t value ) noexcept;

	// === MVEX Methods ===

	/// @brief Returns true if eviction hint bit is set ({eh}) (MVEX instructions only).
	[[nodiscard]] bool is_mvex_eviction_hint() const noexcept;

	/// @brief Sets the eviction hint bit (MVEX instructions only).
	void set_is_mvex_eviction_hint( bool value ) noexcept;

	/// @brief Gets the MVEX register/memory operand conversion function.
	[[nodiscard]] MvexRegMemConv mvex_reg_mem_conv() const noexcept;

	/// @brief Sets the MVEX register/memory operand conversion function.
	void set_mvex_reg_mem_conv( MvexRegMemConv value ) noexcept;

};

static_assert( sizeof( Instruction ) == 40, "Instruction size mismatch with Rust implementation" );

} // namespace iced_x86

#endif // ICED_X86_INSTRUCTION_HPP
