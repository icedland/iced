// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once
#ifndef ICED_X86_DECODER_HPP
#define ICED_X86_DECODER_HPP

#include "iced_x86/instruction.hpp"
#include "iced_x86/decoder_error.hpp"
#include "iced_x86/decoder_options.hpp"
#include "iced_x86/code_size.hpp"
#include "iced_x86/internal/handlers.hpp"

#include <cstdint>
#include <cstddef>
#include <cstring>
#include <span>
#include <expected>
#include <optional>
#include <vector>

// Force inlining for hot path functions
#ifdef _MSC_VER
#define ICED_FORCEINLINE __forceinline
#else
#define ICED_FORCEINLINE __attribute__((always_inline)) inline
#endif

namespace iced_x86 {

/// @brief Error information returned when decoding fails.
struct DecodeError {
	DecoderError error = DecoderError::NONE;
	uint64_t ip = 0;
};

/// @brief Operand size enumeration
enum class OpSize : uint8_t {
	SIZE16 = 0,
	SIZE32 = 1,
	SIZE64 = 2
};

/// @brief Mandatory prefix state
enum class DecoderMandatoryPrefix : uint8_t {
	PNP = 0,  // No prefix or 66/F2/F3 not treated as mandatory prefix
	P66 = 1,  // 66 prefix
	PF3 = 2,  // F3 prefix
	PF2 = 3   // F2 prefix
};

/// @brief State flags for decoder
struct StateFlags {
	static constexpr uint32_t HAS_REX = 1u << 0;
	static constexpr uint32_t W = 1u << 1;
	static constexpr uint32_t IS_INVALID = 1u << 2;
	static constexpr uint32_t NO_MORE_BYTES = 1u << 3;
	static constexpr uint32_t HAS66 = 1u << 4;
	static constexpr uint32_t LOCK = 1u << 5;
	static constexpr uint32_t ALLOW_LOCK = 1u << 6;
	static constexpr uint32_t ADDR64 = 1u << 7;
	static constexpr uint32_t IP_REL64 = 1u << 8;
	static constexpr uint32_t IP_REL32 = 1u << 9;
	static constexpr uint32_t B = 1u << 10;  // EVEX.b broadcast/rounding
	static constexpr uint32_t Z = 1u << 11;  // EVEX.z zeroing-masking
};

/// @brief Vector length for VEX/EVEX instructions
enum class VectorLength : uint8_t {
	L128 = 0,  // 128-bit (XMM)
	L256 = 1,  // 256-bit (YMM)
	L512 = 2,  // 512-bit (ZMM) - EVEX only
	UNKNOWN = 3
};

/// @brief Decoder state
/// Layout optimized to match Rust: fields cleared together are adjacent,
/// small fields grouped to avoid padding.
struct DecoderState {
	// First 4 fields - read from modrm byte
	uint32_t modrm = 0;
	uint32_t mod_ = 0;
	uint32_t reg = 0;
	uint32_t rm = 0;
	
	// Fields cleared together in decode_internal() - keep adjacent for cache efficiency
	uint32_t extra_register_base = 0;
	uint32_t extra_index_register_base = 0;
	uint32_t extra_base_register_base = 0;
	uint32_t extra_index_register_base_vsib = 0; // EVEX.V' for VSIB
	uint32_t flags = 0;
	
	// These are also cleared together
	uint32_t vvvv = 0;
	uint32_t vvvv_invalid_check = 0;  // For validation
	
	// EVEX-specific fields
	uint32_t aaa = 0;  // EVEX opmask register (k0-k7)
	uint32_t extra_register_base_evex = 0;    // EVEX.R' extension
	uint32_t extra_base_register_base_evex = 0; // EVEX.X' and B' extensions
	
	// Memory index for dispatch tables
	uint32_t mem_index = 0;
	
	// These 4 bytes are accessed/written together - keep 4-byte aligned
	OpSize address_size = OpSize::SIZE64;
	OpSize operand_size = OpSize::SIZE32;
	uint8_t segment_prio = 0;
	uint8_t dummy = 0;  // Padding to align, also helps compiler clear all 4 at once
	
	// Less frequently used fields at end
	DecoderMandatoryPrefix mandatory_prefix = DecoderMandatoryPrefix::PNP;
	VectorLength vector_length = VectorLength::L128;
	bool modrm_read = false;  // Track if modrm has been read for this instruction
	uint8_t pad_ = 0;  // Explicit padding
};

/// @brief x86/x64 instruction decoder.
///
/// @details Decodes x86/x64 instructions from a byte buffer. Supports 16-bit,
/// 32-bit, and 64-bit modes.
class Decoder {
public:
	/// @brief Creates a decoder for the specified bitness.
	/// @param bitness 16, 32, or 64
	/// @param data Code bytes to decode
	/// @param ip Instruction pointer of first byte
	/// @param options Decoder options
	Decoder(
	  uint32_t bitness,
	  std::span< const uint8_t > data,
	  uint64_t ip = 0,
	  DecoderOptions::Value options = DecoderOptions::NONE
	) noexcept;

	/// @brief Decodes the next instruction.
	/// @return Decoded instruction or error
	[[nodiscard]] std::expected< Instruction, DecodeError > decode() noexcept;

	/// @brief Decodes the next instruction (never fails, returns invalid on error).
	/// @param[out] error Set to the error code if decoding fails
	[[nodiscard]] Instruction decode_out( DecoderError& error ) noexcept;

	/// @brief Decodes the next instruction into an existing instruction object.
	/// @param[out] instruction Instruction to decode into (will be reset)
	/// @param[out] error Set to the error code if decoding fails
	void decode_out( Instruction& instruction, DecoderError& error ) noexcept;

	/// @brief Checks if there are more bytes to decode.
	[[nodiscard]] bool can_decode() const noexcept;

	/// @brief Gets current position in bytes.
	[[nodiscard]] std::size_t position() const noexcept { return position_; }

	/// @brief Sets current position in bytes.
	void set_position( std::size_t pos ) noexcept;

	/// @brief Gets current instruction pointer.
	[[nodiscard]] uint64_t ip() const noexcept { return ip_; }

	/// @brief Gets current read position IP as 32-bit value.
	/// This returns the IP at the current read position (ip_ + bytes read so far).
	[[nodiscard]] uint32_t current_ip32() const noexcept { return static_cast<uint32_t>( ip_ + position_ - instr_start_position_ ); }

	/// @brief Gets current read position IP as 64-bit value.
	/// This returns the IP at the current read position (ip_ + bytes read so far).
	[[nodiscard]] uint64_t current_ip64() const noexcept { return ip_ + position_ - instr_start_position_; }

	/// @brief Sets current instruction pointer.
	void set_ip( uint64_t ip ) noexcept { ip_ = ip; }

	/// @brief Gets the bitness (16, 32, or 64).
	[[nodiscard]] uint32_t bitness() const noexcept { return bitness_; }

	/// @brief Gets the total number of data bytes.
	[[nodiscard]] std::size_t max_position() const noexcept { return data_.size(); }

	/// @brief Gets the decoder options.
	[[nodiscard]] DecoderOptions::Value options() const noexcept { return options_; }

	/// @brief Checks if AMD decoder option is enabled.
	[[nodiscard]] bool has_amd_option() const noexcept { return ( options_ & DecoderOptions::AMD ) != 0; }

	/// @brief Gets the decoder state (for handler use).
	[[nodiscard]] DecoderState& state() noexcept { return state_; }
	[[nodiscard]] const DecoderState& state() const noexcept { return state_; }

	/// @brief Reads a byte from the input stream.
	[[nodiscard]] std::optional<uint8_t> read_byte() noexcept;

	/// @brief Reads a word (2 bytes) from the input stream.
	[[nodiscard]] std::optional<uint16_t> read_u16() noexcept;

	/// @brief Reads a dword (4 bytes) from the input stream.
	[[nodiscard]] std::optional<uint32_t> read_u32() noexcept;

	/// @brief Reads a qword (8 bytes) from the input stream.
	[[nodiscard]] std::optional<uint64_t> read_u64() noexcept;

	/// @brief Fast byte read - returns 0 and sets error flag on failure.
	/// Like Rust's read_u8(), errors are checked later via state flags.
	[[nodiscard]] ICED_FORCEINLINE uint32_t read_u8_fast() noexcept {
	  if ( position_ < max_instr_position_ ) [[likely]] {
	    return data_[position_++];
	  }
	  state_.flags |= StateFlags::IS_INVALID | StateFlags::NO_MORE_BYTES;
	  return 0;
	}

	/// @brief Fast u16 read - returns 0 and sets error flag on failure.
	[[nodiscard]] ICED_FORCEINLINE uint32_t read_u16_fast() noexcept {
	  if ( position_ + 2 <= max_instr_position_ ) [[likely]] {
	    uint16_t result;
	    std::memcpy( &result, &data_[position_], 2 );
	    position_ += 2;
	    return result;
	  }
	  state_.flags |= StateFlags::IS_INVALID | StateFlags::NO_MORE_BYTES;
	  return 0;
	}

	/// @brief Fast u32 read - returns 0 and sets error flag on failure.
	[[nodiscard]] ICED_FORCEINLINE uint32_t read_u32_fast() noexcept {
	  if ( position_ + 4 <= max_instr_position_ ) [[likely]] {
	    uint32_t result;
	    std::memcpy( &result, &data_[position_], 4 );
	    position_ += 4;
	    return result;
	  }
	  state_.flags |= StateFlags::IS_INVALID | StateFlags::NO_MORE_BYTES;
	  return 0;
	}

	/// @brief Fast u64 read - returns 0 and sets error flag on failure.
	[[nodiscard]] ICED_FORCEINLINE uint64_t read_u64_fast() noexcept {
	  if ( position_ + 8 <= max_instr_position_ ) [[likely]] {
	    uint64_t result;
	    std::memcpy( &result, &data_[position_], 8 );
	    position_ += 8;
	    return result;
	  }
	  state_.flags |= StateFlags::IS_INVALID | StateFlags::NO_MORE_BYTES;
	  return 0;
	}

	/// @brief Fast unchecked byte read - caller must ensure bytes are available.
	/// Use can_read(1) to check first.
	[[nodiscard]] uint8_t read_byte_unchecked() noexcept {
	  return data_[position_++];
	}

	/// @brief Fast unchecked u16 read - caller must ensure bytes are available.
	[[nodiscard]] uint16_t read_u16_unchecked() noexcept {
	  uint16_t result = static_cast<uint16_t>( data_[position_] ) |
	                    ( static_cast<uint16_t>( data_[position_ + 1] ) << 8 );
	  position_ += 2;
	  return result;
	}

	/// @brief Fast unchecked u32 read - caller must ensure bytes are available.
	[[nodiscard]] uint32_t read_u32_unchecked() noexcept {
	  uint32_t result = static_cast<uint32_t>( data_[position_] ) |
	                    ( static_cast<uint32_t>( data_[position_ + 1] ) << 8 ) |
	                    ( static_cast<uint32_t>( data_[position_ + 2] ) << 16 ) |
	                    ( static_cast<uint32_t>( data_[position_ + 3] ) << 24 );
	  position_ += 4;
	  return result;
	}

	/// @brief Fast unchecked u64 read - caller must ensure bytes are available.
	[[nodiscard]] uint64_t read_u64_unchecked() noexcept {
	  uint64_t result = static_cast<uint64_t>( data_[position_] ) |
	                    ( static_cast<uint64_t>( data_[position_ + 1] ) << 8 ) |
	                    ( static_cast<uint64_t>( data_[position_ + 2] ) << 16 ) |
	                    ( static_cast<uint64_t>( data_[position_ + 3] ) << 24 ) |
	                    ( static_cast<uint64_t>( data_[position_ + 4] ) << 32 ) |
	                    ( static_cast<uint64_t>( data_[position_ + 5] ) << 40 ) |
	                    ( static_cast<uint64_t>( data_[position_ + 6] ) << 48 ) |
	                    ( static_cast<uint64_t>( data_[position_ + 7] ) << 56 );
	  position_ += 8;
	  return result;
	}

	/// @brief Check if n bytes can be read within the current instruction.
	[[nodiscard]] bool can_read( std::size_t n ) const noexcept {
	  return position_ + n <= max_instr_position_;
	}

	/// @brief Sets the instruction as invalid.
	void set_invalid_instruction() noexcept;

	/// @brief Reads modrm byte unconditionally (for sub-handlers that need fresh modrm).
	void read_modrm() noexcept {
	  if ( position_ >= max_instr_position_ ) [[unlikely]] {
	    state_.flags |= StateFlags::IS_INVALID | StateFlags::NO_MORE_BYTES;
	    return;
	  }
	  auto m = static_cast<uint32_t>( data_[position_++] );
	  state_.modrm = m;
	  state_.reg = ( m >> 3 ) & 7;
	  state_.mod_ = m >> 6;
	  state_.rm = m & 7;
	  state_.mem_index = ( state_.mod_ << 3 ) | state_.rm;
	}

	/// @brief Checks if running in 64-bit mode.
	[[nodiscard]] bool is_64bit_mode() const noexcept { return bitness_ == 64; }

	/// @brief Resets REX prefix state (called by prefix handlers).
	void reset_rex_prefix_state() noexcept;

	/// @brief Calls the map0 opcode handler table.
	void call_opcode_handlers_map0_table( Instruction& instruction ) noexcept;

	/// @brief Reads a memory operand.
	/// @param instruction The instruction being decoded
	/// @param operand_index Which operand slot (0-4)
	void read_op_mem( Instruction& instruction, uint32_t operand_index ) noexcept;

	/// @brief Reads a VSIB memory operand (for gather/scatter instructions).
	/// @param instruction The instruction being decoded
	/// @param operand_index Which operand slot (0-4)
	/// @param vsib_index Base register for VSIB index (e.g., XMM0, YMM0, ZMM0)
	/// @param tuple_type Tuple type for displacement scaling
	void read_op_mem_vsib( Instruction& instruction, uint32_t operand_index, Register vsib_index, uint32_t tuple_type ) noexcept;

	/// @brief Decodes VEX2 (C5) prefix and dispatches to VEX handler.
	void decode_vex2( Instruction& instruction ) noexcept;

	/// @brief Decodes VEX3 (C4) prefix and dispatches to VEX handler.
	void decode_vex3( Instruction& instruction ) noexcept;

	/// @brief Decodes EVEX (62) prefix and dispatches to EVEX handler.
	void decode_evex( Instruction& instruction ) noexcept;

	/// @brief Decodes XOP prefix and dispatches to XOP handler.
	void decode_xop( Instruction& instruction ) noexcept;

	/// @brief Decodes 3DNow! prefix and dispatches to 3DNow! handler.
	void decode_3dnow( Instruction& instruction ) noexcept;

	/// @brief Gets the VEX handler table for the specified map.
	/// @param map_index Map index (0=0F, 1=0F38, 2=0F3A)
	/// @return Handler table span (empty if invalid)
	[[nodiscard]] std::span<const internal::HandlerEntry> get_vex_table( uint32_t map_index ) const noexcept;

	/// @brief Gets the EVEX handler table for the specified map.
	/// @param map_index Map index (0=0F, 1=0F38, 2=0F3A, 4=MAP5, 5=MAP6)
	/// @return Handler table span (empty if invalid)
	[[nodiscard]] std::span<const internal::HandlerEntry> get_evex_table( uint32_t map_index ) const noexcept;

	/// @brief Gets the mask for register extension bits (0xF in 64-bit, 0x7 in 32/16-bit).
	[[nodiscard]] uint32_t reg15_mask() const noexcept { return bitness_ == 64 ? 0xF : 0x7; }

	/// @brief Gets the invalid check mask for VEX/EVEX prefix validation.
	[[nodiscard]] uint32_t invalid_check_mask() const noexcept { return invalid_check_mask_; }

	/// @brief Reads an EVEX memory operand with tuple type for displacement scaling.
	/// @param instruction The instruction being decoded
	/// @param operand_index Which operand slot (0-4)
	/// @param tuple_type Tuple type for EVEX displacement scaling
	void read_op_mem_evex( Instruction& instruction, uint32_t operand_index, uint32_t tuple_type ) noexcept;

	/// @brief Dispatch to a handler, reading modrm if required.
	/// @param handler The handler entry to dispatch to
	/// @param instruction The instruction being decoded
	void decode_table( internal::HandlerEntry handler, Instruction& instruction ) noexcept;

private:
	void decode_internal( Instruction& instruction ) noexcept;

	// Memory decoding helpers
	void read_op_mem_32_or_64( Instruction& instruction, uint32_t operand_index ) noexcept;
	void read_op_mem_16( Instruction& instruction, uint32_t operand_index ) noexcept;
	bool read_sib( Instruction& instruction ) noexcept;

	std::span< const uint8_t > data_;
	std::size_t position_ = 0;
	std::size_t instr_start_position_ = 0;
	std::size_t max_instr_position_ = 0;
	uint64_t ip_ = 0;
	uint32_t bitness_ = 64;
	DecoderOptions::Value options_ = DecoderOptions::NONE;

	// Default sizes based on bitness
	OpSize default_operand_size_ = OpSize::SIZE32;
	OpSize default_inverted_operand_size_ = OpSize::SIZE16;
	OpSize default_address_size_ = OpSize::SIZE64;
	OpSize default_inverted_address_size_ = OpSize::SIZE32;
	CodeSize default_code_size_ = CodeSize::CODE64;

	// Decoder state
	DecoderState state_;

	// Pointers to static handler tables (shared across all Decoder instances)
	std::span<const internal::HandlerEntry> handlers_map0_;
	std::span<const internal::HandlerEntry> handlers_vex_0f_;
	std::span<const internal::HandlerEntry> handlers_vex_0f38_;
	std::span<const internal::HandlerEntry> handlers_vex_0f3a_;
	std::span<const internal::HandlerEntry> handlers_evex_0f_;
	std::span<const internal::HandlerEntry> handlers_evex_0f38_;
	std::span<const internal::HandlerEntry> handlers_evex_0f3a_;
	std::span<const internal::HandlerEntry> handlers_evex_map5_;
	std::span<const internal::HandlerEntry> handlers_evex_map6_;

	// Masks for bitness-dependent behavior
	uint32_t mask_e0_ = 0;  // E0 mask for inverted bits (0xE0 in 64-bit, 0 in 32/16-bit)
	uint32_t invalid_check_mask_ = 0;  // For checking invalid prefix combinations

	static constexpr std::size_t MAX_INSTRUCTION_LENGTH = 15;

	// Static handler tables - initialized once, shared by all Decoder instances
	struct Tables {
		std::vector<internal::HandlerEntry> handlers_map0;
		std::vector<internal::HandlerEntry> handlers_vex_0f;
		std::vector<internal::HandlerEntry> handlers_vex_0f38;
		std::vector<internal::HandlerEntry> handlers_vex_0f3a;
		std::vector<internal::HandlerEntry> handlers_evex_0f;
		std::vector<internal::HandlerEntry> handlers_evex_0f38;
		std::vector<internal::HandlerEntry> handlers_evex_0f3a;
		std::vector<internal::HandlerEntry> handlers_evex_map5;
		std::vector<internal::HandlerEntry> handlers_evex_map6;
	};

	static const Tables& get_tables();
};

} // namespace iced_x86

#endif // ICED_X86_DECODER_HPP
