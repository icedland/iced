// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once
#ifndef ICED_X86_REGISTER_INFO_HPP
#define ICED_X86_REGISTER_INFO_HPP

#include "iced_x86/register.hpp"

#include <array>
#include <cstdint>

namespace iced_x86 {

/// @brief Contains information about a register.
struct RegisterInfo {
	/// @brief The register.
	Register register_;
	/// @brief The base register (eg. AL, AX, EAX, RAX, MM0, XMM0, YMM0, ZMM0, ES).
	Register base;
	/// @brief The full register that this one is a part of, except for GPRs where the 32-bit version is returned.
	Register full_register32;
	/// @brief The full register that this one is a part of.
	Register full_register;
	/// @brief Size of the register in bytes.
	uint16_t size;

	/// @brief Gets the register number (index) relative to base().
	[[nodiscard]] constexpr std::size_t number() const noexcept {
		return static_cast<std::size_t>( register_ ) - static_cast<std::size_t>( base );
	}
};

namespace internal {
extern const std::array< RegisterInfo, 256 > g_register_infos;
} // namespace internal

/// @brief Gets information about a register.
/// @param reg The register.
/// @return Information about the register.
[[nodiscard]] inline const RegisterInfo& get_register_info( Register reg ) noexcept {
	return internal::g_register_infos[static_cast<std::size_t>( reg )];
}

/// @brief Gets the base register (eg. AL, AX, EAX, RAX, MM0, XMM0, YMM0, ZMM0, ES).
/// @param reg The register.
/// @return The base register.
[[nodiscard]] inline Register register_base( Register reg ) noexcept {
	return get_register_info( reg ).base;
}

/// @brief Gets the register number (index) relative to its base register.
/// @param reg The register.
/// @return The register number.
[[nodiscard]] inline std::size_t register_number( Register reg ) noexcept {
	return get_register_info( reg ).number();
}

/// @brief Gets the full register that this one is a part of.
/// @param reg The register.
/// @return The full register.
[[nodiscard]] inline Register register_full_register( Register reg ) noexcept {
	return get_register_info( reg ).full_register;
}

/// @brief Gets the full register (32-bit for GPRs) that this one is a part of.
/// @param reg The register.
/// @return The full 32-bit register.
[[nodiscard]] inline Register register_full_register32( Register reg ) noexcept {
	return get_register_info( reg ).full_register32;
}

/// @brief Gets the size of the register in bytes.
/// @param reg The register.
/// @return Size in bytes.
[[nodiscard]] inline std::size_t register_size( Register reg ) noexcept {
	return get_register_info( reg ).size;
}

/// @brief Checks if it's a segment register (ES, CS, SS, DS, FS, GS).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_segment_register( Register reg ) noexcept {
	return Register::ES <= reg && reg <= Register::GS;
}

/// @brief Checks if it's a general purpose register (AL-R15L, AX-R15W, EAX-R15D, RAX-R15).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_gpr( Register reg ) noexcept {
	return Register::AL <= reg && reg <= Register::R15;
}

/// @brief Checks if it's an 8-bit general purpose register (AL-R15L).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_gpr8( Register reg ) noexcept {
	return Register::AL <= reg && reg <= Register::R15_L;
}

/// @brief Checks if it's a 16-bit general purpose register (AX-R15W).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_gpr16( Register reg ) noexcept {
	return Register::AX <= reg && reg <= Register::R15_W;
}

/// @brief Checks if it's a 32-bit general purpose register (EAX-R15D).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_gpr32( Register reg ) noexcept {
	return Register::EAX <= reg && reg <= Register::R15_D;
}

/// @brief Checks if it's a 64-bit general purpose register (RAX-R15).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_gpr64( Register reg ) noexcept {
	return Register::RAX <= reg && reg <= Register::R15;
}

/// @brief Checks if it's a 128-bit vector register (XMM0-XMM31).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_xmm( Register reg ) noexcept {
	return Register::XMM0 <= reg && reg <= Register::XMM31;
}

/// @brief Checks if it's a 256-bit vector register (YMM0-YMM31).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_ymm( Register reg ) noexcept {
	return Register::YMM0 <= reg && reg <= Register::YMM31;
}

/// @brief Checks if it's a 512-bit vector register (ZMM0-ZMM31).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_zmm( Register reg ) noexcept {
	return Register::ZMM0 <= reg && reg <= Register::ZMM31;
}

/// @brief Checks if it's an XMM, YMM or ZMM register.
/// @param reg The register.
/// @return True if it's a vector register.
[[nodiscard]] inline bool is_vector_register( Register reg ) noexcept {
	return Register::XMM0 <= reg && reg <= Register::ZMM31;
}

/// @brief Checks if it's EIP or RIP.
/// @param reg The register.
/// @return True if it's EIP or RIP.
[[nodiscard]] inline bool is_ip( Register reg ) noexcept {
	return reg == Register::EIP || reg == Register::RIP;
}

/// @brief Checks if it's an opmask register (K0-K7).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_k( Register reg ) noexcept {
	return Register::K0 <= reg && reg <= Register::K7;
}

/// @brief Checks if it's a control register (CR0-CR15).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_cr( Register reg ) noexcept {
	return Register::CR0 <= reg && reg <= Register::CR15;
}

/// @brief Checks if it's a debug register (DR0-DR15).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_dr( Register reg ) noexcept {
	return Register::DR0 <= reg && reg <= Register::DR15;
}

/// @brief Checks if it's a test register (TR0-TR7).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_tr( Register reg ) noexcept {
	return Register::TR0 <= reg && reg <= Register::TR7;
}

/// @brief Checks if it's an FPU stack register (ST0-ST7).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_st( Register reg ) noexcept {
	return Register::ST0 <= reg && reg <= Register::ST7;
}

/// @brief Checks if it's a bound register (BND0-BND3).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_bnd( Register reg ) noexcept {
	return Register::BND0 <= reg && reg <= Register::BND3;
}

/// @brief Checks if it's an MMX register (MM0-MM7).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_mm( Register reg ) noexcept {
	return Register::MM0 <= reg && reg <= Register::MM7;
}

/// @brief Checks if it's a tile register (TMM0-TMM7).
/// @param reg The register.
/// @return True if the condition is met.
[[nodiscard]] inline bool is_tmm( Register reg ) noexcept {
	return Register::TMM0 <= reg && reg <= Register::TMM7;
}

} // namespace iced_x86

#endif // ICED_X86_REGISTER_INFO_HPP
