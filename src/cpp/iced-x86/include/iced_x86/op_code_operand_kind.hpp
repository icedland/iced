// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once
#ifndef ICED_X86_OPCODEOPERANDKIND_HPP
#define ICED_X86_OPCODEOPERANDKIND_HPP

#include <cstdint>
#include <cstddef>

namespace iced_x86 {

/// @brief Operand kind
enum class OpCodeOperandKind : uint8_t {
	/// @brief No operand
	NONE = 0,
	/// @brief Far branch 16-bit offset, 16-bit segment/selector
	FARBR2_2 = 1,
	/// @brief Far branch 32-bit offset, 16-bit segment/selector
	FARBR4_2 = 2,
	/// @brief Memory offset without a modrm byte (eg. @c MOV AL,[offset])
	MEM_OFFS = 3,
	/// @brief Memory (modrm)
	MEM = 4,
	/// @brief Memory (modrm), MPX:
	/// @par
	/// 16/32-bit mode: must be 32-bit addressing
	/// @par
	/// 64-bit mode: 64-bit addressing is forced and must not be RIP relative
	MEM_MPX = 5,
	/// @brief Memory (modrm), MPX:
	/// @par
	/// 16/32-bit mode: must be 32-bit addressing
	/// @par
	/// 64-bit mode: 64-bit addressing is forced and must not be RIP relative
	MEM_MIB = 6,
	/// @brief Memory (modrm), vsib32, @c XMM registers
	MEM_VSIB32X = 7,
	/// @brief Memory (modrm), vsib64, @c XMM registers
	MEM_VSIB64X = 8,
	/// @brief Memory (modrm), vsib32, @c YMM registers
	MEM_VSIB32Y = 9,
	/// @brief Memory (modrm), vsib64, @c YMM registers
	MEM_VSIB64Y = 10,
	/// @brief Memory (modrm), vsib32, @c ZMM registers
	MEM_VSIB32Z = 11,
	/// @brief Memory (modrm), vsib64, @c ZMM registers
	MEM_VSIB64Z = 12,
	/// @brief 8-bit GPR or memory
	R8_OR_MEM = 13,
	/// @brief 16-bit GPR or memory
	R16_OR_MEM = 14,
	/// @brief 32-bit GPR or memory
	R32_OR_MEM = 15,
	/// @brief 32-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
	R32_OR_MEM_MPX = 16,
	/// @brief 64-bit GPR or memory
	R64_OR_MEM = 17,
	/// @brief 64-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
	R64_OR_MEM_MPX = 18,
	/// @brief @c MM register or memory
	MM_OR_MEM = 19,
	/// @brief @c XMM register or memory
	XMM_OR_MEM = 20,
	/// @brief @c YMM register or memory
	YMM_OR_MEM = 21,
	/// @brief @c ZMM register or memory
	ZMM_OR_MEM = 22,
	/// @brief @c BND register or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced
	BND_OR_MEM_MPX = 23,
	/// @brief @c K register or memory
	K_OR_MEM = 24,
	/// @brief 8-bit GPR encoded in the @c reg field of the modrm byte
	R8_REG = 25,
	/// @brief 8-bit GPR encoded in the low 3 bits of the opcode
	R8_OPCODE = 26,
	/// @brief 16-bit GPR encoded in the @c reg field of the modrm byte
	R16_REG = 27,
	/// @brief 16-bit GPR encoded in the @c reg field of the modrm byte. This is a memory operand and it uses the address size prefix (@c 67h) not the operand size prefix (@c 66h).
	R16_REG_MEM = 28,
	/// @brief 16-bit GPR encoded in the @c mod + r/m fields of the modrm byte
	R16_RM = 29,
	/// @brief 16-bit GPR encoded in the low 3 bits of the opcode
	R16_OPCODE = 30,
	/// @brief 32-bit GPR encoded in the @c reg field of the modrm byte
	R32_REG = 31,
	/// @brief 32-bit GPR encoded in the @c reg field of the modrm byte. This is a memory operand and it uses the address size prefix (@c 67h) not the operand size prefix (@c 66h).
	R32_REG_MEM = 32,
	/// @brief 32-bit GPR encoded in the @c mod + r/m fields of the modrm byte
	R32_RM = 33,
	/// @brief 32-bit GPR encoded in the low 3 bits of the opcode
	R32_OPCODE = 34,
	/// @brief 32-bit GPR encoded in the the @c V'vvvv field (VEX/EVEX/XOP)
	R32_VVVV = 35,
	/// @brief 64-bit GPR encoded in the @c reg field of the modrm byte
	R64_REG = 36,
	/// @brief 64-bit GPR encoded in the @c reg field of the modrm byte. This is a memory operand and it uses the address size prefix (@c 67h) not the operand size prefix (@c 66h).
	R64_REG_MEM = 37,
	/// @brief 64-bit GPR encoded in the @c mod + r/m fields of the modrm byte
	R64_RM = 38,
	/// @brief 64-bit GPR encoded in the low 3 bits of the opcode
	R64_OPCODE = 39,
	/// @brief 64-bit GPR encoded in the the @c V'vvvv field (VEX/EVEX/XOP)
	R64_VVVV = 40,
	/// @brief Segment register encoded in the @c reg field of the modrm byte
	SEG_REG = 41,
	/// @brief @c K register encoded in the @c reg field of the modrm byte
	K_REG = 42,
	/// @brief @c K register (+1) encoded in the @c reg field of the modrm byte
	KP1_REG = 43,
	/// @brief @c K register encoded in the @c mod + r/m fields of the modrm byte
	K_RM = 44,
	/// @brief @c K register encoded in the the @c V'vvvv field (VEX/EVEX/MVEX/XOP)
	K_VVVV = 45,
	/// @brief @c MM register encoded in the @c reg field of the modrm byte
	MM_REG = 46,
	/// @brief @c MM register encoded in the @c mod + r/m fields of the modrm byte
	MM_RM = 47,
	/// @brief @c XMM register encoded in the @c reg field of the modrm byte
	XMM_REG = 48,
	/// @brief @c XMM register encoded in the @c mod + r/m fields of the modrm byte
	XMM_RM = 49,
	/// @brief @c XMM register encoded in the the @c V'vvvv field (VEX/EVEX/XOP)
	XMM_VVVV = 50,
	/// @brief @c XMM register (+3) encoded in the the @c V'vvvv field (VEX/EVEX/XOP)
	XMMP3_VVVV = 51,
	/// @brief @c XMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only @c XMM0-@c XMM15)
	XMM_IS4 = 52,
	/// @brief @c XMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only @c XMM0-@c XMM15)
	XMM_IS5 = 53,
	/// @brief @c YMM register encoded in the @c reg field of the modrm byte
	YMM_REG = 54,
	/// @brief @c YMM register encoded in the @c mod + r/m fields of the modrm byte
	YMM_RM = 55,
	/// @brief @c YMM register encoded in the the @c V'vvvv field (VEX/EVEX/XOP)
	YMM_VVVV = 56,
	/// @brief @c YMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only @c YMM0-@c YMM15)
	YMM_IS4 = 57,
	/// @brief @c YMM register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only @c YMM0-@c YMM15)
	YMM_IS5 = 58,
	/// @brief @c ZMM register encoded in the @c reg field of the modrm byte
	ZMM_REG = 59,
	/// @brief @c ZMM register encoded in the @c mod + r/m fields of the modrm byte
	ZMM_RM = 60,
	/// @brief @c ZMM register encoded in the the @c V'vvvv field (VEX/EVEX/MVEX/XOP)
	ZMM_VVVV = 61,
	/// @brief @c ZMM register (+3) encoded in the the @c V'vvvv field (VEX/EVEX/XOP)
	ZMMP3_VVVV = 62,
	/// @brief @c CR register encoded in the @c reg field of the modrm byte
	CR_REG = 63,
	/// @brief @c DR register encoded in the @c reg field of the modrm byte
	DR_REG = 64,
	/// @brief @c TR register encoded in the @c reg field of the modrm byte
	TR_REG = 65,
	/// @brief @c BND register encoded in the @c reg field of the modrm byte
	BND_REG = 66,
	/// @brief @c ES register
	ES = 67,
	/// @brief @c CS register
	CS = 68,
	/// @brief @c SS register
	SS = 69,
	/// @brief @c DS register
	DS = 70,
	/// @brief @c FS register
	FS = 71,
	/// @brief @c GS register
	GS = 72,
	/// @brief @c AL register
	AL = 73,
	/// @brief @c CL register
	CL = 74,
	/// @brief @c AX register
	AX = 75,
	/// @brief @c DX register
	DX = 76,
	/// @brief @c EAX register
	EAX = 77,
	/// @brief @c RAX register
	RAX = 78,
	/// @brief @c ST(0) register
	ST0 = 79,
	/// @brief @c ST(i) register encoded in the low 3 bits of the opcode
	STI_OPCODE = 80,
	/// @brief 4-bit immediate (m2z field, low 4 bits of the /is5 immediate, eg. @c VPERMIL2PS)
	IMM4_M2Z = 81,
	/// @brief 8-bit immediate
	IMM8 = 82,
	/// @brief Constant 1 (8-bit immediate)
	IMM8_CONST_1 = 83,
	/// @brief 8-bit immediate sign extended to 16 bits
	IMM8SEX16 = 84,
	/// @brief 8-bit immediate sign extended to 32 bits
	IMM8SEX32 = 85,
	/// @brief 8-bit immediate sign extended to 64 bits
	IMM8SEX64 = 86,
	/// @brief 16-bit immediate
	IMM16 = 87,
	/// @brief 32-bit immediate
	IMM32 = 88,
	/// @brief 32-bit immediate sign extended to 64 bits
	IMM32SEX64 = 89,
	/// @brief 64-bit immediate
	IMM64 = 90,
	/// @brief @c seg:[rSI] memory operand (string instructions)
	SEG_R_SI = 91,
	/// @brief @c es:[rDI] memory operand (string instructions)
	ES_R_DI = 92,
	/// @brief @c seg:[rDI] memory operand (@c (V)MASKMOVQ instructions)
	SEG_R_DI = 93,
	/// @brief @c seg:[rBX+al] memory operand (@c XLATB instruction)
	SEG_R_BX_AL = 94,
	/// @brief 16-bit branch, 1-byte signed relative offset
	BR16_1 = 95,
	/// @brief 32-bit branch, 1-byte signed relative offset
	BR32_1 = 96,
	/// @brief 64-bit branch, 1-byte signed relative offset
	BR64_1 = 97,
	/// @brief 16-bit branch, 2-byte signed relative offset
	BR16_2 = 98,
	/// @brief 32-bit branch, 4-byte signed relative offset
	BR32_4 = 99,
	/// @brief 64-bit branch, 4-byte signed relative offset
	BR64_4 = 100,
	/// @brief @c XBEGIN, 2-byte signed relative offset
	XBEGIN_2 = 101,
	/// @brief @c XBEGIN, 4-byte signed relative offset
	XBEGIN_4 = 102,
	/// @brief 2-byte branch offset (@c JMPE instruction)
	BRDISP_2 = 103,
	/// @brief 4-byte branch offset (@c JMPE instruction)
	BRDISP_4 = 104,
	/// @brief Memory (modrm) and the sib byte must be present
	SIBMEM = 105,
	/// @brief @c TMM register encoded in the @c reg field of the modrm byte
	TMM_REG = 106,
	/// @brief @c TMM register encoded in the @c mod + r/m fields of the modrm byte
	TMM_RM = 107,
	/// @brief @c TMM register encoded in the the @c V'vvvv field (VEX/EVEX/XOP)
	TMM_VVVV = 108
};

/// @brief Number of OpCodeOperandKind enum values.
constexpr std::size_t OP_CODE_OPERAND_KIND_COUNT = 109;

} // namespace iced_x86

#endif // ICED_X86_OPCODEOPERANDKIND_HPP
