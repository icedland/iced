// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once
#ifndef ICED_X86_OPACCESS_HPP
#define ICED_X86_OPACCESS_HPP

#include <cstdint>
#include <cstddef>

namespace iced_x86 {

/// @brief Operand, register and memory access
enum class OpAccess : uint8_t {
	/// @brief Nothing is read and nothing is written
	NONE = 0,
	/// @brief The value is read
	READ = 1,
	/// @brief The value is sometimes read and sometimes not
	COND_READ = 2,
	/// @brief The value is completely overwritten
	WRITE = 3,
	/// @brief Conditional write, sometimes it's written and sometimes it's not modified
	COND_WRITE = 4,
	/// @brief The value is read and written
	READ_WRITE = 5,
	/// @brief The value is read and sometimes written
	READ_COND_WRITE = 6,
	/// @brief The memory operand doesn't refer to memory (eg. @c LEA instruction) or it's an instruction that doesn't read the data to a register or doesn't write to the memory location, it just prefetches/invalidates it, eg. @c INVLPG, @c PREFETCHNTA, @c VGATHERPF0DPS, etc. Some of those instructions still check if the code can access the memory location.
	NO_MEM_ACCESS = 7
};

/// @brief Number of OpAccess enum values.
constexpr std::size_t OP_ACCESS_COUNT = 8;

} // namespace iced_x86

#endif // ICED_X86_OPACCESS_HPP
