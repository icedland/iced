// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once
#ifndef ICED_X86_FLOWCONTROL_HPP
#define ICED_X86_FLOWCONTROL_HPP

#include <cstdint>
#include <cstddef>

namespace iced_x86 {

/// @brief Control flow
enum class FlowControl : uint8_t {
	/// @brief The next instruction that will be executed is the next instruction in the instruction stream
	NEXT = 0,
	/// @brief It's an unconditional branch instruction: @c JMP NEAR, @c JMP FAR
	UNCONDITIONAL_BRANCH = 1,
	/// @brief It's an unconditional indirect branch: @c JMP NEAR reg, @c JMP NEAR [mem], @c JMP FAR [mem]
	INDIRECT_BRANCH = 2,
	/// @brief It's a conditional branch instruction: @c Jcc SHORT, @c Jcc NEAR, @c LOOP, @c LOOPcc, @c JRCXZ, @c JKccD SHORT, @c JKccD NEAR
	CONDITIONAL_BRANCH = 3,
	/// @brief It's a return instruction: @c RET NEAR, @c RET FAR, @c IRET, @c SYSRET, @c SYSEXIT, @c RSM, @c SKINIT, @c RDM, @c UIRET
	RETURN = 4,
	/// @brief It's a call instruction: @c CALL NEAR, @c CALL FAR, @c SYSCALL, @c SYSENTER, @c VMLAUNCH, @c VMRESUME, @c VMCALL, @c VMMCALL, @c VMGEXIT, @c VMRUN, @c TDCALL, @c SEAMCALL, @c SEAMRET
	CALL = 5,
	/// @brief It's an indirect call instruction: @c CALL NEAR reg, @c CALL NEAR [mem], @c CALL FAR [mem]
	INDIRECT_CALL = 6,
	/// @brief It's an interrupt instruction: @c INT n, @c INT3, @c INT1, @c INTO, @c SMINT, @c DMINT
	INTERRUPT = 7,
	/// @brief It's @c XBEGIN
	XBEGIN_XABORT_XEND = 8,
	/// @brief It's an invalid instruction, eg. @ref Code::INVALID, @c UD0, @c UD1, @c UD2
	EXCEPTION = 9
};

/// @brief Number of FlowControl enum values.
constexpr std::size_t FLOW_CONTROL_COUNT = 10;

} // namespace iced_x86

#endif // ICED_X86_FLOWCONTROL_HPP
