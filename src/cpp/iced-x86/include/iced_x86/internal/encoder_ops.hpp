// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once
#ifndef ICED_X86_ENCODER_OPS_HPP
#define ICED_X86_ENCODER_OPS_HPP

#include "iced_x86/register.hpp"
#include "iced_x86/op_kind.hpp"

#include <cstdint>

namespace iced_x86 {
class Encoder;  // Forward declaration
struct Instruction;  // Forward declaration
}

namespace iced_x86::internal {

using iced_x86::Encoder;
using iced_x86::Instruction;

/// @brief Base interface for operand encoders
struct Op {
	virtual ~Op() = default;
	virtual void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const = 0;
};

/// @brief Invalid operand handler (should never be called)
struct InvalidOpHandler : Op {
	constexpr InvalidOpHandler() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpA - Absolute address operand (far call/jmp)
struct OpA : Op {
	uint32_t size;
	constexpr explicit OpA(uint32_t size_) : size(size_) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpHx - VEX/EVEX vvvv register operand
struct OpHx : Op {
	Register reg_lo;
	Register reg_hi;
	constexpr OpHx(Register lo, Register hi) : reg_lo(lo), reg_hi(hi) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpI4 - 4-bit immediate (high nibble of byte)
struct OpI4 : Op {
	constexpr OpI4() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpIb - 8-bit immediate
struct OpIb : Op {
	OpKind op_kind;
	constexpr explicit OpIb(OpKind kind) : op_kind(kind) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpId - 32-bit immediate
struct OpId : Op {
	OpKind op_kind;
	constexpr explicit OpId(OpKind kind) : op_kind(kind) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpImm - Fixed immediate value
struct OpImm : Op {
	uint32_t value;
	constexpr explicit OpImm(uint32_t val) : value(val) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpIq - 64-bit immediate
struct OpIq : Op {
	constexpr OpIq() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpIsX - Is4/Is5 immediate register encoding
struct OpIsX : Op {
	Register reg_lo;
	Register reg_hi;
	constexpr OpIsX(Register lo, Register hi) : reg_lo(lo), reg_hi(hi) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpIw - 16-bit immediate
struct OpIw : Op {
	constexpr OpIw() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpJ - Relative branch (jcc, jmp, call)
struct OpJ : Op {
	OpKind op_kind;
	uint32_t imm_size;
	constexpr OpJ(OpKind kind, uint32_t size) : op_kind(kind), imm_size(size) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpJdisp - Direct displacement branch
struct OpJdisp : Op {
	uint32_t displ_size;
	constexpr explicit OpJdisp(uint32_t size) : displ_size(size) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpJx - Relative branch with variable size
struct OpJx : Op {
	uint32_t imm_size;
	constexpr explicit OpJx(uint32_t size) : imm_size(size) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpModRM_reg - ModR/M reg field register
struct OpModRM_reg : Op {
	Register reg_lo;
	Register reg_hi;
	constexpr OpModRM_reg(Register lo, Register hi) : reg_lo(lo), reg_hi(hi) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpModRM_reg_mem - ModR/M reg field that encodes memory
struct OpModRM_reg_mem : Op {
	Register reg_lo;
	Register reg_hi;
	constexpr OpModRM_reg_mem(Register lo, Register hi) : reg_lo(lo), reg_hi(hi) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpModRM_regF0 - ModR/M reg with possible F0 prefix for high CR regs
struct OpModRM_regF0 : Op {
	Register reg_lo;
	Register reg_hi;
	constexpr OpModRM_regF0(Register lo, Register hi) : reg_lo(lo), reg_hi(hi) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpModRM_rm - ModR/M r/m field (register or memory)
struct OpModRM_rm : Op {
	Register reg_lo;
	Register reg_hi;
	constexpr OpModRM_rm(Register lo, Register hi) : reg_lo(lo), reg_hi(hi) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpModRM_rm_mem_only - ModR/M r/m field (memory only)
struct OpModRM_rm_mem_only : Op {
	bool must_use_sib;
	constexpr explicit OpModRM_rm_mem_only(bool sib) : must_use_sib(sib) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpModRM_rm_reg_only - ModR/M r/m field (register only)
struct OpModRM_rm_reg_only : Op {
	Register reg_lo;
	Register reg_hi;
	constexpr OpModRM_rm_reg_only(Register lo, Register hi) : reg_lo(lo), reg_hi(hi) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpMRBX - Memory [rBX + AL] for XLAT
struct OpMRBX : Op {
	constexpr OpMRBX() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpO - Offset-only memory operand (moffs)
struct OpO : Op {
	constexpr OpO() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OprDI - Memory [rDI] for string instructions
struct OprDI : Op {
	constexpr OprDI() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpReg - Fixed register operand
struct OpReg : Op {
	Register register_;
	constexpr explicit OpReg(Register reg) : register_(reg) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpRegEmbed8 - Register embedded in low 3 bits of opcode
struct OpRegEmbed8 : Op {
	Register reg_lo;
	Register reg_hi;
	constexpr OpRegEmbed8(Register lo, Register hi) : reg_lo(lo), reg_hi(hi) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpRegSTi - FPU ST(i) register
struct OpRegSTi : Op {
	constexpr OpRegSTi() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpVsib - VSIB memory operand for gather/scatter
struct OpVsib : Op {
	Register vsib_index_reg_lo;
	Register vsib_index_reg_hi;
	constexpr OpVsib(Register lo, Register hi) : vsib_index_reg_lo(lo), vsib_index_reg_hi(hi) {}
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpX - Memory [rSI] for string instructions
struct OpX : Op {
	constexpr OpX() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

/// @brief OpY - Memory [rDI] for string instructions
struct OpY : Op {
	constexpr OpY() = default;
	void encode(Encoder& encoder, const Instruction& instruction, uint32_t operand) const override;
};

} // namespace iced_x86::internal

#endif // ICED_X86_ENCODER_OPS_HPP
