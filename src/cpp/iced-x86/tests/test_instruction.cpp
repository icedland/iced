// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#include <catch2/catch_test_macros.hpp>
#include "iced_x86/iced_x86.hpp"

using namespace iced_x86;

TEST_CASE( "Instruction: default construction", "[instruction]" ) {
	Instruction instr;

	CHECK( instr.code() == Code::INVALID );
	CHECK( instr.is_invalid() );
	CHECK( instr.length() == 0 );
}

TEST_CASE( "Instruction: set code", "[instruction]" ) {
	Instruction instr;
	instr.set_code( Code::NOPD );

	CHECK( instr.code() == Code::NOPD );
	CHECK( !instr.is_invalid() );
}

TEST_CASE( "Instruction: IP accessors", "[instruction]" ) {
	Instruction instr;
	instr.set_length( 2 );
	instr.set_next_ip( 0x1002 );

	CHECK( instr.ip() == 0x1000 );
	CHECK( instr.next_ip() == 0x1002 );
	CHECK( instr.length() == 2 );
}

TEST_CASE( "Instruction: memory accessors", "[instruction]" ) {
	Instruction instr;

	instr.set_memory_base( Register::RAX );
	instr.set_memory_index( Register::RBX );
	instr.set_memory_index_scale( 4 );
	instr.set_memory_displacement64( 0x1234 );

	CHECK( instr.memory_base() == Register::RAX );
	CHECK( instr.memory_index() == Register::RBX );
	CHECK( instr.memory_index_scale() == 4 );
	CHECK( instr.memory_displacement64() == 0x1234 );
}

TEST_CASE( "Instruction: immediate accessors", "[instruction]" ) {
	Instruction instr;

	instr.set_immediate32( 0xDEADBEEF );
	CHECK( instr.immediate32() == 0xDEADBEEF );

	instr.set_immediate8( 0x42 );
	CHECK( instr.immediate8() == 0x42 );
}

TEST_CASE( "Instruction: prefix flags", "[instruction]" ) {
	Instruction instr;

	CHECK( !instr.has_lock_prefix() );
	instr.set_has_lock_prefix( true );
	CHECK( instr.has_lock_prefix() );

	CHECK( !instr.has_rep_prefix() );
	instr.set_has_rep_prefix( true );
	CHECK( instr.has_rep_prefix() );
}

TEST_CASE( "Instruction: struct size", "[instruction]" ) {
	// Verify struct matches Rust layout
	CHECK( sizeof( Instruction ) == 40 );
}
