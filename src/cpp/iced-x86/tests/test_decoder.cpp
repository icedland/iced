// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#include <catch2/catch_test_macros.hpp>
#include "iced_x86/iced_x86.hpp"

using namespace iced_x86;

TEST_CASE( "Decoder: basic construction", "[decoder]" ) {
	const uint8_t data[] = { 0x90 }; // NOP
	Decoder decoder( 64, data );

	CHECK( decoder.bitness() == 64 );
	CHECK( decoder.position() == 0 );
	CHECK( decoder.ip() == 0 );
	CHECK( decoder.can_decode() );
}

TEST_CASE( "Decoder: 32-bit mode", "[decoder]" ) {
	const uint8_t data[] = { 0x90 };
	Decoder decoder( 32, data, 0x10000 );

	CHECK( decoder.bitness() == 32 );
	CHECK( decoder.ip() == 0x10000 );
}

TEST_CASE( "Decoder: 16-bit mode", "[decoder]" ) {
	const uint8_t data[] = { 0x90 };
	Decoder decoder( 16, data );

	CHECK( decoder.bitness() == 16 );
}

TEST_CASE( "Decoder: decode returns instruction", "[decoder]" ) {
	const uint8_t data[] = { 0x90 };
	Decoder decoder( 64, data );

	auto result = decoder.decode();
	// Note: actual decoding not yet implemented
	// Just verify the API works
	CHECK( decoder.position() == 1 );
}

TEST_CASE( "Decoder: empty input", "[decoder]" ) {
	std::span< const uint8_t > empty_data;
	Decoder decoder( 64, empty_data );

	CHECK( !decoder.can_decode() );
	CHECK( decoder.position() == 0 );
	CHECK( decoder.max_position() == 0 );
}

TEST_CASE( "Decoder: position management", "[decoder]" ) {
	const uint8_t data[] = { 0x90, 0x90, 0x90 };
	Decoder decoder( 64, data, 0x1000 );

	CHECK( decoder.position() == 0 );
	CHECK( decoder.ip() == 0x1000 );

	decoder.set_position( 2 );
	CHECK( decoder.position() == 2 );
	CHECK( decoder.ip() == 0x1002 );
}
