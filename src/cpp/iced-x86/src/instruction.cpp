// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#include "iced_x86/instruction.hpp"
#include "iced_x86/internal/tables.hpp"
#include "iced_x86/internal/mvex_instr_flags.hpp"
#include "iced_x86/iced_constants.hpp"

namespace iced_x86 {

Mnemonic Instruction::mnemonic() const noexcept {
	return internal::g_code_to_mnemonic[static_cast< std::size_t >( code_ )];
}

uint32_t Instruction::op_count() const noexcept {
	return internal::g_instruction_op_counts[static_cast< std::size_t >( code_ )];
}

OpKind Instruction::op_kind( uint32_t operand ) const noexcept {
	if ( operand < 4 ) return op_kinds_[operand];
	if ( operand == 4 ) return OpKind::IMMEDIATE8; // op4 is always IMMEDIATE8
	return OpKind::REGISTER; // Invalid operand, but match default behavior
}

void Instruction::set_op_kind( uint32_t operand, OpKind kind ) noexcept {
	if ( operand < 4 ) op_kinds_[operand] = kind;
	// operand 4: no-op (op4_kind is always IMMEDIATE8)
}

Register Instruction::op_register( uint32_t operand ) const noexcept {
	if ( operand < 4 ) return regs_[operand];
	return Register::NONE; // op4_register is always NONE
}

void Instruction::set_op_register( uint32_t operand, Register reg ) noexcept {
	if ( operand < 4 ) regs_[operand] = reg;
	// operand 4: no-op (op4_register is always NONE)
}

void Instruction::set_memory_index_scale( uint32_t value ) noexcept {
	switch ( value ) {
	case 1: scale_ = 0; break;
	case 2: scale_ = 1; break;
	case 4: scale_ = 2; break;
	case 8: scale_ = 3; break;
	default: scale_ = 0; break;
	}
}

MemorySize Instruction::memory_size() const noexcept {
	return internal::g_instruction_memory_sizes[static_cast< std::size_t >( code_ )];
}

Register Instruction::segment_prefix() const noexcept {
	constexpr uint32_t SEGMENT_PREFIX_SHIFT = 5;
	constexpr uint32_t SEGMENT_PREFIX_MASK = 0x7;
	uint32_t index = ( flags1_ >> SEGMENT_PREFIX_SHIFT ) & SEGMENT_PREFIX_MASK;
	constexpr Register segments[] = { Register::NONE, Register::ES, Register::CS, Register::SS, Register::DS, Register::FS, Register::GS };
	return index < 7 ? segments[index] : Register::NONE;
}

void Instruction::set_segment_prefix( Register value ) noexcept {
	constexpr uint32_t SEGMENT_PREFIX_SHIFT = 5;
	constexpr uint32_t SEGMENT_PREFIX_MASK = 0x7;
	uint32_t index = 0;
	switch ( value ) {
	case Register::ES: index = 1; break;
	case Register::CS: index = 2; break;
	case Register::SS: index = 3; break;
	case Register::DS: index = 4; break;
	case Register::FS: index = 5; break;
	case Register::GS: index = 6; break;
	default: index = 0; break;
	}
	flags1_ = ( flags1_ & ~( SEGMENT_PREFIX_MASK << SEGMENT_PREFIX_SHIFT ) ) | ( index << SEGMENT_PREFIX_SHIFT );
}

Register Instruction::memory_segment() const noexcept {
	Register prefix = segment_prefix();
	if ( prefix != Register::NONE ) return prefix;
	Register base = memory_base();
	if ( base == Register::BP || base == Register::EBP || base == Register::ESP || base == Register::RBP || base == Register::RSP )
	    return Register::SS;
	return Register::DS;
}

RoundingControl Instruction::rounding_control() const noexcept {
	constexpr uint32_t RC_SHIFT = 12;
	constexpr uint32_t RC_MASK = 0x7;
	return static_cast< RoundingControl >( ( flags1_ >> RC_SHIFT ) & RC_MASK );
}

void Instruction::set_rounding_control( RoundingControl value ) noexcept {
	constexpr uint32_t RC_SHIFT = 12;
	constexpr uint32_t RC_MASK = 0x7;
	flags1_ = ( flags1_ & ~( RC_MASK << RC_SHIFT ) ) | ( ( static_cast< uint32_t >( value ) & RC_MASK ) << RC_SHIFT );
}

Register Instruction::op_mask() const noexcept {
	constexpr uint32_t OP_MASK_SHIFT = 15;
	constexpr uint32_t OP_MASK_MASK = 0x7;
	uint32_t index = ( flags1_ >> OP_MASK_SHIFT ) & OP_MASK_MASK;
	if ( index == 0 ) return Register::NONE;
	return static_cast< Register >( static_cast< uint32_t >( Register::K0 ) + index );
}

void Instruction::set_op_mask( Register value ) noexcept {
	constexpr uint32_t OP_MASK_SHIFT = 15;
	constexpr uint32_t OP_MASK_MASK = 0x7;
	uint32_t index = 0;
	if ( value >= Register::K0 && value <= Register::K7 )
	    index = static_cast< uint32_t >( value ) - static_cast< uint32_t >( Register::K0 );
	flags1_ = ( flags1_ & ~( OP_MASK_MASK << OP_MASK_SHIFT ) ) | ( ( index & OP_MASK_MASK ) << OP_MASK_SHIFT );
}

CodeSize Instruction::code_size() const noexcept {
	constexpr uint32_t CODE_SIZE_SHIFT = 18;
	constexpr uint32_t CODE_SIZE_MASK = 0x3;
	return static_cast< CodeSize >( ( flags1_ >> CODE_SIZE_SHIFT ) & CODE_SIZE_MASK );
}

void Instruction::set_code_size( CodeSize value ) noexcept {
	constexpr uint32_t CODE_SIZE_SHIFT = 18;
	constexpr uint32_t CODE_SIZE_MASK = 0x3;
	flags1_ = ( flags1_ & ~( CODE_SIZE_MASK << CODE_SIZE_SHIFT ) ) | ( ( static_cast< uint32_t >( value ) & CODE_SIZE_MASK ) << CODE_SIZE_SHIFT );
}

uint64_t Instruction::near_branch_target() const noexcept {
	OpKind kind = op0_kind();
	// Check if JKZD/JKNZD (MVEX instructions with 2 operands where branch is op1)
	// Only check this for MVEX codes to avoid breaking normal 2-operand instructions
	if ( op_count() == 2 && static_cast<uint32_t>( code_ ) >= static_cast<uint32_t>( Code::MVEX_VPREFETCHNTA_M ) ) {
	    kind = op1_kind();
	}
	switch ( kind ) {
	case OpKind::NEAR_BRANCH16: return near_branch16();
	case OpKind::NEAR_BRANCH32: return near_branch32();
	case OpKind::NEAR_BRANCH64: return near_branch64();
	default: return 0;
	}
}

uint32_t Instruction::declare_data_len() const noexcept {
	constexpr uint32_t DATA_LENGTH_SHIFT = 8;
	constexpr uint32_t DATA_LENGTH_MASK = 0xF;
	return ( ( flags1_ >> DATA_LENGTH_SHIFT ) & DATA_LENGTH_MASK ) + 1;
}

void Instruction::set_declare_data_len( uint32_t value ) noexcept {
	constexpr uint32_t DATA_LENGTH_SHIFT = 8;
	constexpr uint32_t DATA_LENGTH_MASK = 0xF;
	flags1_ = ( flags1_ & ~( DATA_LENGTH_MASK << DATA_LENGTH_SHIFT ) ) | ( ( ( value - 1 ) & DATA_LENGTH_MASK ) << DATA_LENGTH_SHIFT );
}

uint8_t Instruction::get_declare_byte_value( uint32_t index ) const noexcept {
	switch ( index ) {
	case 0: return static_cast< uint8_t >( regs_[0] );
	case 1: return static_cast< uint8_t >( regs_[1] );
	case 2: return static_cast< uint8_t >( regs_[2] );
	case 3: return static_cast< uint8_t >( regs_[3] );
	case 4: return static_cast< uint8_t >( immediate_ );
	case 5: return static_cast< uint8_t >( immediate_ >> 8 );
	case 6: return static_cast< uint8_t >( immediate_ >> 16 );
	case 7: return static_cast< uint8_t >( immediate_ >> 24 );
	case 8: return static_cast< uint8_t >( mem_displ_ );
	case 9: return static_cast< uint8_t >( mem_displ_ >> 8 );
	case 10: return static_cast< uint8_t >( mem_displ_ >> 16 );
	case 11: return static_cast< uint8_t >( mem_displ_ >> 24 );
	case 12: return static_cast< uint8_t >( mem_displ_ >> 32 );
	case 13: return static_cast< uint8_t >( mem_displ_ >> 40 );
	case 14: return static_cast< uint8_t >( mem_displ_ >> 48 );
	case 15: return static_cast< uint8_t >( mem_displ_ >> 56 );
	default: return 0;
	}
}

void Instruction::set_declare_byte_value( uint32_t index, uint8_t value ) noexcept {
	switch ( index ) {
	case 0: regs_[0] = static_cast< Register >( value ); break;
	case 1: regs_[1] = static_cast< Register >( value ); break;
	case 2: regs_[2] = static_cast< Register >( value ); break;
	case 3: regs_[3] = static_cast< Register >( value ); break;
	case 4: immediate_ = ( immediate_ & 0xFFFFFF00U ) | value; break;
	case 5: immediate_ = ( immediate_ & 0xFFFF00FFU ) | ( static_cast< uint32_t >( value ) << 8 ); break;
	case 6: immediate_ = ( immediate_ & 0xFF00FFFFU ) | ( static_cast< uint32_t >( value ) << 16 ); break;
	case 7: immediate_ = ( immediate_ & 0x00FFFFFFU ) | ( static_cast< uint32_t >( value ) << 24 ); break;
	case 8: mem_displ_ = ( mem_displ_ & 0xFFFFFFFFFFFFFF00ULL ) | value; break;
	case 9: mem_displ_ = ( mem_displ_ & 0xFFFFFFFFFFFF00FFULL ) | ( static_cast< uint64_t >( value ) << 8 ); break;
	case 10: mem_displ_ = ( mem_displ_ & 0xFFFFFFFFFF00FFFFULL ) | ( static_cast< uint64_t >( value ) << 16 ); break;
	case 11: mem_displ_ = ( mem_displ_ & 0xFFFFFFFF00FFFFFFULL ) | ( static_cast< uint64_t >( value ) << 24 ); break;
	case 12: mem_displ_ = ( mem_displ_ & 0xFFFFFF00FFFFFFFFULL ) | ( static_cast< uint64_t >( value ) << 32 ); break;
	case 13: mem_displ_ = ( mem_displ_ & 0xFFFF00FFFFFFFFFFULL ) | ( static_cast< uint64_t >( value ) << 40 ); break;
	case 14: mem_displ_ = ( mem_displ_ & 0xFF00FFFFFFFFFFFFULL ) | ( static_cast< uint64_t >( value ) << 48 ); break;
	case 15: mem_displ_ = ( mem_displ_ & 0x00FFFFFFFFFFFFFFULL ) | ( static_cast< uint64_t >( value ) << 56 ); break;
	default: break;
	}
}

uint16_t Instruction::get_declare_word_value( uint32_t index ) const noexcept {
	switch ( index ) {
	case 0: return static_cast< uint16_t >( regs_[0] ) | ( static_cast< uint16_t >( regs_[1] ) << 8 );
	case 1: return static_cast< uint16_t >( regs_[2] ) | ( static_cast< uint16_t >( regs_[3] ) << 8 );
	case 2: return static_cast< uint16_t >( immediate_ );
	case 3: return static_cast< uint16_t >( immediate_ >> 16 );
	case 4: return static_cast< uint16_t >( mem_displ_ );
	case 5: return static_cast< uint16_t >( mem_displ_ >> 16 );
	case 6: return static_cast< uint16_t >( mem_displ_ >> 32 );
	case 7: return static_cast< uint16_t >( mem_displ_ >> 48 );
	default: return 0;
	}
}

void Instruction::set_declare_word_value( uint32_t index, uint16_t value ) noexcept {
	switch ( index ) {
	case 0:
		regs_[0] = static_cast< Register >( value & 0xFF );
		regs_[1] = static_cast< Register >( ( value >> 8 ) & 0xFF );
		break;
	case 1:
		regs_[2] = static_cast< Register >( value & 0xFF );
		regs_[3] = static_cast< Register >( ( value >> 8 ) & 0xFF );
		break;
	case 2: immediate_ = ( immediate_ & 0xFFFF0000U ) | value; break;
	case 3: immediate_ = ( immediate_ & 0x0000FFFFU ) | ( static_cast< uint32_t >( value ) << 16 ); break;
	case 4: mem_displ_ = ( mem_displ_ & 0xFFFFFFFFFFFF0000ULL ) | value; break;
	case 5: mem_displ_ = ( mem_displ_ & 0xFFFFFFFF0000FFFFULL ) | ( static_cast< uint64_t >( value ) << 16 ); break;
	case 6: mem_displ_ = ( mem_displ_ & 0xFFFF0000FFFFFFFFULL ) | ( static_cast< uint64_t >( value ) << 32 ); break;
	case 7: mem_displ_ = ( mem_displ_ & 0x0000FFFFFFFFFFFFULL ) | ( static_cast< uint64_t >( value ) << 48 ); break;
	default: break;
	}
}

uint32_t Instruction::get_declare_dword_value( uint32_t index ) const noexcept {
	switch ( index ) {
	case 0: return static_cast< uint32_t >( regs_[0] ) | ( static_cast< uint32_t >( regs_[1] ) << 8 ) | ( static_cast< uint32_t >( regs_[2] ) << 16 ) | ( static_cast< uint32_t >( regs_[3] ) << 24 );
	case 1: return immediate_;
	case 2: return static_cast< uint32_t >( mem_displ_ );
	case 3: return static_cast< uint32_t >( mem_displ_ >> 32 );
	default: return 0;
	}
}

void Instruction::set_declare_dword_value( uint32_t index, uint32_t value ) noexcept {
	switch ( index ) {
	case 0:
		regs_[0] = static_cast< Register >( value & 0xFF );
		regs_[1] = static_cast< Register >( ( value >> 8 ) & 0xFF );
		regs_[2] = static_cast< Register >( ( value >> 16 ) & 0xFF );
		regs_[3] = static_cast< Register >( ( value >> 24 ) & 0xFF );
		break;
	case 1: immediate_ = value; break;
	case 2: mem_displ_ = ( mem_displ_ & 0xFFFFFFFF00000000ULL ) | value; break;
	case 3: mem_displ_ = ( mem_displ_ & 0x00000000FFFFFFFFULL ) | ( static_cast< uint64_t >( value ) << 32 ); break;
	default: break;
	}
}

uint64_t Instruction::get_declare_qword_value( uint32_t index ) const noexcept {
	switch ( index ) {
	case 0: return static_cast< uint64_t >( regs_[0] ) | ( static_cast< uint64_t >( regs_[1] ) << 8 ) | ( static_cast< uint64_t >( regs_[2] ) << 16 ) | ( static_cast< uint64_t >( regs_[3] ) << 24 ) | ( static_cast< uint64_t >( immediate_ ) << 32 );
	case 1: return mem_displ_;
	default: return 0;
	}
}

void Instruction::set_declare_qword_value( uint32_t index, uint64_t value ) noexcept {
	switch ( index ) {
	case 0:
		regs_[0] = static_cast< Register >( value & 0xFF );
		regs_[1] = static_cast< Register >( ( value >> 8 ) & 0xFF );
		regs_[2] = static_cast< Register >( ( value >> 16 ) & 0xFF );
		regs_[3] = static_cast< Register >( ( value >> 24 ) & 0xFF );
		immediate_ = static_cast< uint32_t >( value >> 32 );
		break;
	case 1: mem_displ_ = value; break;
	default: break;
	}
}

// Helper to check if a code is MVEX
static inline bool is_mvex_code( Code code ) noexcept {
	uint32_t c = static_cast< uint32_t >( code );
	return c >= IcedConstants::MVEX_START && c < IcedConstants::MVEX_START + IcedConstants::MVEX_LENGTH;
}

bool Instruction::is_mvex_eviction_hint() const noexcept {
	return is_mvex_code( code_ ) && ( immediate_ & internal::MvexInstrFlags::EVICTION_HINT ) != 0;
}

void Instruction::set_is_mvex_eviction_hint( bool value ) noexcept {
	if ( value )
		immediate_ |= internal::MvexInstrFlags::EVICTION_HINT;
	else
		immediate_ &= ~internal::MvexInstrFlags::EVICTION_HINT;
}

MvexRegMemConv Instruction::mvex_reg_mem_conv() const noexcept {
	if ( !is_mvex_code( code_ ) )
		return MvexRegMemConv::NONE;
	return static_cast< MvexRegMemConv >( ( immediate_ >> internal::MvexInstrFlags::MVEX_REG_MEM_CONV_SHIFT ) & internal::MvexInstrFlags::MVEX_REG_MEM_CONV_MASK );
}

void Instruction::set_mvex_reg_mem_conv( MvexRegMemConv value ) noexcept {
	immediate_ = ( immediate_ & ~( internal::MvexInstrFlags::MVEX_REG_MEM_CONV_MASK << internal::MvexInstrFlags::MVEX_REG_MEM_CONV_SHIFT ) )
		| ( static_cast< uint32_t >( value ) << internal::MvexInstrFlags::MVEX_REG_MEM_CONV_SHIFT );
}

} // namespace iced_x86
