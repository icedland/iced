/*
Copyright (C) 2018-2019 de4dot@gmail.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

use super::iced_constants::IcedConstants;
#[cfg(feature = "INSTR_INFO")]
use super::info::enums::*;
use super::*;
use std::{fmt, mem, slice, u16, u32, u64};

// GENERATOR-BEGIN: MemoryFlags
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
pub(crate) struct MemoryFlags;
impl MemoryFlags {
	pub(crate) const SCALE_MASK: u32 = 0x0000_0003;
	pub(crate) const DISPL_SIZE_SHIFT: u32 = 0x0000_0002;
	pub(crate) const DISPL_SIZE_MASK: u32 = 0x0000_0007;
	pub(crate) const SEGMENT_PREFIX_SHIFT: u32 = 0x0000_0005;
	pub(crate) const SEGMENT_PREFIX_MASK: u32 = 0x0000_0007;
	pub(crate) const BROADCAST: u32 = 0x0000_8000;
}
// GENERATOR-END: MemoryFlags

// GENERATOR-BEGIN: OpKindFlags
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
pub(crate) struct OpKindFlags;
impl OpKindFlags {
	pub(crate) const OP_KIND_BITS: u32 = 0x0000_0005;
	pub(crate) const OP_KIND_MASK: u32 = 0x0000_001F;
	pub(crate) const OP1_KIND_SHIFT: u32 = 0x0000_0005;
	pub(crate) const OP2_KIND_SHIFT: u32 = 0x0000_000A;
	pub(crate) const OP3_KIND_SHIFT: u32 = 0x0000_000F;
	pub(crate) const DATA_LENGTH_MASK: u32 = 0x0000_000F;
	pub(crate) const DATA_LENGTH_SHIFT: u32 = 0x0000_0014;
	pub(crate) const CODE_SIZE_MASK: u32 = 0x0000_0003;
	pub(crate) const CODE_SIZE_SHIFT: u32 = 0x0000_001E;
	pub(crate) const EQUALS_IGNORE_MASK: u32 = 0xC000_0000;
}
// GENERATOR-END: OpKindFlags

// GENERATOR-BEGIN: CodeFlags
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
pub(crate) struct CodeFlags;
impl CodeFlags {
	pub(crate) const CODE_BITS: u32 = 0x0000_000D;
	pub(crate) const CODE_MASK: u32 = 0x0000_1FFF;
	pub(crate) const ROUNDING_CONTROL_MASK: u32 = 0x0000_0007;
	pub(crate) const ROUNDING_CONTROL_SHIFT: u32 = 0x0000_000D;
	pub(crate) const OP_MASK_MASK: u32 = 0x0000_0007;
	pub(crate) const OP_MASK_SHIFT: u32 = 0x0000_0010;
	pub(crate) const INSTR_LENGTH_MASK: u32 = 0x0000_000F;
	pub(crate) const INSTR_LENGTH_SHIFT: u32 = 0x0000_0013;
	pub(crate) const SUPPRESS_ALL_EXCEPTIONS: u32 = 0x0200_0000;
	pub(crate) const ZEROING_MASKING: u32 = 0x0400_0000;
	pub(crate) const XACQUIRE_PREFIX: u32 = 0x0800_0000;
	pub(crate) const XRELEASE_PREFIX: u32 = 0x1000_0000;
	pub(crate) const REPE_PREFIX: u32 = 0x2000_0000;
	pub(crate) const REPNE_PREFIX: u32 = 0x4000_0000;
	pub(crate) const LOCK_PREFIX: u32 = 0x8000_0000;
	pub(crate) const EQUALS_IGNORE_MASK: u32 = 0x0078_0000;
}
// GENERATOR-END: CodeFlags

/// A 16/32/64-bit x86 instruction
#[derive(Copy, Clone, Default)]
pub struct Instruction {
	pub(crate) next_rip: u64,
	pub(crate) code_flags: u32,    // CodeFlags
	pub(crate) op_kind_flags: u32, // OpKindFlags
	// If it's a 64-bit immediate/offset/target, the high 32 bits is in mem_displ
	pub(crate) immediate: u32,
	// This is the high 32 bits if it's a 64-bit immediate/offset/target
	pub(crate) mem_displ: u32,
	pub(crate) memory_flags: u16, // MemoryFlags
	pub(crate) mem_base_reg: u8,  // Register
	pub(crate) mem_index_reg: u8, // Register
	pub(crate) reg0: u8,          // Register
	pub(crate) reg1: u8,          // Register
	pub(crate) reg2: u8,          // Register
	pub(crate) reg3: u8,          // Register
}

#[cfg_attr(feature = "cargo-clippy", allow(clippy::len_without_is_empty))]
impl Instruction {
	/// Creates an empty `Instruction` (all fields are cleared)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn new() -> Self {
		Instruction::default()
	}

	/// Checks if two instructions are equal, comparing all bits, not ignoring anything. `==` ignores some fields.
	#[cfg_attr(has_must_use, must_use)]
	#[allow(trivial_casts)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn eq_all_bits(&self, other: &Self) -> bool {
		unsafe {
			let a: *const u8 = self as *const Self as *const u8;
			let b: *const u8 = other as *const Self as *const u8;
			let sa = slice::from_raw_parts(a, mem::size_of::<Self>());
			let sb = slice::from_raw_parts(b, mem::size_of::<Self>());
			sa == sb
		}
	}

	/// Gets the 16-bit IP of the instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn ip16(&self) -> u16 {
		(self.next_rip as u16).wrapping_sub(self.len() as u16)
	}

	/// Sets the 16-bit IP of the instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_ip16(&mut self, new_value: u16) {
		self.next_rip = (new_value as u64).wrapping_add(self.len() as u64);
	}

	/// Gets the 32-bit IP of the instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn ip32(&self) -> u32 {
		(self.next_rip as u32).wrapping_sub(self.len())
	}

	/// Sets the 32-bit IP of the instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_ip32(&mut self, new_value: u32) {
		self.next_rip = (new_value as u64).wrapping_add(self.len() as u64);
	}

	/// Gets the 64-bit IP of the instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn ip(&self) -> u64 {
		self.next_rip.wrapping_sub(self.len() as u64)
	}

	/// Sets the 64-bit IP of the instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_ip(&mut self, new_value: u64) {
		self.next_rip = new_value.wrapping_add(self.len() as u64);
	}

	/// Gets the 16-bit IP of the next instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn next_ip16(&self) -> u16 {
		self.next_rip as u16
	}

	/// Sets the 16-bit IP of the next instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_next_ip16(&mut self, new_value: u16) {
		self.next_rip = new_value as u64;
	}

	/// Gets the 32-bit IP of the next instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn next_ip32(&self) -> u32 {
		self.next_rip as u32
	}

	/// Sets the 32-bit IP of the next instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_next_ip32(&mut self, new_value: u32) {
		self.next_rip = new_value as u64;
	}

	/// Gets the 64-bit IP of the next instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn next_ip(&self) -> u64 {
		self.next_rip
	}

	/// Sets the 64-bit IP of the next instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_next_ip(&mut self, new_value: u64) {
		self.next_rip = new_value;
	}

	/// Gets the code size when the instruction was decoded. This value is informational and can
	/// be used by a formatter.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn code_size(&self) -> CodeSize {
		// safe: the bits are only initialized to valid values by iced and
		// we store 2 bits in op_kind_flags, which is exactly the size of CodeSize
		unsafe { mem::transmute(((self.op_kind_flags >> OpKindFlags::CODE_SIZE_SHIFT) & OpKindFlags::CODE_SIZE_MASK) as u8) }
	}

	/// Sets the code size when the instruction was decoded. This value is informational and can
	/// be used by a formatter.
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_code_size(&mut self, new_value: CodeSize) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::CODE_SIZE_MASK << OpKindFlags::CODE_SIZE_SHIFT))
			| (((new_value as u32) & OpKindFlags::CODE_SIZE_MASK) << OpKindFlags::CODE_SIZE_SHIFT);
	}

	/// Gets the instruction code, see also `mnemonic()`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn code(&self) -> Code {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute((self.code_flags & CodeFlags::CODE_MASK) as u16) }
	}

	/// Sets the instruction code
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_code(&mut self, new_value: Code) {
		self.code_flags = (self.code_flags & !CodeFlags::CODE_MASK) | (new_value as u32);
	}

	/// Gets the mnemonic, see also `code()`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn mnemonic(&self) -> Mnemonic {
		self.code().mnemonic()
	}

	/// Gets the operand count. An instruction can have 0-5 operands.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // add [rax],ebx
	/// let bytes = b"\x01\x18";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert_eq!(2, instr.op_count());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op_count(&self) -> u32 {
		unsafe { *instruction_op_counts::OP_COUNT.get_unchecked((self.code_flags & CodeFlags::CODE_MASK) as usize) as u32 }
	}

	/// Gets the length of the instruction, 0-15 bytes. This is just informational. If you modify the instruction
	/// or create a new one, this property could return the wrong value.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn len(&self) -> u32 {
		((self.code_flags >> CodeFlags::INSTR_LENGTH_SHIFT) & CodeFlags::INSTR_LENGTH_MASK)
	}

	/// Sets the length of the instruction, 0-15 bytes. This is just informational. If you modify the instruction
	/// or create a new one, this property could return the wrong value.
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_len(&mut self, new_value: u32) {
		self.code_flags = (self.code_flags & !(CodeFlags::INSTR_LENGTH_MASK << CodeFlags::INSTR_LENGTH_SHIFT))
			| ((new_value & CodeFlags::INSTR_LENGTH_MASK) << CodeFlags::INSTR_LENGTH_SHIFT);
	}

	/// Checks if the instruction has the `XACQUIRE` prefix (`F2`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_xacquire_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::XACQUIRE_PREFIX) != 0
	}

	/// Sets the has `XACQUIRE` prefix (`F2`) flag
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_xacquire_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::XACQUIRE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::XACQUIRE_PREFIX;
		}
	}

	/// Checks if the instruction has the `XRELEASE` prefix (`F3`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_xrelease_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::XRELEASE_PREFIX) != 0
	}

	/// Sets the has `XRELEASE` prefix (`F3`) flag
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_xrelease_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::XRELEASE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::XRELEASE_PREFIX;
		}
	}

	/// Checks if the instruction has the `REPE` or `REP` prefix (`F3`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_rep_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::REPE_PREFIX) != 0
	}

	/// Sets the has `REPE` or `REP` prefix (`F3`) flag
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_rep_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::REPE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::REPE_PREFIX;
		}
	}

	/// Checks if the instruction has the `REPE` or `REP` prefix (`F3`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_repe_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::REPE_PREFIX) != 0
	}

	/// Sets the has `REPE` or `REP` prefix (`F3`) flag
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_repe_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::REPE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::REPE_PREFIX;
		}
	}

	/// Checks if the instruction has the `REPNE` prefix (`F2`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_repne_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::REPNE_PREFIX) != 0
	}

	/// Sets the has `REPNE` prefix (`F2`) flag
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_repne_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::REPNE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::REPNE_PREFIX;
		}
	}

	/// Checks if the instruction has the `LOCK` prefix (`F0`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_lock_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::LOCK_PREFIX) != 0
	}

	/// Sets the has `LOCK` prefix (`F0`) flag
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_lock_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::LOCK_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::LOCK_PREFIX;
		}
	}

	/// Gets operand #0's kind if the operand exists (see `op_count()` and `op_kind()`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op0_kind(&self) -> OpKind {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute((self.op_kind_flags & OpKindFlags::OP_KIND_MASK) as u8) }
	}

	/// Sets operand #0's kind if the operand exists (see `op_count()` and `set_op_kind()`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_op0_kind(&mut self, new_value: OpKind) {
		self.op_kind_flags = (self.op_kind_flags & !OpKindFlags::OP_KIND_MASK) | ((new_value as u32) & OpKindFlags::OP_KIND_MASK);
	}

	/// Gets operand #1's kind if the operand exists (see `op_count()` and `op_kind()`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op1_kind(&self) -> OpKind {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(((self.op_kind_flags >> OpKindFlags::OP1_KIND_SHIFT) & OpKindFlags::OP_KIND_MASK) as u8) }
	}

	/// Sets operand #1's kind if the operand exists (see `op_count()` and `set_op_kind()`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_op1_kind(&mut self, new_value: OpKind) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::OP_KIND_MASK << OpKindFlags::OP1_KIND_SHIFT))
			| (((new_value as u32) & OpKindFlags::OP_KIND_MASK) << OpKindFlags::OP1_KIND_SHIFT);
	}

	/// Gets operand #2's kind if the operand exists (see `op_count()` and `op_kind()`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op2_kind(&self) -> OpKind {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(((self.op_kind_flags >> OpKindFlags::OP2_KIND_SHIFT) & OpKindFlags::OP_KIND_MASK) as u8) }
	}

	/// Sets operand #2's kind if the operand exists (see `op_count()` and `set_op_kind()`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_op2_kind(&mut self, new_value: OpKind) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::OP_KIND_MASK << OpKindFlags::OP2_KIND_SHIFT))
			| (((new_value as u32) & OpKindFlags::OP_KIND_MASK) << OpKindFlags::OP2_KIND_SHIFT);
	}

	/// Gets operand #3's kind if the operand exists (see `op_count()` and `op_kind()`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op3_kind(&self) -> OpKind {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(((self.op_kind_flags >> OpKindFlags::OP3_KIND_SHIFT) & OpKindFlags::OP_KIND_MASK) as u8) }
	}

	/// Sets operand #3's kind if the operand exists (see `op_count()` and `set_op_kind()`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_op3_kind(&mut self, new_value: OpKind) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::OP_KIND_MASK << OpKindFlags::OP3_KIND_SHIFT))
			| (((new_value as u32) & OpKindFlags::OP_KIND_MASK) << OpKindFlags::OP3_KIND_SHIFT);
	}

	/// Gets operand #4's kind if the operand exists (see `op_count()` and `op_kind()`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op4_kind(&self) -> OpKind {
		OpKind::Immediate8
	}

	/// Sets operand #4's kind if the operand exists (see `op_count()` and `set_op_kind()`)
	///
	/// # Panics
	///
	/// Panics if `new_value` is invalid.
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_op4_kind(&mut self, new_value: OpKind) {
		if new_value != OpKind::Immediate8 {
			panic!();
		}
	}

	/// Gets an operand's kind if it exists (see `op_count()`)
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // add [rax],ebx
	/// let bytes = b"\x01\x18";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert_eq!(2, instr.op_count());
	/// assert_eq!(OpKind::Memory, instr.op_kind(0));
	/// assert_eq!(OpKind::Register, instr.op_kind(1));
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn op_kind(&self, operand: u32) -> OpKind {
		match operand {
			0 => self.op0_kind(),
			1 => self.op1_kind(),
			2 => self.op2_kind(),
			3 => self.op3_kind(),
			4 => self.op4_kind(),
			_ => panic!(),
		}
	}

	/// Sets an operand's kind
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `op_kind`: Operand kind
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_op_kind(&mut self, operand: u32, op_kind: OpKind) {
		match operand {
			0 => self.set_op0_kind(op_kind),
			1 => self.set_op1_kind(op_kind),
			2 => self.set_op2_kind(op_kind),
			3 => self.set_op3_kind(op_kind),
			4 => self.set_op4_kind(op_kind),
			_ => panic!(),
		}
	}

	/// Checks if the instruction has a segment override prefix, see `segment_prefix()`
	#[inline]
	pub fn has_segment_prefix(&self) -> bool {
		(((self.memory_flags as u32) >> MemoryFlags::SEGMENT_PREFIX_SHIFT) & MemoryFlags::SEGMENT_PREFIX_MASK).wrapping_sub(1) < 6
	}

	/// Gets the segment override prefix or `Register::None` if none. See also `memory_segment()`.
	/// Use this property if the operand has kind `OpKind::Memory`, `OpKind::Memory64`,
	/// `OpKind::MemorySegSI`, `OpKind::MemorySegESI`, `OpKind::MemorySegRSI`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn segment_prefix(&self) -> Register {
		let index = (((self.memory_flags as u32) >> MemoryFlags::SEGMENT_PREFIX_SHIFT) & MemoryFlags::SEGMENT_PREFIX_MASK).wrapping_sub(1);
		if index < 6 {
			// safe: it's guaranteed to only return one of ES,CS,SS,DS,FS,GS
			unsafe { mem::transmute((Register::ES as u32 + index) as u8) }
		} else {
			Register::None
		}
	}

	/// Sets the segment override prefix or `Register::None` if none. See also `memory_segment()`.
	/// Use this property if the operand has kind `OpKind::Memory`, `OpKind::Memory64`,
	/// `OpKind::MemorySegSI`, `OpKind::MemorySegESI`, `OpKind::MemorySegRSI`
	///
	/// # Arguments
	///
	/// * `new_value`: Segment register prefix
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_segment_prefix(&mut self, new_value: Register) {
		let enc_value = if new_value == Register::None {
			0
		} else {
			(((new_value as u32) - (Register::ES as u32)) + 1) & MemoryFlags::SEGMENT_PREFIX_MASK
		};
		self.memory_flags = (((self.memory_flags as u32) & !(MemoryFlags::SEGMENT_PREFIX_MASK << MemoryFlags::SEGMENT_PREFIX_SHIFT))
			| (enc_value << MemoryFlags::SEGMENT_PREFIX_SHIFT)) as u16;
	}

	/// Gets the effective segment register used to reference the memory location.
	/// Use this property if the operand has kind `OpKind::Memory`, `OpKind::Memory64`,
	/// `OpKind::MemorySegSI`, `OpKind::MemorySegESI`, `OpKind::MemorySegRSI`
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn memory_segment(&self) -> Register {
		let seg_reg = self.segment_prefix();
		if seg_reg != Register::None {
			return seg_reg;
		}
		match self.memory_base() {
			Register::BP | Register::EBP | Register::ESP | Register::RBP | Register::RSP => Register::SS,
			_ => Register::DS,
		}
	}

	/// Gets the size of the memory displacement in bytes. Valid values are 0, 1 (16/32/64-bit), 2 (16-bit), 4 (32-bit), 8 (64-bit).
	/// Note that the return value can be 1 and `memory_displacement()` may still not fit in
	/// a signed byte if it's an EVEX encoded instruction.
	/// Use this property if the operand has kind `OpKind::Memory`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_displ_size(&self) -> u32 {
		let size = ((self.memory_flags as u32) >> MemoryFlags::DISPL_SIZE_SHIFT) & MemoryFlags::DISPL_SIZE_MASK;
		if size <= 2 {
			size
		} else if size == 3 {
			4
		} else {
			8
		}
	}

	/// Sets the size of the memory displacement in bytes. Valid values are 0, 1 (16/32/64-bit), 2 (16-bit), 4 (32-bit), 8 (64-bit).
	/// Note that the return value can be 1 and `memory_displacement()` may still not fit in
	/// a signed byte if it's an EVEX encoded instruction.
	/// Use this property if the operand has kind `OpKind::Memory`
	///
	/// # Arguments
	///
	/// * `new_value`: Displacement size
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_memory_displ_size(&mut self, new_value: u32) {
		let enc_value = match new_value {
			0 => 0,
			1 => 1,
			2 => 2,
			4 => 3,
			_ => 4,
		};
		self.memory_flags = (((self.memory_flags as u32) & !(MemoryFlags::DISPL_SIZE_MASK << MemoryFlags::DISPL_SIZE_SHIFT))
			| (enc_value << MemoryFlags::DISPL_SIZE_SHIFT)) as u16;
	}

	/// `true` if the data is broadcasted (EVEX instructions only)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_broadcast(&self) -> bool {
		(self.memory_flags & (MemoryFlags::BROADCAST as u16)) != 0
	}

	/// Sets the is broadcast flag (EVEX instructions only)
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_is_broadcast(&mut self, new_value: bool) {
		if new_value {
			self.memory_flags |= MemoryFlags::BROADCAST as u16;
		} else {
			self.memory_flags &= !(MemoryFlags::BROADCAST as u16);
		}
	}

	/// Gets the size of the memory location that is referenced by the operand. See also `is_broadcast()`).
	/// Use this property if the operand has kind `OpKind::Memory`, `OpKind::Memory64`,
	/// `OpKind::MemorySegSI`, `OpKind::MemorySegESI`, `OpKind::MemorySegRSI`,
	/// `OpKind::MemoryESDI`, `OpKind::MemoryESEDI`, `OpKind::MemoryESRDI`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_size(&self) -> MemorySize {
		let mut index = self.code() as usize;
		if self.is_broadcast() {
			index += IcedConstants::NUMBER_OF_CODE_VALUES as usize;
		}
		unsafe { mem::transmute(*instruction_memory_sizes::SIZES.get_unchecked(index)) }
	}

	/// Gets the index register scale value, valid values are *1, *2, *4, *8. Use this property if the operand has kind `OpKind::Memory`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_index_scale(&self) -> u32 {
		1 << (self.memory_flags as u32 & MemoryFlags::SCALE_MASK)
	}

	/// Sets the index register scale value, valid values are *1, *2, *4, *8. Use this property if the operand has kind `OpKind::Memory`
	///
	/// # Arguments
	///
	/// * `new_value`: New value (1, 2, 4 or 8)
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_memory_index_scale(&mut self, new_value: u32) {
		match new_value {
			1 => self.memory_flags &= !3,
			2 => self.memory_flags = (self.memory_flags & !(MemoryFlags::SCALE_MASK as u16)) | 1,
			4 => self.memory_flags = (self.memory_flags & !(MemoryFlags::SCALE_MASK as u16)) | 2,
			_ => {
				debug_assert_eq!(8, new_value);
				self.memory_flags |= 3;
			}
		}
	}

	/// Gets the memory operand's displacement. This should be sign extended to 64 bits if it's 64-bit addressing (see `memory_displacement64()`).
	/// Use this property if the operand has kind `OpKind::Memory`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_displacement(&self) -> u32 {
		self.mem_displ
	}

	/// Sets the memory operand's displacement. This should be sign extended to 64 bits if it's 64-bit addressing.
	/// Use this property if the operand has kind `OpKind::Memory`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_memory_displacement(&mut self, new_value: u32) {
		self.mem_displ = new_value;
	}

	/// Gets the memory operand's displacement sign extended to 64 bits.
	/// Use this property if the operand has kind `OpKind::Memory`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_displacement64(&self) -> u64 {
		self.mem_displ as i32 as u64
	}

	/// Gets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or if it's not an immediate operand
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn immediate(&self, operand: u32) -> u64 {
		match self.op_kind(operand) {
			OpKind::Immediate8 => self.immediate8() as u64,
			OpKind::Immediate8_2nd => self.immediate8_2nd() as u64,
			OpKind::Immediate16 => self.immediate16() as u64,
			OpKind::Immediate32 => self.immediate32() as u64,
			OpKind::Immediate64 => self.immediate64(),
			OpKind::Immediate8to16 => self.immediate8to16() as u64,
			OpKind::Immediate8to32 => self.immediate8to32() as u64,
			OpKind::Immediate8to64 => self.immediate8to64() as u64,
			OpKind::Immediate32to64 => self.immediate32to64() as u64,
			_ => panic!(),
		}
	}

	/// Sets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or if it's not an immediate operand
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: Immediate
	#[inline]
	pub fn set_immediate_i32(&mut self, operand: u32, new_value: i32) {
		self.set_immediate_u64(operand, new_value as u64);
	}

	/// Sets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or if it's not an immediate operand
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: Immediate
	#[inline]
	pub fn set_immediate_u32(&mut self, operand: u32, new_value: u32) {
		self.set_immediate_u64(operand, new_value as u64);
	}

	/// Sets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or if it's not an immediate operand
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: Immediate
	#[inline]
	pub fn set_immediate_i64(&mut self, operand: u32, new_value: i64) {
		self.set_immediate_u64(operand, new_value as u64);
	}

	/// Sets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or if it's not an immediate operand
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: Immediate
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_immediate_u64(&mut self, operand: u32, new_value: u64) {
		match self.op_kind(operand) {
			OpKind::Immediate8 | OpKind::Immediate8to16 | OpKind::Immediate8to32 | OpKind::Immediate8to64 => self.immediate = new_value as u8 as u32,
			OpKind::Immediate8_2nd => self.mem_displ = new_value as u8 as u32,
			OpKind::Immediate16 => self.immediate = new_value as u16 as u32,
			OpKind::Immediate32to64 | OpKind::Immediate32 => self.immediate = new_value as u32,
			OpKind::Immediate64 => self.set_immediate64(new_value),
			_ => panic!(),
		}
	}

	/// Gets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8(&self) -> u8 {
		self.immediate as u8
	}

	/// Sets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8(&mut self, new_value: u8) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8_2nd`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8_2nd(&self) -> u8 {
		self.mem_displ as u8
	}

	/// Sets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8_2nd`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8_2nd(&mut self, new_value: u8) {
		self.mem_displ = new_value as u32;
	}

	/// Gets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate16`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate16(&self) -> u16 {
		self.immediate as u16
	}

	/// Sets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate16`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate16(&mut self, new_value: u16) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate32`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate32(&self) -> u32 {
		self.immediate
	}

	/// Sets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate32`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate32(&mut self, new_value: u32) {
		self.immediate = new_value;
	}

	/// Gets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate64`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate64(&self) -> u64 {
		((self.mem_displ as u64) << 32) | (self.immediate as u64)
	}

	/// Sets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate64`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate64(&mut self, new_value: u64) {
		self.immediate = new_value as u32;
		self.mem_displ = (new_value >> 32) as u32;
	}

	/// Gets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8to16`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8to16(&self) -> i16 {
		self.immediate as i8 as i16
	}

	/// Sets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8to16`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8to16(&mut self, new_value: i16) {
		self.immediate = new_value as i8 as u32;
	}

	/// Gets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8to32`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8to32(&self) -> i32 {
		self.immediate as i8 as i32
	}

	/// Sets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8to32`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8to32(&mut self, new_value: i32) {
		self.immediate = new_value as i8 as u32;
	}

	/// Gets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8to64`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8to64(&self) -> i64 {
		self.immediate as i8 as i64
	}

	/// Sets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate8to64`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8to64(&mut self, new_value: i64) {
		self.immediate = new_value as i8 as u32;
	}

	/// Gets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate32to64`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate32to64(&self) -> i64 {
		self.immediate as i32 as i64
	}

	/// Sets the operand's immediate value. Use this property if the operand has kind `OpKind::Immediate32to64`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate32to64(&mut self, new_value: i64) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's 64-bit address value. Use this property if the operand has kind `OpKind::Memory64`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_address64(&self) -> u64 {
		((self.mem_displ as u64) << 32) | self.immediate as u64
	}

	/// Sets the operand's 64-bit address value. Use this property if the operand has kind `OpKind::Memory64`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_memory_address64(&mut self, new_value: u64) {
		self.immediate = new_value as u32;
		self.mem_displ = (new_value >> 32) as u32;
	}

	/// Gets the operand's branch target. Use this property if the operand has kind `OpKind::NearBranch16`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn near_branch16(&self) -> u16 {
		self.immediate as u16
	}

	/// Sets the operand's branch target. Use this property if the operand has kind `OpKind::NearBranch16`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_near_branch16(&mut self, new_value: u16) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's branch target. Use this property if the operand has kind `OpKind::NearBranch32`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn near_branch32(&self) -> u32 {
		self.immediate
	}

	/// Sets the operand's branch target. Use this property if the operand has kind `OpKind::NearBranch32`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_near_branch32(&mut self, new_value: u32) {
		self.immediate = new_value;
	}

	/// Gets the operand's branch target. Use this property if the operand has kind `OpKind::NearBranch64`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn near_branch64(&self) -> u64 {
		((self.mem_displ as u64) << 32) | self.immediate as u64
	}

	/// Sets the operand's branch target. Use this property if the operand has kind `OpKind::NearBranch64`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_near_branch64(&mut self, new_value: u64) {
		self.immediate = new_value as u32;
		self.mem_displ = (new_value >> 32) as u32;
	}

	/// Gets the near branch target if it's a call/jmp near branch instruction
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn near_branch_target(&self) -> u64 {
		match self.op0_kind() {
			OpKind::NearBranch16 => self.near_branch16() as u64,
			OpKind::NearBranch32 => self.near_branch32() as u64,
			OpKind::NearBranch64 => self.near_branch64(),
			_ => 0,
		}
	}

	/// Gets the operand's branch target. Use this property if the operand has kind `OpKind::FarBranch16`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn far_branch16(&self) -> u16 {
		self.immediate as u16
	}

	/// Sets the operand's branch target. Use this property if the operand has kind `OpKind::FarBranch16`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_far_branch16(&mut self, new_value: u16) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's branch target. Use this property if the operand has kind `OpKind::FarBranch32`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn far_branch32(&self) -> u32 {
		self.immediate
	}

	/// Sets the operand's branch target. Use this property if the operand has kind `OpKind::FarBranch32`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_far_branch32(&mut self, new_value: u32) {
		self.immediate = new_value;
	}

	/// Gets the operand's branch target selector. Use this property if the operand has kind `OpKind::FarBranch16` or `OpKind::FarBranch32`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn far_branch_selector(&self) -> u16 {
		self.mem_displ as u16
	}

	/// Sets the operand's branch target selector. Use this property if the operand has kind `OpKind::FarBranch16` or `OpKind::FarBranch32`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_far_branch_selector(&mut self, new_value: u16) {
		self.mem_displ = new_value as u32;
	}

	/// Gets the memory operand's base register or `Register::None` if none. Use this property if the operand has kind `OpKind::Memory`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_base(&self) -> Register {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(self.mem_base_reg) }
	}

	/// Sets the memory operand's base register or `Register::None` if none. Use this property if the operand has kind `OpKind::Memory`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_memory_base(&mut self, new_value: Register) {
		self.mem_base_reg = new_value as u8;
	}

	/// Gets the memory operand's index register or `Register::None` if none. Use this property if the operand has kind `OpKind::Memory`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_index(&self) -> Register {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(self.mem_index_reg) }
	}

	/// Sets the memory operand's index register or `Register::None` if none. Use this property if the operand has kind `OpKind::Memory`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_memory_index(&mut self, new_value: Register) {
		self.mem_index_reg = new_value as u8;
	}

	/// Gets operand #0's register value. Use this property if operand #0 (`op0_kind()`) has kind `OpKind::Register`, see `op_count()` and `op_register()`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op0_register(&self) -> Register {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(self.reg0) }
	}

	/// Sets operand #0's register value. Use this property if operand #0 (`op0_kind()`) has kind `OpKind::Register`, see `op_count()` and `set_op_register()`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_op0_register(&mut self, new_value: Register) {
		self.reg0 = new_value as u8;
	}

	/// Gets operand #1's register value. Use this property if operand #1 (`op1_kind()`) has kind `OpKind::Register`, see `op_count()` and `op_register()`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op1_register(&self) -> Register {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(self.reg1) }
	}

	/// Sets operand #1's register value. Use this property if operand #1 (`op1_kind()`) has kind `OpKind::Register`, see `op_count()` and `set_op_register()`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_op1_register(&mut self, new_value: Register) {
		self.reg1 = new_value as u8;
	}

	/// Gets operand #2's register value. Use this property if operand #2 (`op2_kind()`) has kind `OpKind::Register`, see `op_count()` and `op_register()`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op2_register(&self) -> Register {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(self.reg2) }
	}

	/// Sets operand #2's register value. Use this property if operand #2 (`op2_kind()`) has kind `OpKind::Register`, see `op_count()` and `set_op_register()`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_op2_register(&mut self, new_value: Register) {
		self.reg2 = new_value as u8;
	}

	/// Gets operand #3's register value. Use this property if operand #3 (`op3_kind()`) has kind `OpKind::Register`, see `op_count()` and `op_register()`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op3_register(&self) -> Register {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(self.reg3) }
	}

	/// Sets operand #3's register value. Use this property if operand #3 (`op3_kind()`) has kind `OpKind::Register`, see `op_count()` and `set_op_register()`
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_op3_register(&mut self, new_value: Register) {
		self.reg3 = new_value as u8;
	}

	/// Gets operand #4's register value. Use this property if operand #4 (`op4_kind()`) has kind `OpKind::Register`, see `op_count()` and `op_register()`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op4_register(&self) -> Register {
		Register::None
	}

	/// Sets operand #4's register value. Use this property if operand #4 (`op4_kind()`) has kind `OpKind::Register`, see `op_count()` and `set_op_register()`
	///
	/// # Panics
	///
	/// Panics if `new_value` is invalid
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_op4_register(&mut self, new_value: Register) {
		if new_value != Register::None {
			panic!();
		}
	}

	/// Gets the operand's register value. Use this property if the operand has kind `OpKind::Register`
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // add [rax],ebx
	/// let bytes = b"\x01\x18";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert_eq!(2, instr.op_count());
	/// assert_eq!(OpKind::Memory, instr.op_kind(0));
	/// assert_eq!(OpKind::Register, instr.op_kind(1));
	/// assert_eq!(Register::EBX, instr.op_register(1));
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn op_register(&self, operand: u32) -> Register {
		match operand {
			0 => self.op0_register(),
			1 => self.op1_register(),
			2 => self.op2_register(),
			3 => self.op3_register(),
			4 => self.op4_register(),
			_ => panic!(),
		}
	}

	/// Sets the operand's register value. Use this property if the operand has kind `OpKind::Register`
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_op_register(&mut self, operand: u32, new_value: Register) {
		match operand {
			0 => self.set_op0_register(new_value),
			1 => self.set_op1_register(new_value),
			2 => self.set_op2_register(new_value),
			3 => self.set_op3_register(new_value),
			4 => self.set_op4_register(new_value),
			_ => panic!(),
		}
	}

	/// Gets the op mask register (`Register::K1` - `Register::K7`) or `Register::None` if none
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op_mask(&self) -> Register {
		let r = (self.code_flags >> CodeFlags::OP_MASK_SHIFT) & CodeFlags::OP_MASK_MASK;
		if r == 0 {
			Register::None
		} else {
			// safe, it's guaranteed to return K1-K7 since we only store 3 register bits (r == 1..7)
			unsafe { mem::transmute((r + Register::K0 as u32) as u8) }
		}
	}

	/// Sets the op mask register (`Register::K1` - `Register::K7`) or `Register::None` if none
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_op_mask(&mut self, new_value: Register) {
		let r = if new_value == Register::None {
			0
		} else {
			(new_value as u32 - Register::K0 as u32) & CodeFlags::OP_MASK_MASK
		};
		self.code_flags = (self.code_flags & !(CodeFlags::OP_MASK_MASK << CodeFlags::OP_MASK_SHIFT)) | (r << CodeFlags::OP_MASK_SHIFT);
	}

	/// Checks if there's an op mask register (`op_mask()`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_op_mask(&self) -> bool {
		(self.code_flags & (CodeFlags::OP_MASK_MASK << CodeFlags::OP_MASK_SHIFT)) != 0
	}

	/// `true` if zeroing-masking, `false` if merging-masking.
	/// Only used by most EVEX encoded instructions that use op mask registers.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn zeroing_masking(&self) -> bool {
		(self.code_flags & CodeFlags::ZEROING_MASKING) != 0
	}

	/// `true` if zeroing-masking, `false` if merging-masking.
	/// Only used by most EVEX encoded instructions that use op mask registers.
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_zeroing_masking(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::ZEROING_MASKING;
		} else {
			self.code_flags &= !CodeFlags::ZEROING_MASKING;
		}
	}

	/// `true` if merging-masking, `false` if zeroing-masking.
	/// Only used by most EVEX encoded instructions that use op mask registers.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn merging_masking(&self) -> bool {
		(self.code_flags & CodeFlags::ZEROING_MASKING) == 0
	}

	/// `true` if merging-masking, `false` if zeroing-masking.
	/// Only used by most EVEX encoded instructions that use op mask registers.
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_merging_masking(&mut self, new_value: bool) {
		if new_value {
			self.code_flags &= !CodeFlags::ZEROING_MASKING;
		} else {
			self.code_flags |= CodeFlags::ZEROING_MASKING;
		}
	}

	/// Gets the rounding control (`suppress_all_exceptions()` is implied but still returns `false`)
	/// or `RoundingControl::None` if the instruction doesn't use it.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rounding_control(&self) -> RoundingControl {
		// safe: iced only initializes the bits to valid values. The user can write garbage if he/she uses unsafe code though.
		unsafe { mem::transmute(((self.code_flags >> CodeFlags::ROUNDING_CONTROL_SHIFT) & CodeFlags::ROUNDING_CONTROL_MASK) as u8) }
	}

	/// Sets the rounding control (`suppress_all_exceptions()` is implied but still returns `false`)
	/// or `RoundingControl::None` if the instruction doesn't use it.
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_rounding_control(&mut self, new_value: RoundingControl) {
		self.code_flags = (self.code_flags & !(CodeFlags::ROUNDING_CONTROL_MASK << CodeFlags::ROUNDING_CONTROL_SHIFT))
			| ((new_value as u32 & CodeFlags::ROUNDING_CONTROL_MASK) << CodeFlags::ROUNDING_CONTROL_SHIFT);
	}

	/// Gets the number of elements in a `db`/`dw`/`dd`/`dq` directive.
	/// Can only be called if `code()` is `Code::DeclareByte`, `Code::DeclareWord`, `Code::DeclareDword`, `Code::DeclareQword`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn declare_data_len(&self) -> u32 {
		((self.op_kind_flags >> OpKindFlags::DATA_LENGTH_SHIFT) & OpKindFlags::DATA_LENGTH_MASK) + 1
	}

	/// Sets the number of elements in a `db`/`dw`/`dd`/`dq` directive.
	/// Can only be called if `code()` is `Code::DeclareByte`, `Code::DeclareWord`, `Code::DeclareDword`, `Code::DeclareQword`
	///
	/// # Arguments
	///
	/// * `new_value`: New value: `db`: 1-16; `dw`: 1-8; `dd`: 1-4; `dq`: 1-2
	#[inline]
	pub fn set_declare_data_len(&mut self, new_value: u32) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::DATA_LENGTH_MASK << OpKindFlags::DATA_LENGTH_SHIFT))
			| (((new_value - 1) & OpKindFlags::DATA_LENGTH_MASK) << OpKindFlags::DATA_LENGTH_SHIFT);
	}

	/// Sets a new `db` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareByte`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-15)
	/// * `new_value`: New value
	#[inline]
	pub fn set_declare_byte_value_i8(&mut self, index: u32, new_value: i8) {
		self.set_declare_byte_value(index, new_value as u8)
	}

	/// Sets a new `db` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareByte`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-15)
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_declare_byte_value(&mut self, index: u32, new_value: u8) {
		match index {
			0 => self.reg0 = new_value,
			1 => self.reg1 = new_value,
			2 => self.reg2 = new_value,
			3 => self.reg3 = new_value,
			4 => self.immediate = (self.immediate & 0xFFFF_FF00) | new_value as u32,
			5 => self.immediate = (self.immediate & 0xFFFF_00FF) | ((new_value as u32) << 8),
			6 => self.immediate = (self.immediate & 0xFF00_FFFF) | ((new_value as u32) << 16),
			7 => self.immediate = (self.immediate & 0x00FF_FFFF) | ((new_value as u32) << 24),
			8 => self.mem_displ = (self.mem_displ & 0xFFFF_FF00) | new_value as u32,
			9 => self.mem_displ = (self.mem_displ & 0xFFFF_00FF) | ((new_value as u32) << 8),
			10 => self.mem_displ = (self.mem_displ & 0xFF00_FFFF) | ((new_value as u32) << 16),
			11 => self.mem_displ = (self.mem_displ & 0x00FF_FFFF) | ((new_value as u32) << 24),
			12 => self.mem_base_reg = new_value,
			13 => self.mem_index_reg = new_value,
			14 => self.op_kind_flags = (self.op_kind_flags & 0xFFFF_FF00) | new_value as u32,
			15 => self.op_kind_flags = (self.op_kind_flags & 0xFFFF_00FF) | ((new_value as u32) << 8),
			_ => panic!(),
		}
	}

	/// Gets a `db` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareByte`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-15)
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn get_declare_byte_value(&self, index: u32) -> u8 {
		match index {
			0 => self.reg0,
			1 => self.reg1,
			2 => self.reg2,
			3 => self.reg3,
			4 => self.immediate as u8,
			5 => (self.immediate >> 8) as u8,
			6 => (self.immediate >> 16) as u8,
			7 => (self.immediate >> 24) as u8,
			8 => self.mem_displ as u8,
			9 => (self.mem_displ >> 8) as u8,
			10 => (self.mem_displ >> 16) as u8,
			11 => (self.mem_displ >> 24) as u8,
			12 => self.mem_base_reg,
			13 => self.mem_index_reg,
			14 => self.op_kind_flags as u8,
			15 => (self.op_kind_flags >> 8) as u8,
			_ => panic!(),
		}
	}

	/// Sets a new `dw` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareWord`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-7)
	/// * `new_value`: New value
	#[inline]
	pub fn set_declare_word_value_i16(&mut self, index: u32, new_value: i16) {
		self.set_declare_word_value(index, new_value as u16);
	}

	/// Sets a new `dw` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareWord`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-7)
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_declare_word_value(&mut self, index: u32, new_value: u16) {
		match index {
			0 => {
				self.reg0 = new_value as u8;
				self.reg1 = (new_value >> 8) as u8;
			}
			1 => {
				self.reg2 = new_value as u8;
				self.reg3 = (new_value >> 8) as u8;
			}
			2 => self.immediate = (self.immediate & 0xFFFF_0000) | new_value as u32,
			3 => self.immediate = self.immediate as u16 as u32 | (new_value as u32) << 16,
			4 => self.mem_displ = (self.mem_displ & 0xFFFF_0000) | new_value as u32,
			5 => self.mem_displ = self.mem_displ as u16 as u32 | (new_value as u32) << 16,
			6 => {
				self.mem_base_reg = new_value as u8;
				self.mem_index_reg = (new_value >> 8) as u8;
			}
			7 => self.op_kind_flags = (self.op_kind_flags & 0xFFFF_0000) | new_value as u32,
			_ => panic!(),
		}
	}

	/// Gets a `dw` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareWord`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-7)
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn get_declare_word_value(&self, index: u32) -> u16 {
		match index {
			0 => self.reg0 as u16 | ((self.reg1 as u16) << 8),
			1 => self.reg2 as u16 | ((self.reg3 as u16) << 8),
			2 => self.immediate as u16,
			3 => (self.immediate >> 16) as u16,
			4 => self.mem_displ as u16,
			5 => (self.mem_displ >> 16) as u16,
			6 => self.mem_base_reg as u16 | ((self.mem_index_reg as u16) << 8),
			7 => self.op_kind_flags as u16,
			_ => panic!(),
		}
	}

	/// Sets a new `dd` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareDword`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-3)
	/// * `new_value`: New value
	#[inline]
	pub fn set_declare_dword_value_i32(&mut self, index: u32, new_value: i32) {
		self.set_declare_dword_value(index, new_value as u32);
	}

	/// Sets a new `dd` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareDword`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-3)
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_declare_dword_value(&mut self, index: u32, new_value: u32) {
		match index {
			0 => {
				self.reg0 = new_value as u8;
				self.reg1 = (new_value >> 8) as u8;
				self.reg2 = (new_value >> 16) as u8;
				self.reg3 = (new_value >> 24) as u8;
			}
			1 => self.immediate = new_value,
			2 => self.mem_displ = new_value,
			3 => {
				self.mem_base_reg = new_value as u8;
				self.mem_index_reg = (new_value >> 8) as u8;
				self.op_kind_flags = (self.op_kind_flags & 0xFFFF_0000) | (new_value >> 16);
			}
			_ => panic!(),
		}
	}

	/// Gets a `dd` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareDword`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-3)
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn get_declare_dword_value(&self, index: u32) -> u32 {
		match index {
			0 => self.reg0 as u32 | ((self.reg1 as u32) << 8) | ((self.reg2 as u32) << 16) | ((self.reg3 as u32) << 24),
			1 => self.immediate,
			2 => self.mem_displ,
			3 => self.mem_base_reg as u32 | ((self.mem_index_reg as u32) << 8) | (self.op_kind_flags << 16),
			_ => panic!(),
		}
	}

	/// Sets a new `dq` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareQword`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-1)
	/// * `new_value`: New value
	#[inline]
	pub fn set_declare_qword_value_i64(&mut self, index: u32, new_value: i64) {
		self.set_declare_qword_value(index, new_value as u64);
	}

	/// Sets a new `dq` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareQword`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-1)
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_declare_qword_value(&mut self, index: u32, new_value: u64) {
		match index {
			0 => {
				self.reg0 = new_value as u8;
				self.reg1 = (new_value >> 8) as u8;
				self.reg2 = (new_value >> 16) as u8;
				self.reg3 = (new_value >> 24) as u8;
				self.immediate = (new_value >> 32) as u32;
			}
			1 => {
				self.mem_displ = new_value as u32;
				self.mem_base_reg = (new_value >> 32) as u8;
				self.mem_index_reg = (new_value >> 40) as u8;
				self.op_kind_flags = (self.op_kind_flags & 0xFFFF_0000) | (new_value >> 48) as u32;
			}
			_ => panic!(),
		}
	}

	/// Gets a `dq` value, see also `declare_data_len()`.
	/// Can only be called if `code()` is `Code::DeclareQword`
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-1)
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn get_declare_qword_value(&self, index: u32) -> u64 {
		match index {
			0 => {
				self.reg0 as u64
					| ((self.reg1 as u64) << 8)
					| ((self.reg2 as u64) << 16)
					| ((self.reg3 as u64) << 24)
					| ((self.immediate as u64) << 32)
			}
			1 => {
				self.mem_displ as u64 | ((self.mem_base_reg as u64) << 32) | ((self.mem_index_reg as u64) << 40) | ((self.op_kind_flags as u64) << 48)
			}
			_ => panic!(),
		}
	}

	/// Checks if this is a VSIB instruction, see also `is_vsib32()`, `is_vsib64()`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_vsib(&self) -> bool {
		self.vsib().is_some()
	}

	/// VSIB instructions only (`is_vsib()`): `true` if it's using 32-bit indexes, `false` if it's using 64-bit indexes
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_vsib32(&self) -> bool {
		if let Some(is_vsib64) = self.vsib() {
			!is_vsib64
		} else {
			false
		}
	}

	/// VSIB instructions only (`is_vsib()`): `true` if it's using 64-bit indexes, `false` if it's using 32-bit indexes
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_vsib64(&self) -> bool {
		if let Some(is_vsib64) = self.vsib() {
			is_vsib64
		} else {
			false
		}
	}

	/// Checks if it's a vsib instruction.
	/// # Returns
	///
	/// * `Some(true)` if it's a VSIB instruction with 64-bit indexes
	/// * `Some(false)` if it's a VSIB instruction with 32-bit indexes
	/// * `None` if it's not a VSIB instruction.
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn vsib(&self) -> Option<bool> {
		match self.code() {
			Code::VEX_Vpgatherdd_xmm_vm32x_xmm
			| Code::VEX_Vpgatherdd_ymm_vm32y_ymm
			| Code::VEX_Vpgatherdq_xmm_vm32x_xmm
			| Code::VEX_Vpgatherdq_ymm_vm32x_ymm
			| Code::EVEX_Vpgatherdd_xmm_k1_vm32x
			| Code::EVEX_Vpgatherdd_ymm_k1_vm32y
			| Code::EVEX_Vpgatherdd_zmm_k1_vm32z
			| Code::EVEX_Vpgatherdq_xmm_k1_vm32x
			| Code::EVEX_Vpgatherdq_ymm_k1_vm32x
			| Code::EVEX_Vpgatherdq_zmm_k1_vm32y
			| Code::VEX_Vgatherdps_xmm_vm32x_xmm
			| Code::VEX_Vgatherdps_ymm_vm32y_ymm
			| Code::VEX_Vgatherdpd_xmm_vm32x_xmm
			| Code::VEX_Vgatherdpd_ymm_vm32x_ymm
			| Code::EVEX_Vgatherdps_xmm_k1_vm32x
			| Code::EVEX_Vgatherdps_ymm_k1_vm32y
			| Code::EVEX_Vgatherdps_zmm_k1_vm32z
			| Code::EVEX_Vgatherdpd_xmm_k1_vm32x
			| Code::EVEX_Vgatherdpd_ymm_k1_vm32x
			| Code::EVEX_Vgatherdpd_zmm_k1_vm32y
			| Code::EVEX_Vpscatterdd_vm32x_k1_xmm
			| Code::EVEX_Vpscatterdd_vm32y_k1_ymm
			| Code::EVEX_Vpscatterdd_vm32z_k1_zmm
			| Code::EVEX_Vpscatterdq_vm32x_k1_xmm
			| Code::EVEX_Vpscatterdq_vm32x_k1_ymm
			| Code::EVEX_Vpscatterdq_vm32y_k1_zmm
			| Code::EVEX_Vscatterdps_vm32x_k1_xmm
			| Code::EVEX_Vscatterdps_vm32y_k1_ymm
			| Code::EVEX_Vscatterdps_vm32z_k1_zmm
			| Code::EVEX_Vscatterdpd_vm32x_k1_xmm
			| Code::EVEX_Vscatterdpd_vm32x_k1_ymm
			| Code::EVEX_Vscatterdpd_vm32y_k1_zmm
			| Code::EVEX_Vgatherpf0dps_vm32z_k1
			| Code::EVEX_Vgatherpf0dpd_vm32y_k1
			| Code::EVEX_Vgatherpf1dps_vm32z_k1
			| Code::EVEX_Vgatherpf1dpd_vm32y_k1
			| Code::EVEX_Vscatterpf0dps_vm32z_k1
			| Code::EVEX_Vscatterpf0dpd_vm32y_k1
			| Code::EVEX_Vscatterpf1dps_vm32z_k1
			| Code::EVEX_Vscatterpf1dpd_vm32y_k1 => Some(false),

			Code::VEX_Vpgatherqd_xmm_vm64x_xmm
			| Code::VEX_Vpgatherqd_xmm_vm64y_xmm
			| Code::VEX_Vpgatherqq_xmm_vm64x_xmm
			| Code::VEX_Vpgatherqq_ymm_vm64y_ymm
			| Code::EVEX_Vpgatherqd_xmm_k1_vm64x
			| Code::EVEX_Vpgatherqd_xmm_k1_vm64y
			| Code::EVEX_Vpgatherqd_ymm_k1_vm64z
			| Code::EVEX_Vpgatherqq_xmm_k1_vm64x
			| Code::EVEX_Vpgatherqq_ymm_k1_vm64y
			| Code::EVEX_Vpgatherqq_zmm_k1_vm64z
			| Code::VEX_Vgatherqps_xmm_vm64x_xmm
			| Code::VEX_Vgatherqps_xmm_vm64y_xmm
			| Code::VEX_Vgatherqpd_xmm_vm64x_xmm
			| Code::VEX_Vgatherqpd_ymm_vm64y_ymm
			| Code::EVEX_Vgatherqps_xmm_k1_vm64x
			| Code::EVEX_Vgatherqps_xmm_k1_vm64y
			| Code::EVEX_Vgatherqps_ymm_k1_vm64z
			| Code::EVEX_Vgatherqpd_xmm_k1_vm64x
			| Code::EVEX_Vgatherqpd_ymm_k1_vm64y
			| Code::EVEX_Vgatherqpd_zmm_k1_vm64z
			| Code::EVEX_Vpscatterqd_vm64x_k1_xmm
			| Code::EVEX_Vpscatterqd_vm64y_k1_xmm
			| Code::EVEX_Vpscatterqd_vm64z_k1_ymm
			| Code::EVEX_Vpscatterqq_vm64x_k1_xmm
			| Code::EVEX_Vpscatterqq_vm64y_k1_ymm
			| Code::EVEX_Vpscatterqq_vm64z_k1_zmm
			| Code::EVEX_Vscatterqps_vm64x_k1_xmm
			| Code::EVEX_Vscatterqps_vm64y_k1_xmm
			| Code::EVEX_Vscatterqps_vm64z_k1_ymm
			| Code::EVEX_Vscatterqpd_vm64x_k1_xmm
			| Code::EVEX_Vscatterqpd_vm64y_k1_ymm
			| Code::EVEX_Vscatterqpd_vm64z_k1_zmm
			| Code::EVEX_Vgatherpf0qps_vm64z_k1
			| Code::EVEX_Vgatherpf0qpd_vm64z_k1
			| Code::EVEX_Vgatherpf1qps_vm64z_k1
			| Code::EVEX_Vgatherpf1qpd_vm64z_k1
			| Code::EVEX_Vscatterpf0qps_vm64z_k1
			| Code::EVEX_Vscatterpf0qpd_vm64z_k1
			| Code::EVEX_Vscatterpf1qps_vm64z_k1
			| Code::EVEX_Vscatterpf1qpd_vm64z_k1 => Some(true),

			_ => None,
		}
	}

	/// Gets the suppress all exceptions flag (EVEX encoded instructions). Note that if `rounding_control()` is
	/// not `RoundingControl::None`, SAE is implied but this property will still return `false`.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn suppress_all_exceptions(&self) -> bool {
		(self.code_flags & CodeFlags::SUPPRESS_ALL_EXCEPTIONS) != 0
	}

	/// Sets the suppress all exceptions flag (EVEX encoded instructions). Note that if `rounding_control()` is
	/// not `RoundingControl::None`, SAE is implied but this property will still return `false`.
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_suppress_all_exceptions(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::SUPPRESS_ALL_EXCEPTIONS;
		} else {
			self.code_flags &= !CodeFlags::SUPPRESS_ALL_EXCEPTIONS;
		}
	}

	/// Checks if the memory operand is `RIP`/`EIP` relative
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_ip_relative_memory_operand(&self) -> bool {
		let base_reg = self.memory_base();
		base_reg == Register::RIP || base_reg == Register::EIP
	}

	/// Gets the `RIP`/`EIP` releative address ((`next_ip()` or `next_ip32()`) + `memory_displacement()`).
	/// This property is only valid if there's a memory operand with `RIP`/`EIP` relative addressing, see `is_ip_relative_memory_operand()`
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn ip_relative_memory_address(&self) -> u64 {
		let mut result = self.next_ip().wrapping_add(self.memory_displacement() as i32 as u64);
		if self.memory_base() == Register::EIP {
			result = result as u32 as u64;
		}
		result
	}

	/// Gets the virtual address of a memory operand
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, must be a memory operand
	/// * `element_index`: Only used if it's a vsib memory operand. This is the element index of the vector index register.
	/// * `get_register_value`: Function that returns the value of a register or the base address of a segment register.
	///
	/// # Call-back function args
	///
	/// * Arg 1: `register`: Register (GPR8, GPR16, GPR32, GPR64, XMM, YMM, ZMM, seg). If it's a segment register, the call-back function should return the segment's base value, not the segment register value.
	/// * Arg 2: `element_index`: Only used if it's a vsib memory operand. This is the element index in the vector register.
	/// * Arg 3: `element_size`: Only used if it's a vsib memory operand. Size in bytes of elements in vector index register (4 or 8).
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // add [rdi+r12*8-5AA5EDCCh],esi
	/// let bytes = b"\x42\x01\xB4\xE7\x34\x12\x5A\xA5";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// let va = instr.virtual_address(0, 0, |register, element_index, element_size| {
	///     match register {
	///         // The base address of ES, CS, SS and DS is always 0 in 64-bit mode
	///         Register::DS => 0x0000_0000_0000_0000,
	///         Register::RDI => 0x0000_0000_1000_0000,
	///         Register::R12 => 0x0000_0004_0000_0000,
	///         _ => unimplemented!(),
	///     }
	/// });
	/// assert_eq!(0x0000_001F_B55A_1234, va);
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn virtual_address<F>(&self, operand: u32, element_index: u32, get_register_value: F) -> u64
	where
		F: Fn(Register, u32, u32) -> u64,
	{
		match self.op_kind(operand) {
			OpKind::Register
			| OpKind::NearBranch16
			| OpKind::NearBranch32
			| OpKind::NearBranch64
			| OpKind::FarBranch16
			| OpKind::FarBranch32
			| OpKind::Immediate8
			| OpKind::Immediate8_2nd
			| OpKind::Immediate16
			| OpKind::Immediate32
			| OpKind::Immediate64
			| OpKind::Immediate8to16
			| OpKind::Immediate8to32
			| OpKind::Immediate8to64
			| OpKind::Immediate32to64 => 0,

			OpKind::MemorySegSI => get_register_value(self.memory_segment(), 0, 0).wrapping_add(get_register_value(Register::SI, 0, 0) as u16 as u64),
			OpKind::MemorySegESI => {
				get_register_value(self.memory_segment(), 0, 0).wrapping_add(get_register_value(Register::ESI, 0, 0) as u32 as u64)
			}
			OpKind::MemorySegRSI => get_register_value(self.memory_segment(), 0, 0).wrapping_add(get_register_value(Register::RSI, 0, 0)),
			OpKind::MemorySegDI => get_register_value(self.memory_segment(), 0, 0).wrapping_add(get_register_value(Register::DI, 0, 0) as u16 as u64),
			OpKind::MemorySegEDI => {
				get_register_value(self.memory_segment(), 0, 0).wrapping_add(get_register_value(Register::EDI, 0, 0) as u32 as u64)
			}
			OpKind::MemorySegRDI => get_register_value(self.memory_segment(), 0, 0).wrapping_add(get_register_value(Register::RDI, 0, 0)),
			OpKind::MemoryESDI => get_register_value(Register::ES, 0, 0).wrapping_add(get_register_value(Register::DI, 0, 0) as u16 as u64),
			OpKind::MemoryESEDI => get_register_value(Register::ES, 0, 0).wrapping_add(get_register_value(Register::EDI, 0, 0) as u32 as u64),
			OpKind::MemoryESRDI => get_register_value(Register::ES, 0, 0).wrapping_add(get_register_value(Register::RDI, 0, 0)),
			OpKind::Memory64 => get_register_value(self.memory_segment(), 0, 0).wrapping_add(self.memory_address64()),

			OpKind::Memory => {
				let base_reg = self.memory_base();
				let index_reg = self.memory_index();
				let addr_size =
					super::instruction_internal::get_address_size_in_bytes(base_reg, index_reg, self.memory_displ_size(), self.code_size());
				let mut offset = self.memory_displacement() as u64;
				let offset_mask = match addr_size {
					8 => {
						offset = offset as i32 as u64;
						u64::MAX
					}
					4 => u32::MAX as u64,
					_ => {
						debug_assert_eq!(2, addr_size);
						u16::MAX as u64
					}
				};
				match base_reg {
					Register::None => {}
					Register::RIP => offset = offset.wrapping_add(self.next_ip()),
					Register::EIP => offset = offset.wrapping_add(self.next_ip32() as u64),
					_ => offset = offset.wrapping_add(get_register_value(base_reg, 0, 0)),
				}
				if index_reg != Register::None {
					if let Some(is_vsib64) = self.vsib() {
						if is_vsib64 {
							offset = offset.wrapping_add(
								get_register_value(index_reg, element_index, 8) << super::instruction_internal::internal_get_memory_index_scale(self),
							);
						} else {
							offset = offset.wrapping_add(
								(get_register_value(index_reg, element_index, 4) as u32 as u64)
									<< super::instruction_internal::internal_get_memory_index_scale(self),
							);
						}
					} else {
						offset = offset.wrapping_add(
							get_register_value(index_reg, element_index, 0) << super::instruction_internal::internal_get_memory_index_scale(self),
						);
					}
				}
				offset &= offset_mask;
				get_register_value(self.memory_segment(), 0, 0).wrapping_add(offset)
			}
		}
	}
}

impl Instruction {
	//TODO: OpCode prop
}

#[cfg(feature = "ENCODER")]
impl Instruction {
	//TODO: Instruction.Create.cs
}

#[cfg(feature = "INSTR_INFO")]
impl Instruction {
	/// Gets the number of bytes added to `SP`/`ESP`/`RSP` or 0 if it's not an instruction that pushes or pops data. This method assumes
	/// the instruction doesn't change the privilege level (eg. `IRET/D/Q`). If it's the `LEAVE` instruction, this method returns 0.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // pushfq
	/// let bytes = b"\x9C";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert!(instr.is_stack_instruction());
	/// assert_eq!(-8, instr.stack_pointer_increment());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn stack_pointer_increment(&self) -> i32 {
		match self.code() {
			Code::Pushw_ES
			| Code::Pushw_CS
			| Code::Pushw_SS
			| Code::Pushw_DS
			| Code::Push_r16
			| Code::Push_imm16
			| Code::Pushw_imm8
			| Code::Pushfw
			| Code::Push_rm16
			| Code::Pushw_FS
			| Code::Pushw_GS => -2,
			Code::Pushd_ES
			| Code::Pushd_CS
			| Code::Pushd_SS
			| Code::Pushd_DS
			| Code::Push_r32
			| Code::Pushd_imm32
			| Code::Pushd_imm8
			| Code::Pushfd
			| Code::Push_rm32
			| Code::Pushd_FS
			| Code::Pushd_GS => -4,
			Code::Push_r64 | Code::Pushq_imm32 | Code::Pushq_imm8 | Code::Pushfq | Code::Push_rm64 | Code::Pushq_FS | Code::Pushq_GS => -8,
			Code::Pushaw => -2 * 8,
			Code::Pushad => -4 * 8,
			Code::Popw_ES
			| Code::Popw_CS
			| Code::Popw_SS
			| Code::Popw_DS
			| Code::Pop_r16
			| Code::Pop_rm16
			| Code::Popfw
			| Code::Popw_FS
			| Code::Popw_GS => 2,
			Code::Popd_ES | Code::Popd_SS | Code::Popd_DS | Code::Pop_r32 | Code::Pop_rm32 | Code::Popfd | Code::Popd_FS | Code::Popd_GS => 4,
			Code::Pop_r64 | Code::Pop_rm64 | Code::Popfq | Code::Popq_FS | Code::Popq_GS => 8,
			Code::Popaw => 2 * 8,
			Code::Popad => 4 * 8,
			Code::Call_ptr1616 | Code::Call_m1616 => -(2 + 2),
			Code::Call_ptr1632 | Code::Call_m1632 => -(4 + 4),
			Code::Call_m1664 => -(8 + 8),
			Code::Call_rel16 | Code::Call_rm16 => -2,
			Code::Call_rel32_32 | Code::Call_rm32 => -4,
			Code::Call_rel32_64 | Code::Call_rm64 => -8,
			Code::Retnw_imm16 => 2 + self.immediate16() as i32,
			Code::Retnd_imm16 => 4 + self.immediate16() as i32,
			Code::Retnq_imm16 => 8 + self.immediate16() as i32,
			Code::Retnw => 2,
			Code::Retnd => 4,
			Code::Retnq => 8,
			Code::Retfw_imm16 => 2 + 2 + self.immediate16() as i32,
			Code::Retfd_imm16 => 4 + 4 + self.immediate16() as i32,
			Code::Retfq_imm16 => 8 + 8 + self.immediate16() as i32,
			Code::Retfw => 2 + 2,
			Code::Retfd => 4 + 4,
			Code::Retfq => 8 + 8,
			Code::Iretw => {
				if self.code_size() == CodeSize::Code64 {
					2 * 5
				} else {
					2 * 3
				}
			}
			Code::Iretd => {
				if self.code_size() == CodeSize::Code64 {
					4 * 5
				} else {
					4 * 3
				}
			}
			Code::Iretq => 8 * 5,
			Code::Enterw_imm16_imm8 => -(2 + (self.immediate8_2nd() as i32 & 0x1F) * 2 + self.immediate16() as i32),
			Code::Enterd_imm16_imm8 => -(4 + (self.immediate8_2nd() as i32 & 0x1F) * 4 + self.immediate16() as i32),
			Code::Enterq_imm16_imm8 => -(8 + (self.immediate8_2nd() as i32 & 0x1F) * 8 + self.immediate16() as i32),
			Code::Leavew | Code::Leaved | Code::Leaveq => 0,
			_ => 0,
		}
	}

	// InstructionInfoFactory should be used, these are slower so they're only enabled for the tests
	#[cfg(test)]
	#[inline]
	pub(crate) fn info(&self) -> InstructionInfo {
		self.info_options(0)
	}

	#[cfg(test)]
	#[inline]
	pub(crate) fn info_options(&self, options: u32) -> InstructionInfo {
		let mut info = InstructionInfo::new(options);
		let _ = self::info::InstructionInfoFactory::create(&mut info, self, options);
		info
	}

	#[cfg(test)]
	#[inline]
	pub(crate) fn used_registers(&self) -> Vec<UsedRegister> {
		const OPTIONS: u32 = 0;
		let mut info = InstructionInfo::new(OPTIONS);
		let _ = self::info::InstructionInfoFactory::create(&mut info, self, OPTIONS);
		info.used_registers
	}

	#[cfg(test)]
	#[inline]
	pub(crate) fn used_memory(&self) -> Vec<UsedMemory> {
		const OPTIONS: u32 = 0;
		let mut info = InstructionInfo::new(OPTIONS);
		let _ = self::info::InstructionInfoFactory::create(&mut info, self, OPTIONS);
		info.used_memory_locations
	}

	/// Instruction encoding, eg. legacy, VEX, EVEX, ...
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // vmovaps xmm1,xmm5
	/// let bytes = b"\xC5\xF8\x28\xCD";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert_eq!(EncodingKind::VEX, instr.encoding());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn encoding(&self) -> EncodingKind {
		self.code().encoding()
	}

	/// Gets the CPU or CPUID feature flags
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // vmovaps xmm1,xmm5
	/// // vmovaps xmm10{k3}{z},xmm19
	/// let bytes = b"\xC5\xF8\x28\xCD\x62\x31\x7C\x8B\x28\xD3";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // vmovaps xmm1,xmm5
	/// let instr = decoder.decode();
	/// let cpuid = instr.cpuid_features();
	/// assert_eq!(1, cpuid.len());
	/// assert_eq!(CpuidFeature::AVX, cpuid[0]);
	///
	/// // vmovaps xmm10{k3}{z},xmm19
	/// let instr = decoder.decode();
	/// let cpuid = instr.cpuid_features();
	/// assert_eq!(2, cpuid.len());
	/// assert_eq!(CpuidFeature::AVX512VL, cpuid[0]);
	/// assert_eq!(CpuidFeature::AVX512F, cpuid[1]);
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn cpuid_features(&self) -> &'static [CpuidFeature] {
		let flags2 = unsafe { *super::info::info_table::TABLE.get_unchecked((self.code() as usize) * 2 + 1) };
		let mut index = ((flags2 >> InfoFlags2::CPUID_FEATURE_INTERNAL_SHIFT) & InfoFlags2::CPUID_FEATURE_INTERNAL_MASK) as usize;
		if (flags2 & InfoFlags2::AVX2_CHECK) != 0 && self.op1_kind() == OpKind::Register {
			index = CpuidFeatureInternal::AVX2 as usize;
		}
		unsafe { *super::info::cpuid_table::CPUID.get_unchecked(index) }
	}

	/// Flow control info
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // or ecx,esi
	/// // ud0 rcx,rsi
	/// // call rcx
	/// let bytes = b"\x0B\xCE\x48\x0F\xFF\xCE\xFF\xD1";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // or ecx,esi
	/// let instr = decoder.decode();
	/// assert_eq!(FlowControl::Next, instr.flow_control());
	///
	/// // ud0 rcx,rsi
	/// let instr = decoder.decode();
	/// assert_eq!(FlowControl::Exception, instr.flow_control());
	///
	/// // call rcx
	/// let instr = decoder.decode();
	/// assert_eq!(FlowControl::IndirectCall, instr.flow_control());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn flow_control(&self) -> FlowControl {
		self.code().flow_control()
	}

	/// true if the instruction isn't available in real mode or virtual 8086 mode
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_protected_mode(&self) -> bool {
		self.code().is_protected_mode()
	}

	/// true if this is a privileged instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_privileged(&self) -> bool {
		self.code().is_privileged()
	}

	/// true if this is an instruction that implicitly uses the stack pointer (`SP`/`ESP`/`RSP`), eg. `CALL`, `PUSH`, `POP`, `RET`, etc.
	/// See also `stack_pointer_increment()`
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // or ecx,esi
	/// // push rax
	/// let bytes = b"\x0B\xCE\x50";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // or ecx,esi
	/// let instr = decoder.decode();
	/// assert!(!instr.is_stack_instruction());
	///
	/// // push rax
	/// let instr = decoder.decode();
	/// assert!(instr.is_stack_instruction());
	/// assert_eq!(-8, instr.stack_pointer_increment());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_stack_instruction(&self) -> bool {
		self.code().is_stack_instruction()
	}

	/// true if it's an instruction that saves or restores too many registers (eg. `FXRSTOR`, `XSAVE`, etc).
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_save_restore_instruction(&self) -> bool {
		self.code().is_save_restore_instruction()
	}

	#[cfg_attr(has_must_use, must_use)]
	fn rflags_info(&self) -> usize {
		let flags1 = unsafe { *super::info::info_table::TABLE.get_unchecked((self.code() as usize) * 2) };
		let code_info = (flags1 >> InfoFlags1::CODE_INFO_SHIFT) & InfoFlags1::CODE_INFO_MASK;
		const_assert!(CodeInfo::Shift_Ib_MASK1FMOD9 as u32 + 1 == CodeInfo::Shift_Ib_MASK1FMOD11 as u32);
		const_assert!(CodeInfo::Shift_Ib_MASK1FMOD9 as u32 + 2 == CodeInfo::Shift_Ib_MASK1F as u32);
		const_assert!(CodeInfo::Shift_Ib_MASK1FMOD9 as u32 + 3 == CodeInfo::Shift_Ib_MASK3F as u32);
		const_assert!(CodeInfo::Shift_Ib_MASK1FMOD9 as u32 + 4 == CodeInfo::Clear_rflags as u32);
		match code_info.wrapping_sub(CodeInfo::Shift_Ib_MASK1FMOD9 as u32) {
			0 => {
				const_assert_eq!(0, CodeInfo::Shift_Ib_MASK1FMOD9 as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				if (self.immediate8() & 0x1F) % 9 == 0 {
					return RflagsInfo::None as usize;
				}
			}
			1 => {
				const_assert_eq!(1, CodeInfo::Shift_Ib_MASK1FMOD11 as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				if (self.immediate8() & 0x1F) % 17 == 0 {
					return RflagsInfo::None as usize;
				}
			}
			2 => {
				const_assert_eq!(2, CodeInfo::Shift_Ib_MASK1F as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				if (self.immediate8() & 0x1F) == 0 {
					return RflagsInfo::None as usize;
				}
			}
			3 => {
				const_assert_eq!(3, CodeInfo::Shift_Ib_MASK3F as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				if (self.immediate8() & 0x3F) == 0 {
					return RflagsInfo::None as usize;
				}
			}
			4 => {
				const_assert_eq!(4, CodeInfo::Clear_rflags as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				if self.op0_register() == self.op1_register() && self.op0_kind() == OpKind::Register && self.op1_kind() == OpKind::Register {
					return RflagsInfo::C_cos_S_pz_U_a as usize;
				}
			}
			_ => {}
		}
		((flags1 >> InfoFlags1::RFLAGS_INFO_SHIFT) & InfoFlags1::RFLAGS_INFO_MASK) as usize
	}

	/// All flags that are read by the CPU when executing the instruction. This method returns a `RflagsBits` value. See also `rflags_modified()`.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_read(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_READ.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are written by the CPU, except those flags that are known to be undefined, always set or always cleared.
	/// This method returns a `RflagsBits` value. See also `rflags_modified()`.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_written(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_WRITTEN.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are always cleared by the CPU. This method returns a `RflagsBits` value. See also `rflags_modified()`.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_cleared(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_CLEARED.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are always set by the CPU. This method returns a `RflagsBits` value. See also `rflags_modified()`.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_set(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_SET.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are undefined after executing the instruction. This method returns a `RflagsBits` value. See also `rflags_modified()`.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_undefined(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_UNDEFINED.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are modified by the CPU. This is `rflags_written() + rflags_cleared() + rflags_set() + rflags_undefined()`. This method returns a `RflagsBits` value.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_modified(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_MODIFIED.get_unchecked(self.rflags_info()) as u32 }
	}

	/// Checks if it's a `Jcc SHORT` or `Jcc NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jcc_short_or_near(&self) -> bool {
		self.code().is_jcc_short_or_near()
	}

	/// Checks if it's a `Jcc NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jcc_near(&self) -> bool {
		self.code().is_jcc_near()
	}

	/// Checks if it's a `Jcc SHORT` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jcc_short(&self) -> bool {
		self.code().is_jcc_short()
	}

	/// Checks if it's a `JMP SHORT` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_short(&self) -> bool {
		self.code().is_jmp_short()
	}

	/// Checks if it's a `JMP NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_near(&self) -> bool {
		self.code().is_jmp_near()
	}

	/// Checks if it's a `JMP SHORT` or a `JMP NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_short_or_near(&self) -> bool {
		self.code().is_jmp_short_or_near()
	}

	/// Checks if it's a `JMP FAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_far(&self) -> bool {
		self.code().is_jmp_far()
	}

	/// Checks if it's a `CALL NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_call_near(&self) -> bool {
		self.code().is_call_near()
	}

	/// Checks if it's a `CALL FAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_call_far(&self) -> bool {
		self.code().is_call_far()
	}

	/// Checks if it's a `JMP NEAR reg/[mem]` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_near_indirect(&self) -> bool {
		self.code().is_jmp_near_indirect()
	}

	/// Checks if it's a `JMP FAR [mem]` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_far_indirect(&self) -> bool {
		self.code().is_jmp_far_indirect()
	}

	/// Checks if it's a `CALL NEAR reg/[mem]` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_call_near_indirect(&self) -> bool {
		self.code().is_call_near_indirect()
	}

	/// Checks if it's a `CALL FAR [mem]` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_call_far_indirect(&self) -> bool {
		self.code().is_call_far_indirect()
	}

	/// Negates the condition code, eg. `JE` -> `JNE`. Can be used if it's `Jcc`, `SETcc`, `CMOVcc` and does
	/// nothing if the instruction doesn't have a condition code.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // setbe al
	/// let bytes = b"\x0F\x96\xC0";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// let mut instr = decoder.decode();
	/// assert_eq!(Code::Setbe_rm8, instr.code());
	/// assert_eq!(ConditionCode::be, instr.condition_code());
	/// instr.negate_condition_code();
	/// assert_eq!(Code::Seta_rm8, instr.code());
	/// assert_eq!(ConditionCode::a, instr.condition_code());
	/// ```
	#[inline]
	pub fn negate_condition_code(&mut self) {
		// Temp needed if rustc < 1.36.0 (2015 edition)
		let t = self.code().negate_condition_code();
		self.set_code(t)
	}

	/// Converts `Jcc/JMP NEAR` to `Jcc/JMP SHORT` and does nothing if it's not a `Jcc/JMP NEAR` instruction
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // jbe near ptr label
	/// let bytes = b"\x0F\x86\x5A\xA5\x12\x34";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// let mut instr = decoder.decode();
	/// assert_eq!(Code::Jbe_rel32_64, instr.code());
	/// instr.to_short_branch();
	/// assert_eq!(Code::Jbe_rel8_64, instr.code());
	/// instr.to_short_branch();
	/// assert_eq!(Code::Jbe_rel8_64, instr.code());
	/// ```
	#[inline]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::wrong_self_convention))]
	pub fn to_short_branch(&mut self) {
		// Temp needed if rustc < 1.36.0 (2015 edition)
		let t = self.code().to_short_branch();
		self.set_code(t)
	}

	/// Converts `Jcc/JMP SHORT` to `Jcc/JMP NEAR` and does nothing if it's not a `Jcc/JMP SHORT` instruction
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // jbe short label
	/// let bytes = b"\x76\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// let mut instr = decoder.decode();
	/// assert_eq!(Code::Jbe_rel8_64, instr.code());
	/// instr.to_near_branch();
	/// assert_eq!(Code::Jbe_rel32_64, instr.code());
	/// instr.to_near_branch();
	/// assert_eq!(Code::Jbe_rel32_64, instr.code());
	/// ```
	#[inline]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::wrong_self_convention))]
	pub fn to_near_branch(&mut self) {
		// Temp needed if rustc < 1.36.0 (2015 edition)
		let t = self.code().to_near_branch();
		self.set_code(t)
	}

	/// Gets the condition code if it's `Jcc`, `SETcc`, `CMOVcc` else `ConditionCode::None` is returned
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // setbe al
	/// // jl short label
	/// // cmovne ecx,esi
	/// // nop
	/// let bytes = b"\x0F\x96\xC0\x7C\x5A\x0F\x45\xCE\x90";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // setbe al
	/// let instr = decoder.decode();
	/// assert_eq!(ConditionCode::be, instr.condition_code());
	///
	/// // jl short label
	/// let instr = decoder.decode();
	/// assert_eq!(ConditionCode::l, instr.condition_code());
	///
	/// // cmovne ecx,esi
	/// let instr = decoder.decode();
	/// assert_eq!(ConditionCode::ne, instr.condition_code());
	///
	/// // nop
	/// let instr = decoder.decode();
	/// assert_eq!(ConditionCode::None, instr.condition_code());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn condition_code(&self) -> ConditionCode {
		self.code().condition_code()
	}
}

impl Eq for Instruction {}

impl PartialEq<Instruction> for Instruction {
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	fn eq(&self, other: &Self) -> bool {
		((self.code_flags ^ other.code_flags) & !CodeFlags::EQUALS_IGNORE_MASK) == 0
			&& ((self.op_kind_flags ^ other.op_kind_flags) & !OpKindFlags::EQUALS_IGNORE_MASK) == 0
			&& self.immediate == other.immediate
			&& self.mem_displ == other.mem_displ
			&& self.memory_flags == other.memory_flags
			&& self.mem_base_reg == other.mem_base_reg
			&& self.mem_index_reg == other.mem_index_reg
			&& self.reg0 == other.reg0
			&& self.reg1 == other.reg1
			&& self.reg2 == other.reg2
			&& self.reg3 == other.reg3
	}
}

#[cfg(any(feature = "MASM_FORMATTER", feature = "ALL_FORMATTERS"))]
impl fmt::Display for Instruction {
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> fmt::Result {
		f.write_str("NYI")?; //TODO:
		Ok(())
	}
}
#[cfg(all(
	not(any(feature = "MASM_FORMATTER", feature = "ALL_FORMATTERS")),
	any(feature = "NASM_FORMATTER", feature = "ALL_FORMATTERS")
))]
impl fmt::Display for Instruction {
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> fmt::Result {
		f.write_str("NYI")?; //TODO:
		Ok(())
	}
}
#[cfg(all(
	not(any(feature = "MASM_FORMATTER", feature = "ALL_FORMATTERS")),
	not(any(feature = "NASM_FORMATTER", feature = "ALL_FORMATTERS")),
	any(feature = "INTEL_FORMATTER", feature = "ALL_FORMATTERS")
))]
impl fmt::Display for Instruction {
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> fmt::Result {
		f.write_str("NYI")?; //TODO:
		Ok(())
	}
}
#[cfg(all(
	not(any(feature = "MASM_FORMATTER", feature = "ALL_FORMATTERS")),
	not(any(feature = "NASM_FORMATTER", feature = "ALL_FORMATTERS")),
	not(any(feature = "INTEL_FORMATTER", feature = "ALL_FORMATTERS")),
	any(feature = "GAS_FORMATTER", feature = "ALL_FORMATTERS")
))]
impl fmt::Display for Instruction {
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> fmt::Result {
		f.write_str("NYI")?; //TODO:
		Ok(())
	}
}
