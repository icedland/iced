/*
Copyright (C) 2018-2019 de4dot@gmail.com

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

use super::iced_constants::IcedConstants;
#[cfg(feature = "instr_info")]
use super::info::enums::*;
use super::*;
#[cfg(all(not(any(feature = "gas", feature = "intel", feature = "masm", feature = "nasm")), feature = "fast_fmt"))]
#[cfg(not(feature = "std"))]
use alloc::string::String;
#[cfg(any(feature = "gas", feature = "intel", feature = "masm", feature = "nasm", feature = "fast_fmt"))]
use core::fmt;
use core::hash::{Hash, Hasher};
#[cfg(feature = "encoder")]
use core::ptr;
use core::{mem, slice, u16, u32, u64};

// GENERATOR-BEGIN: MemoryFlags
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
pub(crate) struct MemoryFlags;
#[allow(dead_code)]
impl MemoryFlags {
	pub(crate) const SCALE_MASK: u32 = 0x0000_0003;
	pub(crate) const DISPL_SIZE_SHIFT: u32 = 0x0000_0002;
	pub(crate) const DISPL_SIZE_MASK: u32 = 0x0000_0007;
	pub(crate) const SEGMENT_PREFIX_SHIFT: u32 = 0x0000_0005;
	pub(crate) const SEGMENT_PREFIX_MASK: u32 = 0x0000_0007;
	pub(crate) const BROADCAST: u32 = 0x0000_8000;
}
// GENERATOR-END: MemoryFlags

// GENERATOR-BEGIN: OpKindFlags
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
pub(crate) struct OpKindFlags;
#[allow(dead_code)]
impl OpKindFlags {
	pub(crate) const OP_KIND_BITS: u32 = 0x0000_0005;
	pub(crate) const OP_KIND_MASK: u32 = 0x0000_001F;
	pub(crate) const OP1_KIND_SHIFT: u32 = 0x0000_0005;
	pub(crate) const OP2_KIND_SHIFT: u32 = 0x0000_000A;
	pub(crate) const OP3_KIND_SHIFT: u32 = 0x0000_000F;
	pub(crate) const DATA_LENGTH_MASK: u32 = 0x0000_000F;
	pub(crate) const DATA_LENGTH_SHIFT: u32 = 0x0000_0014;
	pub(crate) const CODE_SIZE_MASK: u32 = 0x0000_0003;
	pub(crate) const CODE_SIZE_SHIFT: u32 = 0x0000_001E;
	pub(crate) const EQUALS_IGNORE_MASK: u32 = 0xC000_0000;
}
// GENERATOR-END: OpKindFlags

// GENERATOR-BEGIN: CodeFlags
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
pub(crate) struct CodeFlags;
#[allow(dead_code)]
impl CodeFlags {
	pub(crate) const CODE_BITS: u32 = 0x0000_000D;
	pub(crate) const CODE_MASK: u32 = 0x0000_1FFF;
	pub(crate) const ROUNDING_CONTROL_MASK: u32 = 0x0000_0007;
	pub(crate) const ROUNDING_CONTROL_SHIFT: u32 = 0x0000_000D;
	pub(crate) const OP_MASK_MASK: u32 = 0x0000_0007;
	pub(crate) const OP_MASK_SHIFT: u32 = 0x0000_0010;
	pub(crate) const INSTR_LENGTH_MASK: u32 = 0x0000_000F;
	pub(crate) const INSTR_LENGTH_SHIFT: u32 = 0x0000_0013;
	pub(crate) const SUPPRESS_ALL_EXCEPTIONS: u32 = 0x0200_0000;
	pub(crate) const ZEROING_MASKING: u32 = 0x0400_0000;
	pub(crate) const XACQUIRE_PREFIX: u32 = 0x0800_0000;
	pub(crate) const XRELEASE_PREFIX: u32 = 0x1000_0000;
	pub(crate) const REPE_PREFIX: u32 = 0x2000_0000;
	pub(crate) const REPNE_PREFIX: u32 = 0x4000_0000;
	pub(crate) const LOCK_PREFIX: u32 = 0x8000_0000;
	pub(crate) const EQUALS_IGNORE_MASK: u32 = 0x0078_0000;
}
// GENERATOR-END: CodeFlags

/// A 16/32/64-bit x86 instruction. Created by [`Decoder`] or by `Instruction::with*()` methods.
///
/// [`Decoder`]: struct.Decoder.html
#[derive(Debug, Default, Copy, Clone)]
pub struct Instruction {
	pub(crate) next_rip: u64,
	pub(crate) code_flags: u32,    // CodeFlags
	pub(crate) op_kind_flags: u32, // OpKindFlags
	// If it's a 64-bit immediate/offset/target, the high 32 bits is in mem_displ
	pub(crate) immediate: u32,
	// This is the high 32 bits if it's a 64-bit immediate/offset/target
	pub(crate) mem_displ: u32,
	pub(crate) memory_flags: u16, // MemoryFlags
	pub(crate) mem_base_reg: u8,  // Register
	pub(crate) mem_index_reg: u8, // Register
	pub(crate) reg0: u8,          // Register
	pub(crate) reg1: u8,          // Register
	pub(crate) reg2: u8,          // Register
	pub(crate) reg3: u8,          // Register
}
// All fields, size: 32 bytes with bits to spare
#[cfg(test)]
pub(crate) const INSTRUCTION_TOTAL_SIZE: usize = 32;

#[cfg_attr(feature = "cargo-clippy", allow(clippy::len_without_is_empty))]
impl Instruction {
	/// Creates an empty `Instruction` (all fields are cleared). See also the `with_*()` constructor methods.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn new() -> Self {
		Instruction::default()
	}

	/// Checks if two instructions are equal, comparing all bits, not ignoring anything. `==` ignores some fields.
	#[cfg_attr(has_must_use, must_use)]
	#[allow(trivial_casts)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn eq_all_bits(&self, other: &Self) -> bool {
		unsafe {
			let a: *const u8 = self as *const Self as *const u8;
			let b: *const u8 = other as *const Self as *const u8;
			let sa = slice::from_raw_parts(a, mem::size_of::<Self>());
			let sb = slice::from_raw_parts(b, mem::size_of::<Self>());
			sa == sb
		}
	}

	/// Gets the 16-bit IP of the instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn ip16(&self) -> u16 {
		(self.next_rip as u16).wrapping_sub(self.len() as u16)
	}

	/// Sets the 16-bit IP of the instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_ip16(&mut self, new_value: u16) {
		self.next_rip = (new_value as u64).wrapping_add(self.len() as u64);
	}

	/// Gets the 32-bit IP of the instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn ip32(&self) -> u32 {
		(self.next_rip as u32).wrapping_sub(self.len() as u32)
	}

	/// Sets the 32-bit IP of the instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_ip32(&mut self, new_value: u32) {
		self.next_rip = (new_value as u64).wrapping_add(self.len() as u64);
	}

	/// Gets the 64-bit IP of the instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn ip(&self) -> u64 {
		self.next_rip.wrapping_sub(self.len() as u64)
	}

	/// Sets the 64-bit IP of the instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_ip(&mut self, new_value: u64) {
		self.next_rip = new_value.wrapping_add(self.len() as u64);
	}

	/// Gets the 16-bit IP of the next instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn next_ip16(&self) -> u16 {
		self.next_rip as u16
	}

	/// Sets the 16-bit IP of the next instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_next_ip16(&mut self, new_value: u16) {
		self.next_rip = new_value as u64;
	}

	/// Gets the 32-bit IP of the next instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn next_ip32(&self) -> u32 {
		self.next_rip as u32
	}

	/// Sets the 32-bit IP of the next instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_next_ip32(&mut self, new_value: u32) {
		self.next_rip = new_value as u64;
	}

	/// Gets the 64-bit IP of the next instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn next_ip(&self) -> u64 {
		self.next_rip
	}

	/// Sets the 64-bit IP of the next instruction
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_next_ip(&mut self, new_value: u64) {
		self.next_rip = new_value;
	}

	/// Gets the code size when the instruction was decoded. This value is informational and can
	/// be used by a formatter.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn code_size(&self) -> CodeSize {
		unsafe { mem::transmute(((self.op_kind_flags >> OpKindFlags::CODE_SIZE_SHIFT) & OpKindFlags::CODE_SIZE_MASK) as u8) }
	}

	/// Sets the code size when the instruction was decoded. This value is informational and can
	/// be used by a formatter.
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_code_size(&mut self, new_value: CodeSize) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::CODE_SIZE_MASK << OpKindFlags::CODE_SIZE_SHIFT))
			| (((new_value as u32) & OpKindFlags::CODE_SIZE_MASK) << OpKindFlags::CODE_SIZE_SHIFT);
	}

	/// Checks if it's an invalid instruction ([`code()`] == [`Code::INVALID`])
	///
	/// [`code()`]: #method.code
	/// [`Code::INVALID`]: enum.Code.html#variant.INVALID
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_invalid(&self) -> bool {
		const_assert_eq!(0, Code::INVALID as u32);
		(self.code_flags & CodeFlags::CODE_MASK) == 0
	}

	/// Gets the instruction code, see also [`mnemonic()`]
	///
	/// [`mnemonic()`]: #method.mnemonic
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn code(&self) -> Code {
		unsafe { mem::transmute((self.code_flags & CodeFlags::CODE_MASK) as u16) }
	}

	/// Sets the instruction code
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_code(&mut self, new_value: Code) {
		self.code_flags = (self.code_flags & !CodeFlags::CODE_MASK) | new_value as u32;
	}

	/// Gets the mnemonic, see also [`code()`]
	///
	/// [`code()`]: #method.code
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn mnemonic(&self) -> Mnemonic {
		self.code().mnemonic()
	}

	/// Gets the operand count. An instruction can have 0-5 operands.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // add [rax],ebx
	/// let bytes = b"\x01\x18";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert_eq!(2, instr.op_count());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op_count(&self) -> u32 {
		unsafe { *instruction_op_counts::OP_COUNT.get_unchecked((self.code_flags & CodeFlags::CODE_MASK) as usize) as u32 }
	}

	/// Gets the length of the instruction, 0-15 bytes. This is just informational. If you modify the instruction
	/// or create a new one, this method could return the wrong value.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn len(&self) -> usize {
		((self.code_flags >> CodeFlags::INSTR_LENGTH_SHIFT) & CodeFlags::INSTR_LENGTH_MASK) as usize
	}

	/// Sets the length of the instruction, 0-15 bytes. This is just informational. If you modify the instruction
	/// or create a new one, this method could return the wrong value.
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_len(&mut self, new_value: usize) {
		self.code_flags = (self.code_flags & !(CodeFlags::INSTR_LENGTH_MASK << CodeFlags::INSTR_LENGTH_SHIFT))
			| (((new_value as u32) & CodeFlags::INSTR_LENGTH_MASK) << CodeFlags::INSTR_LENGTH_SHIFT);
	}

	/// `true` if the instruction has the `XACQUIRE` prefix (`F2`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_xacquire_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::XACQUIRE_PREFIX) != 0
	}

	/// `true` if the instruction has the `XACQUIRE` prefix (`F2`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_xacquire_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::XACQUIRE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::XACQUIRE_PREFIX;
		}
	}

	/// `true` if the instruction has the `XRELEASE` prefix (`F3`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_xrelease_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::XRELEASE_PREFIX) != 0
	}

	/// `true` if the instruction has the `XRELEASE` prefix (`F3`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_xrelease_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::XRELEASE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::XRELEASE_PREFIX;
		}
	}

	/// `true` if the instruction has the `REPE` or `REP` prefix (`F3`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_rep_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::REPE_PREFIX) != 0
	}

	/// `true` if the instruction has the `REPE` or `REP` prefix (`F3`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_rep_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::REPE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::REPE_PREFIX;
		}
	}

	/// `true` if the instruction has the `REPE` or `REP` prefix (`F3`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_repe_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::REPE_PREFIX) != 0
	}

	/// `true` if the instruction has the `REPE` or `REP` prefix (`F3`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_repe_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::REPE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::REPE_PREFIX;
		}
	}

	/// `true` if the instruction has the `REPNE` prefix (`F2`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_repne_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::REPNE_PREFIX) != 0
	}

	/// `true` if the instruction has the `REPNE` prefix (`F2`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_repne_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::REPNE_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::REPNE_PREFIX;
		}
	}

	/// `true` if the instruction has the `LOCK` prefix (`F0`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_lock_prefix(&self) -> bool {
		(self.code_flags & CodeFlags::LOCK_PREFIX) != 0
	}

	/// `true` if the instruction has the `LOCK` prefix (`F0`)
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_has_lock_prefix(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::LOCK_PREFIX;
		} else {
			self.code_flags &= !CodeFlags::LOCK_PREFIX;
		}
	}

	/// Gets operand #0's kind if the operand exists (see [`op_count()`] and [`op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`op_kind()`]: #method.op_kind
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op0_kind(&self) -> OpKind {
		unsafe { mem::transmute((self.op_kind_flags & OpKindFlags::OP_KIND_MASK) as u8) }
	}

	/// Sets operand #0's kind if the operand exists (see [`op_count()`] and [`set_op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`set_op_kind()`]: #method.set_op_kind
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_op0_kind(&mut self, new_value: OpKind) {
		self.op_kind_flags = (self.op_kind_flags & !OpKindFlags::OP_KIND_MASK) | ((new_value as u32) & OpKindFlags::OP_KIND_MASK);
	}

	/// Gets operand #1's kind if the operand exists (see [`op_count()`] and [`op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`op_kind()`]: #method.op_kind
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op1_kind(&self) -> OpKind {
		unsafe { mem::transmute(((self.op_kind_flags >> OpKindFlags::OP1_KIND_SHIFT) & OpKindFlags::OP_KIND_MASK) as u8) }
	}

	/// Sets operand #1's kind if the operand exists (see [`op_count()`] and [`set_op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`set_op_kind()`]: #method.set_op_kind
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_op1_kind(&mut self, new_value: OpKind) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::OP_KIND_MASK << OpKindFlags::OP1_KIND_SHIFT))
			| (((new_value as u32) & OpKindFlags::OP_KIND_MASK) << OpKindFlags::OP1_KIND_SHIFT);
	}

	/// Gets operand #2's kind if the operand exists (see [`op_count()`] and [`op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`op_kind()`]: #method.op_kind
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op2_kind(&self) -> OpKind {
		unsafe { mem::transmute(((self.op_kind_flags >> OpKindFlags::OP2_KIND_SHIFT) & OpKindFlags::OP_KIND_MASK) as u8) }
	}

	/// Sets operand #2's kind if the operand exists (see [`op_count()`] and [`set_op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`set_op_kind()`]: #method.set_op_kind
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_op2_kind(&mut self, new_value: OpKind) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::OP_KIND_MASK << OpKindFlags::OP2_KIND_SHIFT))
			| (((new_value as u32) & OpKindFlags::OP_KIND_MASK) << OpKindFlags::OP2_KIND_SHIFT);
	}

	/// Gets operand #3's kind if the operand exists (see [`op_count()`] and [`op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`op_kind()`]: #method.op_kind
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op3_kind(&self) -> OpKind {
		unsafe { mem::transmute(((self.op_kind_flags >> OpKindFlags::OP3_KIND_SHIFT) & OpKindFlags::OP_KIND_MASK) as u8) }
	}

	/// Sets operand #3's kind if the operand exists (see [`op_count()`] and [`set_op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`set_op_kind()`]: #method.set_op_kind
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[inline]
	pub fn set_op3_kind(&mut self, new_value: OpKind) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::OP_KIND_MASK << OpKindFlags::OP3_KIND_SHIFT))
			| (((new_value as u32) & OpKindFlags::OP_KIND_MASK) << OpKindFlags::OP3_KIND_SHIFT);
	}

	/// Gets operand #4's kind if the operand exists (see [`op_count()`] and [`op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`op_kind()`]: #method.op_kind
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::unused_self))]
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op4_kind(&self) -> OpKind {
		OpKind::Immediate8
	}

	/// Sets operand #4's kind if the operand exists (see [`op_count()`] and [`set_op_kind()`])
	///
	/// [`op_count()`]: #method.op_count
	/// [`set_op_kind()`]: #method.set_op_kind
	///
	/// # Panics
	///
	/// Panics if `new_value` is invalid.
	///
	/// # Arguments
	///
	/// * `new_value`: new value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::unused_self))]
	#[inline]
	pub fn set_op4_kind(&mut self, new_value: OpKind) {
		if new_value != OpKind::Immediate8 {
			panic!();
		}
	}

	/// Gets an operand's kind if it exists (see [`op_count()`])
	///
	/// [`op_count()`]: #method.op_count
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // add [rax],ebx
	/// let bytes = b"\x01\x18";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert_eq!(2, instr.op_count());
	/// assert_eq!(OpKind::Memory, instr.op_kind(0));
	/// assert_eq!(Register::RAX, instr.memory_base());
	/// assert_eq!(Register::None, instr.memory_index());
	/// assert_eq!(OpKind::Register, instr.op_kind(1));
	/// assert_eq!(Register::EBX, instr.op_register(1));
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn op_kind(&self, operand: u32) -> OpKind {
		match operand {
			0 => self.op0_kind(),
			1 => self.op1_kind(),
			2 => self.op2_kind(),
			3 => self.op3_kind(),
			4 => self.op4_kind(),
			_ => panic!(),
		}
	}

	/// Sets an operand's kind
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `op_kind`: Operand kind
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_op_kind(&mut self, operand: u32, op_kind: OpKind) {
		match operand {
			0 => self.set_op0_kind(op_kind),
			1 => self.set_op1_kind(op_kind),
			2 => self.set_op2_kind(op_kind),
			3 => self.set_op3_kind(op_kind),
			4 => self.set_op4_kind(op_kind),
			_ => panic!(),
		}
	}

	/// Checks if the instruction has a segment override prefix, see [`segment_prefix()`]
	///
	/// [`segment_prefix()`]: #method.segment_prefix
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_segment_prefix(&self) -> bool {
		(((self.memory_flags as u32) >> MemoryFlags::SEGMENT_PREFIX_SHIFT) & MemoryFlags::SEGMENT_PREFIX_MASK).wrapping_sub(1) < 6
	}

	/// Gets the segment override prefix or [`Register::None`] if none. See also [`memory_segment()`].
	/// Use this method if the operand has kind [`OpKind::Memory`], [`OpKind::Memory64`],
	/// [`OpKind::MemorySegSI`], [`OpKind::MemorySegESI`], [`OpKind::MemorySegRSI`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`memory_segment()`]: #method.memory_segment
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	/// [`OpKind::Memory64`]: enum.OpKind.html#variant.Memory64
	/// [`OpKind::MemorySegSI`]: enum.OpKind.html#variant.MemorySegSI
	/// [`OpKind::MemorySegESI`]: enum.OpKind.html#variant.MemorySegESI
	/// [`OpKind::MemorySegESI`]: enum.OpKind.html#variant.MemorySegESI
	/// [`OpKind::MemorySegRSI`]: enum.OpKind.html#variant.MemorySegRSI
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn segment_prefix(&self) -> Register {
		let index = (((self.memory_flags as u32) >> MemoryFlags::SEGMENT_PREFIX_SHIFT) & MemoryFlags::SEGMENT_PREFIX_MASK).wrapping_sub(1);
		if index < 6 {
			unsafe { mem::transmute((Register::ES as u32 + index) as u8) }
		} else {
			Register::None
		}
	}

	/// Sets the segment override prefix or [`Register::None`] if none. See also [`memory_segment()`].
	/// Use this method if the operand has kind [`OpKind::Memory`], [`OpKind::Memory64`],
	/// [`OpKind::MemorySegSI`], [`OpKind::MemorySegESI`], [`OpKind::MemorySegRSI`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`memory_segment()`]: #method.memory_segment
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	/// [`OpKind::Memory64`]: enum.OpKind.html#variant.Memory64
	/// [`OpKind::MemorySegSI`]: enum.OpKind.html#variant.MemorySegSI
	/// [`OpKind::MemorySegESI`]: enum.OpKind.html#variant.MemorySegESI
	/// [`OpKind::MemorySegESI`]: enum.OpKind.html#variant.MemorySegESI
	/// [`OpKind::MemorySegRSI`]: enum.OpKind.html#variant.MemorySegRSI
	///
	/// # Arguments
	///
	/// * `new_value`: Segment register prefix
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_segment_prefix(&mut self, new_value: Register) {
		let enc_value =
			if new_value == Register::None { 0 } else { (((new_value as u32) - (Register::ES as u32)) + 1) & MemoryFlags::SEGMENT_PREFIX_MASK };
		self.memory_flags = (((self.memory_flags as u32) & !(MemoryFlags::SEGMENT_PREFIX_MASK << MemoryFlags::SEGMENT_PREFIX_SHIFT))
			| (enc_value << MemoryFlags::SEGMENT_PREFIX_SHIFT)) as u16;
	}

	/// Gets the effective segment register used to reference the memory location.
	/// Use this method if the operand has kind [`OpKind::Memory`], [`OpKind::Memory64`],
	/// [`OpKind::MemorySegSI`], [`OpKind::MemorySegESI`], [`OpKind::MemorySegRSI`]
	///
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	/// [`OpKind::Memory64`]: enum.OpKind.html#variant.Memory64
	/// [`OpKind::MemorySegSI`]: enum.OpKind.html#variant.MemorySegSI
	/// [`OpKind::MemorySegESI`]: enum.OpKind.html#variant.MemorySegESI
	/// [`OpKind::MemorySegRSI`]: enum.OpKind.html#variant.MemorySegRSI
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn memory_segment(&self) -> Register {
		let seg_reg = self.segment_prefix();
		if seg_reg != Register::None {
			return seg_reg;
		}
		match self.memory_base() {
			Register::BP | Register::EBP | Register::ESP | Register::RBP | Register::RSP => Register::SS,
			_ => Register::DS,
		}
	}

	/// Gets the size of the memory displacement in bytes. Valid values are `0`, `1` (16/32/64-bit), `2` (16-bit), `4` (32-bit), `8` (64-bit).
	/// Note that the return value can be 1 and [`memory_displacement()`] may still not fit in
	/// a signed byte if it's an EVEX encoded instruction.
	/// Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`memory_displacement()`]: #method.memory_displacement
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_displ_size(&self) -> u32 {
		let size = ((self.memory_flags as u32) >> MemoryFlags::DISPL_SIZE_SHIFT) & MemoryFlags::DISPL_SIZE_MASK;
		if size <= 2 {
			size
		} else if size == 3 {
			4
		} else {
			8
		}
	}

	/// Sets the size of the memory displacement in bytes. Valid values are `0`, `1` (16/32/64-bit), `2` (16-bit), `4` (32-bit), `8` (64-bit).
	/// Note that the return value can be 1 and [`memory_displacement()`] may still not fit in
	/// a signed byte if it's an EVEX encoded instruction.
	/// Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`memory_displacement()`]: #method.memory_displacement
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	///
	/// # Arguments
	///
	/// * `new_value`: Displacement size
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_memory_displ_size(&mut self, new_value: u32) {
		let enc_value = match new_value {
			0 => 0,
			1 => 1,
			2 => 2,
			4 => 3,
			_ => 4,
		};
		self.memory_flags = (((self.memory_flags as u32) & !(MemoryFlags::DISPL_SIZE_MASK << MemoryFlags::DISPL_SIZE_SHIFT))
			| (enc_value << MemoryFlags::DISPL_SIZE_SHIFT)) as u16;
	}

	/// `true` if the data is broadcasted (EVEX instructions only)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_broadcast(&self) -> bool {
		(self.memory_flags & (MemoryFlags::BROADCAST as u16)) != 0
	}

	/// Sets the is broadcast flag (EVEX instructions only)
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_is_broadcast(&mut self, new_value: bool) {
		if new_value {
			self.memory_flags |= MemoryFlags::BROADCAST as u16;
		} else {
			self.memory_flags &= !(MemoryFlags::BROADCAST as u16);
		}
	}

	/// Gets the size of the memory location that is referenced by the operand. See also [`is_broadcast()`].
	/// Use this method if the operand has kind [`OpKind::Memory`], [`OpKind::Memory64`],
	/// [`OpKind::MemorySegSI`], [`OpKind::MemorySegESI`], [`OpKind::MemorySegRSI`],
	/// [`OpKind::MemoryESDI`], [`OpKind::MemoryESEDI`], [`OpKind::MemoryESRDI`]
	///
	/// [`is_broadcast()`]: #method.is_broadcast
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	/// [`OpKind::Memory64`]: enum.OpKind.html#variant.Memory64
	/// [`OpKind::MemorySegSI`]: enum.OpKind.html#variant.MemorySegSI
	/// [`OpKind::MemorySegESI`]: enum.OpKind.html#variant.MemorySegESI
	/// [`OpKind::MemorySegRSI`]: enum.OpKind.html#variant.MemorySegRSI
	/// [`OpKind::MemoryESDI`]: enum.OpKind.html#variant.MemoryESDI
	/// [`OpKind::MemoryESEDI`]: enum.OpKind.html#variant.MemoryESEDI
	/// [`OpKind::MemoryESRDI`]: enum.OpKind.html#variant.MemoryESRDI
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_size(&self) -> MemorySize {
		let mut index = self.code() as usize;
		if self.is_broadcast() {
			index += IcedConstants::NUMBER_OF_CODE_VALUES;
		}
		unsafe { *instruction_memory_sizes::SIZES.get_unchecked(index) }
	}

	/// Gets the index register scale value, valid values are `*1`, `*2`, `*4`, `*8`. Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_index_scale(&self) -> u32 {
		1 << (self.memory_flags as u32 & MemoryFlags::SCALE_MASK)
	}

	/// Sets the index register scale value, valid values are `*1`, `*2`, `*4`, `*8`. Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	///
	/// # Arguments
	///
	/// * `new_value`: New value (1, 2, 4 or 8)
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_memory_index_scale(&mut self, new_value: u32) {
		match new_value {
			1 => self.memory_flags &= !3,
			2 => self.memory_flags = (self.memory_flags & !(MemoryFlags::SCALE_MASK as u16)) | 1,
			4 => self.memory_flags = (self.memory_flags & !(MemoryFlags::SCALE_MASK as u16)) | 2,
			_ => {
				debug_assert_eq!(8, new_value);
				self.memory_flags |= 3;
			}
		}
	}

	/// Gets the memory operand's displacement. This should be sign extended to 64 bits if it's 64-bit addressing (see [`memory_displacement64()`]).
	/// Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`memory_displacement64()`]: #method.memory_displacement64
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_displacement(&self) -> u32 {
		self.mem_displ
	}

	/// Gets the memory operand's displacement. This should be sign extended to 64 bits if it's 64-bit addressing (see [`memory_displacement64()`]).
	/// Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`memory_displacement64()`]: #method.memory_displacement64
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_memory_displacement(&mut self, new_value: u32) {
		self.mem_displ = new_value;
	}

	/// Gets the memory operand's displacement sign extended to 64 bits.
	/// Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_displacement64(&self) -> u64 {
		self.mem_displ as i32 as u64
	}

	/// Gets an operand's immediate value, or `None` if the operand is not immediate
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn try_immediate(&self, operand: u32) -> Option<u64> {
		Some(match self.op_kind(operand) {
			OpKind::Immediate8 => self.immediate8() as u64,
			OpKind::Immediate8_2nd => self.immediate8_2nd() as u64,
			OpKind::Immediate16 => self.immediate16() as u64,
			OpKind::Immediate32 => self.immediate32() as u64,
			OpKind::Immediate64 => self.immediate64(),
			OpKind::Immediate8to16 => self.immediate8to16() as u64,
			OpKind::Immediate8to32 => self.immediate8to32() as u64,
			OpKind::Immediate8to64 => self.immediate8to64() as u64,
			OpKind::Immediate32to64 => self.immediate32to64() as u64,
			_ => return None,
		})
	}

	/// Gets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or not immediate.
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate(&self, operand: u32) -> u64 {
		self.try_immediate(operand).unwrap()
	}

	/// Sets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or if it's not an immediate operand
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: Immediate
	#[inline]
	pub fn set_immediate_i32(&mut self, operand: u32, new_value: i32) {
		self.set_immediate_u64(operand, new_value as u64);
	}

	/// Sets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or if it's not an immediate operand
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: Immediate
	#[inline]
	pub fn set_immediate_u32(&mut self, operand: u32, new_value: u32) {
		self.set_immediate_u64(operand, new_value as u64);
	}

	/// Sets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or if it's not an immediate operand
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: Immediate
	#[inline]
	pub fn set_immediate_i64(&mut self, operand: u32, new_value: i64) {
		self.set_immediate_u64(operand, new_value as u64);
	}

	/// Sets an operand's immediate value
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid or if it's not an immediate operand
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: Immediate
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_immediate_u64(&mut self, operand: u32, new_value: u64) {
		match self.op_kind(operand) {
			OpKind::Immediate8 | OpKind::Immediate8to16 | OpKind::Immediate8to32 | OpKind::Immediate8to64 => self.immediate = new_value as u8 as u32,
			OpKind::Immediate8_2nd => self.mem_displ = new_value as u8 as u32,
			OpKind::Immediate16 => self.immediate = new_value as u16 as u32,
			OpKind::Immediate32to64 | OpKind::Immediate32 => self.immediate = new_value as u32,
			OpKind::Immediate64 => self.set_immediate64(new_value),
			_ => panic!(),
		}
	}

	/// Gets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8`]
	///
	/// [`OpKind::Immediate8`]: enum.OpKind.html#variant.Immediate8
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8(&self) -> u8 {
		self.immediate as u8
	}

	/// Sets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8`]
	///
	/// [`OpKind::Immediate8`]: enum.OpKind.html#variant.Immediate8
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8(&mut self, new_value: u8) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8_2nd`]
	///
	/// [`OpKind::Immediate8_2nd`]: enum.OpKind.html#variant.Immediate8_2nd
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8_2nd(&self) -> u8 {
		self.mem_displ as u8
	}

	/// Sets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8_2nd`]
	///
	/// [`OpKind::Immediate8_2nd`]: enum.OpKind.html#variant.Immediate8_2nd
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8_2nd(&mut self, new_value: u8) {
		self.mem_displ = new_value as u32;
	}

	/// Gets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate16`]
	///
	/// [`OpKind::Immediate16`]: enum.OpKind.html#variant.Immediate16
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate16(&self) -> u16 {
		self.immediate as u16
	}

	/// Sets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate16`]
	///
	/// [`OpKind::Immediate16`]: enum.OpKind.html#variant.Immediate16
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate16(&mut self, new_value: u16) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate32`]
	///
	/// [`OpKind::Immediate32`]: enum.OpKind.html#variant.Immediate32
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate32(&self) -> u32 {
		self.immediate
	}

	/// Sets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate32`]
	///
	/// [`OpKind::Immediate32`]: enum.OpKind.html#variant.Immediate32
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate32(&mut self, new_value: u32) {
		self.immediate = new_value;
	}

	/// Gets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate64`]
	///
	/// [`OpKind::Immediate64`]: enum.OpKind.html#variant.Immediate64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate64(&self) -> u64 {
		((self.mem_displ as u64) << 32) | (self.immediate as u64)
	}

	/// Sets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate64`]
	///
	/// [`OpKind::Immediate64`]: enum.OpKind.html#variant.Immediate64
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate64(&mut self, new_value: u64) {
		self.immediate = new_value as u32;
		self.mem_displ = (new_value >> 32) as u32;
	}

	/// Gets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8to16`]
	///
	/// [`OpKind::Immediate8to16`]: enum.OpKind.html#variant.Immediate8to16
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8to16(&self) -> i16 {
		self.immediate as i8 as i16
	}

	/// Sets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8to16`]
	///
	/// [`OpKind::Immediate8to16`]: enum.OpKind.html#variant.Immediate8to16
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8to16(&mut self, new_value: i16) {
		self.immediate = new_value as i8 as u32;
	}

	/// Gets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8to32`]
	///
	/// [`OpKind::Immediate8to32`]: enum.OpKind.html#variant.Immediate8to32
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8to32(&self) -> i32 {
		self.immediate as i8 as i32
	}

	/// Sets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8to32`]
	///
	/// [`OpKind::Immediate8to32`]: enum.OpKind.html#variant.Immediate8to32
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8to32(&mut self, new_value: i32) {
		self.immediate = new_value as i8 as u32;
	}

	/// Gets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8to64`]
	///
	/// [`OpKind::Immediate8to64`]: enum.OpKind.html#variant.Immediate8to64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate8to64(&self) -> i64 {
		self.immediate as i8 as i64
	}

	/// Sets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate8to64`]
	///
	/// [`OpKind::Immediate8to64`]: enum.OpKind.html#variant.Immediate8to64
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate8to64(&mut self, new_value: i64) {
		self.immediate = new_value as i8 as u32;
	}

	/// Gets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate32to64`]
	///
	/// [`OpKind::Immediate32to64`]: enum.OpKind.html#variant.Immediate32to64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn immediate32to64(&self) -> i64 {
		self.immediate as i32 as i64
	}

	/// Sets the operand's immediate value. Use this method if the operand has kind [`OpKind::Immediate32to64`]
	///
	/// [`OpKind::Immediate32to64`]: enum.OpKind.html#variant.Immediate32to64
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_immediate32to64(&mut self, new_value: i64) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's 64-bit address value. Use this method if the operand has kind [`OpKind::Memory64`]
	///
	/// [`OpKind::Memory64`]: enum.OpKind.html#variant.Memory64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_address64(&self) -> u64 {
		((self.mem_displ as u64) << 32) | self.immediate as u64
	}

	/// Sets the operand's 64-bit address value. Use this method if the operand has kind [`OpKind::Memory64`]
	///
	/// [`OpKind::Memory64`]: enum.OpKind.html#variant.Memory64
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_memory_address64(&mut self, new_value: u64) {
		self.immediate = new_value as u32;
		self.mem_displ = (new_value >> 32) as u32;
	}

	/// Gets the operand's branch target. Use this method if the operand has kind [`OpKind::NearBranch16`]
	///
	/// [`OpKind::NearBranch16`]: enum.OpKind.html#variant.NearBranch16
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn near_branch16(&self) -> u16 {
		self.immediate as u16
	}

	/// Sets the operand's branch target. Use this method if the operand has kind [`OpKind::NearBranch16`]
	///
	/// [`OpKind::NearBranch16`]: enum.OpKind.html#variant.NearBranch16
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_near_branch16(&mut self, new_value: u16) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's branch target. Use this method if the operand has kind [`OpKind::NearBranch32`]
	///
	/// [`OpKind::NearBranch32`]: enum.OpKind.html#variant.NearBranch32
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn near_branch32(&self) -> u32 {
		self.immediate
	}

	/// Sets the operand's branch target. Use this method if the operand has kind [`OpKind::NearBranch32`]
	///
	/// [`OpKind::NearBranch32`]: enum.OpKind.html#variant.NearBranch32
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_near_branch32(&mut self, new_value: u32) {
		self.immediate = new_value;
	}

	/// Gets the operand's branch target. Use this method if the operand has kind [`OpKind::NearBranch64`]
	///
	/// [`OpKind::NearBranch64`]: enum.OpKind.html#variant.NearBranch64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn near_branch64(&self) -> u64 {
		((self.mem_displ as u64) << 32) | self.immediate as u64
	}

	/// Sets the operand's branch target. Use this method if the operand has kind [`OpKind::NearBranch64`]
	///
	/// [`OpKind::NearBranch64`]: enum.OpKind.html#variant.NearBranch64
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_near_branch64(&mut self, new_value: u64) {
		self.immediate = new_value as u32;
		self.mem_displ = (new_value >> 32) as u32;
	}

	/// Gets the near branch target if it's a `CALL`/`JMP`/`Jcc` near branch instruction
	/// (i.e., if [`op0_kind()`] is [`OpKind::NearBranch16`], [`OpKind::NearBranch32`] or [`OpKind::NearBranch64`])
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`OpKind::NearBranch16`]: enum.OpKind.html#variant.NearBranch16
	/// [`OpKind::NearBranch32`]: enum.OpKind.html#variant.NearBranch32
	/// [`OpKind::NearBranch64`]: enum.OpKind.html#variant.NearBranch64
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn near_branch_target(&self) -> u64 {
		match self.op0_kind() {
			OpKind::NearBranch16 => self.near_branch16() as u64,
			OpKind::NearBranch32 => self.near_branch32() as u64,
			OpKind::NearBranch64 => self.near_branch64(),
			_ => 0,
		}
	}

	/// Gets the operand's branch target. Use this method if the operand has kind [`OpKind::FarBranch16`]
	///
	/// [`OpKind::FarBranch16`]: enum.OpKind.html#variant.FarBranch16
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn far_branch16(&self) -> u16 {
		self.immediate as u16
	}

	/// Sets the operand's branch target. Use this method if the operand has kind [`OpKind::FarBranch16`]
	///
	/// [`OpKind::FarBranch16`]: enum.OpKind.html#variant.FarBranch16
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_far_branch16(&mut self, new_value: u16) {
		self.immediate = new_value as u32;
	}

	/// Gets the operand's branch target. Use this method if the operand has kind [`OpKind::FarBranch32`]
	///
	/// [`OpKind::FarBranch32`]: enum.OpKind.html#variant.FarBranch32
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn far_branch32(&self) -> u32 {
		self.immediate
	}

	/// Sets the operand's branch target. Use this method if the operand has kind [`OpKind::FarBranch32`]
	///
	/// [`OpKind::FarBranch32`]: enum.OpKind.html#variant.FarBranch32
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_far_branch32(&mut self, new_value: u32) {
		self.immediate = new_value;
	}

	/// Gets the operand's branch target selector. Use this method if the operand has kind [`OpKind::FarBranch16`] or [`OpKind::FarBranch32`]
	///
	/// [`OpKind::FarBranch16`]: enum.OpKind.html#variant.FarBranch16
	/// [`OpKind::FarBranch32`]: enum.OpKind.html#variant.FarBranch32
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn far_branch_selector(&self) -> u16 {
		self.mem_displ as u16
	}

	/// Sets the operand's branch target selector. Use this method if the operand has kind [`OpKind::FarBranch16`] or [`OpKind::FarBranch32`]
	///
	/// [`OpKind::FarBranch16`]: enum.OpKind.html#variant.FarBranch16
	/// [`OpKind::FarBranch32`]: enum.OpKind.html#variant.FarBranch32
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_far_branch_selector(&mut self, new_value: u16) {
		self.mem_displ = new_value as u32;
	}

	/// Gets the memory operand's base register or [`Register::None`] if none. Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_base(&self) -> Register {
		unsafe { mem::transmute(self.mem_base_reg) }
	}

	/// Sets the memory operand's base register or [`Register::None`] if none. Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_memory_base(&mut self, new_value: Register) {
		self.mem_base_reg = new_value as u8;
	}

	/// Gets the memory operand's index register or [`Register::None`] if none. Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn memory_index(&self) -> Register {
		unsafe { mem::transmute(self.mem_index_reg) }
	}

	/// Sets the memory operand's index register or [`Register::None`] if none. Use this method if the operand has kind [`OpKind::Memory`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Memory`]: enum.OpKind.html#variant.Memory
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_memory_index(&mut self, new_value: Register) {
		self.mem_index_reg = new_value as u8;
	}

	/// Gets operand #0's register value. Use this method if operand #0 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op0_register(&self) -> Register {
		unsafe { mem::transmute(self.reg0) }
	}

	/// Sets operand #0's register value. Use this method if operand #0 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_op0_register(&mut self, new_value: Register) {
		self.reg0 = new_value as u8;
	}

	/// Gets operand #1's register value. Use this method if operand #1 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op1_register(&self) -> Register {
		unsafe { mem::transmute(self.reg1) }
	}

	/// Sets operand #1's register value. Use this method if operand #1 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_op1_register(&mut self, new_value: Register) {
		self.reg1 = new_value as u8;
	}

	/// Gets operand #2's register value. Use this method if operand #2 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op2_register(&self) -> Register {
		unsafe { mem::transmute(self.reg2) }
	}

	/// Sets operand #2's register value. Use this method if operand #2 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_op2_register(&mut self, new_value: Register) {
		self.reg2 = new_value as u8;
	}

	/// Gets operand #3's register value. Use this method if operand #3 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op3_register(&self) -> Register {
		unsafe { mem::transmute(self.reg3) }
	}

	/// Sets operand #3's register value. Use this method if operand #3 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_op3_register(&mut self, new_value: Register) {
		self.reg3 = new_value as u8;
	}

	/// Gets operand #4's register value. Use this method if operand #4 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::unused_self))]
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op4_register(&self) -> Register {
		Register::None
	}

	/// Sets operand #4's register value. Use this method if operand #4 ([`op0_kind()`]) has kind [`OpKind::Register`], see [`op_count()`] and [`op_register()`]
	///
	/// [`op0_kind()`]: #method.op0_kind
	/// [`op_count()`]: #method.op_count
	/// [`op_register()`]: #method.op_register
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	///
	/// # Panics
	///
	/// Panics if `new_value` is invalid
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::unused_self))]
	#[inline]
	pub fn set_op4_register(&mut self, new_value: Register) {
		if new_value != Register::None {
			panic!();
		}
	}

	/// Gets the operand's register value. Use this method if the operand has kind [`OpKind::Register`]
	///
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // add [rax],ebx
	/// let bytes = b"\x01\x18";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert_eq!(2, instr.op_count());
	/// assert_eq!(OpKind::Memory, instr.op_kind(0));
	/// assert_eq!(OpKind::Register, instr.op_kind(1));
	/// assert_eq!(Register::EBX, instr.op_register(1));
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn op_register(&self, operand: u32) -> Register {
		match operand {
			0 => self.op0_register(),
			1 => self.op1_register(),
			2 => self.op2_register(),
			3 => self.op3_register(),
			4 => self.op4_register(),
			_ => panic!(),
		}
	}

	/// Sets the operand's register value. Use this method if the operand has kind [`OpKind::Register`]
	///
	/// [`OpKind::Register`]: enum.OpKind.html#variant.Register
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, 0-4
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_op_register(&mut self, operand: u32, new_value: Register) {
		match operand {
			0 => self.set_op0_register(new_value),
			1 => self.set_op1_register(new_value),
			2 => self.set_op2_register(new_value),
			3 => self.set_op3_register(new_value),
			4 => self.set_op4_register(new_value),
			_ => panic!(),
		}
	}

	/// Gets the op mask register ([`Register::K1`] - [`Register::K7`]) or [`Register::None`] if none
	///
	/// [`Register::K1`]: enum.Register.html#variant.K1
	/// [`Register::K7`]: enum.Register.html#variant.K7
	/// [`Register::None`]: enum.Register.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op_mask(&self) -> Register {
		let r = (self.code_flags >> CodeFlags::OP_MASK_SHIFT) & CodeFlags::OP_MASK_MASK;
		if r == 0 {
			Register::None
		} else {
			unsafe { mem::transmute((r + Register::K0 as u32) as u8) }
		}
	}

	/// Sets the op mask register ([`Register::K1`] - [`Register::K7`]) or [`Register::None`] if none
	///
	/// [`Register::K1`]: enum.Register.html#variant.K1
	/// [`Register::K7`]: enum.Register.html#variant.K7
	/// [`Register::None`]: enum.Register.html#variant.None
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_op_mask(&mut self, new_value: Register) {
		let r = if new_value == Register::None { 0 } else { (new_value as u32 - Register::K0 as u32) & CodeFlags::OP_MASK_MASK };
		self.code_flags = (self.code_flags & !(CodeFlags::OP_MASK_MASK << CodeFlags::OP_MASK_SHIFT)) | (r << CodeFlags::OP_MASK_SHIFT);
	}

	/// Checks if there's an op mask register ([`op_mask()`])
	///
	/// [`op_mask()`]: #method.op_mask
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn has_op_mask(&self) -> bool {
		(self.code_flags & (CodeFlags::OP_MASK_MASK << CodeFlags::OP_MASK_SHIFT)) != 0
	}

	/// `true` if zeroing-masking, `false` if merging-masking.
	/// Only used by most EVEX encoded instructions that use op mask registers.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn zeroing_masking(&self) -> bool {
		(self.code_flags & CodeFlags::ZEROING_MASKING) != 0
	}

	/// `true` if zeroing-masking, `false` if merging-masking.
	/// Only used by most EVEX encoded instructions that use op mask registers.
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_zeroing_masking(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::ZEROING_MASKING;
		} else {
			self.code_flags &= !CodeFlags::ZEROING_MASKING;
		}
	}

	/// `true` if merging-masking, `false` if zeroing-masking.
	/// Only used by most EVEX encoded instructions that use op mask registers.
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn merging_masking(&self) -> bool {
		(self.code_flags & CodeFlags::ZEROING_MASKING) == 0
	}

	/// `true` if merging-masking, `false` if zeroing-masking.
	/// Only used by most EVEX encoded instructions that use op mask registers.
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_merging_masking(&mut self, new_value: bool) {
		if new_value {
			self.code_flags &= !CodeFlags::ZEROING_MASKING;
		} else {
			self.code_flags |= CodeFlags::ZEROING_MASKING;
		}
	}

	/// Gets the rounding control ([`suppress_all_exceptions()`] is implied but still returns `false`)
	/// or [`RoundingControl::None`] if the instruction doesn't use it.
	///
	/// [`suppress_all_exceptions()`]: #method.suppress_all_exceptions
	/// [`RoundingControl::None`]: enum.RoundingControl.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rounding_control(&self) -> RoundingControl {
		unsafe { mem::transmute(((self.code_flags >> CodeFlags::ROUNDING_CONTROL_SHIFT) & CodeFlags::ROUNDING_CONTROL_MASK) as u8) }
	}

	/// Sets the rounding control ([`suppress_all_exceptions()`] is implied but still returns `false`)
	/// or [`RoundingControl::None`] if the instruction doesn't use it.
	///
	/// [`suppress_all_exceptions()`]: #method.suppress_all_exceptions
	/// [`RoundingControl::None`]: enum.RoundingControl.html#variant.None
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_rounding_control(&mut self, new_value: RoundingControl) {
		self.code_flags = (self.code_flags & !(CodeFlags::ROUNDING_CONTROL_MASK << CodeFlags::ROUNDING_CONTROL_SHIFT))
			| ((new_value as u32 & CodeFlags::ROUNDING_CONTROL_MASK) << CodeFlags::ROUNDING_CONTROL_SHIFT);
	}

	/// Gets the number of elements in a `db`/`dw`/`dd`/`dq` directive.
	/// Can only be called if [`code()`] is [`Code::DeclareByte`], [`Code::DeclareWord`], [`Code::DeclareDword`], [`Code::DeclareQword`]
	///
	/// [`code()`]: #method.code
	/// [`Code::DeclareByte`]: enum.Code.html#variant.DeclareByte
	/// [`Code::DeclareWord`]: enum.Code.html#variant.DeclareWord
	/// [`Code::DeclareDword`]: enum.Code.html#variant.DeclareDword
	/// [`Code::DeclareQword`]: enum.Code.html#variant.DeclareQword
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn declare_data_len(&self) -> usize {
		(((self.op_kind_flags >> OpKindFlags::DATA_LENGTH_SHIFT) & OpKindFlags::DATA_LENGTH_MASK) + 1) as usize
	}

	/// Sets the number of elements in a `db`/`dw`/`dd`/`dq` directive.
	/// Can only be called if [`code()`] is [`Code::DeclareByte`], [`Code::DeclareWord`], [`Code::DeclareDword`], [`Code::DeclareQword`]
	///
	/// [`code()`]: #method.code
	/// [`Code::DeclareByte`]: enum.Code.html#variant.DeclareByte
	/// [`Code::DeclareWord`]: enum.Code.html#variant.DeclareWord
	/// [`Code::DeclareDword`]: enum.Code.html#variant.DeclareDword
	/// [`Code::DeclareQword`]: enum.Code.html#variant.DeclareQword
	///
	/// # Arguments
	///
	/// * `new_value`: New value: `db`: 1-16; `dw`: 1-8; `dd`: 1-4; `dq`: 1-2
	#[inline]
	pub fn set_declare_data_len(&mut self, new_value: usize) {
		self.op_kind_flags = (self.op_kind_flags & !(OpKindFlags::DATA_LENGTH_MASK << OpKindFlags::DATA_LENGTH_SHIFT))
			| ((((new_value as u32) - 1) & OpKindFlags::DATA_LENGTH_MASK) << OpKindFlags::DATA_LENGTH_SHIFT);
	}

	/// Sets a new `db` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareByte`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareByte`]: enum.Code.html#variant.DeclareByte
	///
	/// # Panics
	///
	/// - Panics if `index` is invalid
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `index`: Index (0-15)
	/// * `new_value`: New value
	#[inline]
	pub fn set_declare_byte_value_i8(&mut self, index: usize, new_value: i8) {
		self.set_declare_byte_value(index, new_value as u8)
	}

	/// Sets a new `db` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareByte`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareByte`]: enum.Code.html#variant.DeclareByte
	///
	/// # Panics
	///
	/// - Panics if `index` is invalid
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `index`: Index (0-15)
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_declare_byte_value(&mut self, index: usize, new_value: u8) {
		if cfg!(feature = "db") {
			match index {
				0 => self.reg0 = new_value,
				1 => self.reg1 = new_value,
				2 => self.reg2 = new_value,
				3 => self.reg3 = new_value,
				4 => self.immediate = (self.immediate & 0xFFFF_FF00) | new_value as u32,
				5 => self.immediate = (self.immediate & 0xFFFF_00FF) | ((new_value as u32) << 8),
				6 => self.immediate = (self.immediate & 0xFF00_FFFF) | ((new_value as u32) << 16),
				7 => self.immediate = (self.immediate & 0x00FF_FFFF) | ((new_value as u32) << 24),
				8 => self.mem_displ = (self.mem_displ & 0xFFFF_FF00) | new_value as u32,
				9 => self.mem_displ = (self.mem_displ & 0xFFFF_00FF) | ((new_value as u32) << 8),
				10 => self.mem_displ = (self.mem_displ & 0xFF00_FFFF) | ((new_value as u32) << 16),
				11 => self.mem_displ = (self.mem_displ & 0x00FF_FFFF) | ((new_value as u32) << 24),
				12 => self.mem_base_reg = new_value,
				13 => self.mem_index_reg = new_value,
				14 => self.op_kind_flags = (self.op_kind_flags & 0xFFFF_FF00) | new_value as u32,
				15 => self.op_kind_flags = (self.op_kind_flags & 0xFFFF_00FF) | ((new_value as u32) << 8),
				_ => panic!(),
			}
		} else {
			panic!();
		}
	}

	/// Gets a `db` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareByte`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareByte`]: enum.Code.html#variant.DeclareByte
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-15)
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn get_declare_byte_value(&self, index: usize) -> u8 {
		match index {
			0 => self.reg0,
			1 => self.reg1,
			2 => self.reg2,
			3 => self.reg3,
			4 => self.immediate as u8,
			5 => (self.immediate >> 8) as u8,
			6 => (self.immediate >> 16) as u8,
			7 => (self.immediate >> 24) as u8,
			8 => self.mem_displ as u8,
			9 => (self.mem_displ >> 8) as u8,
			10 => (self.mem_displ >> 16) as u8,
			11 => (self.mem_displ >> 24) as u8,
			12 => self.mem_base_reg,
			13 => self.mem_index_reg,
			14 => self.op_kind_flags as u8,
			15 => (self.op_kind_flags >> 8) as u8,
			_ => panic!(),
		}
	}

	/// Sets a new `dw` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareWord`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareWord`]: enum.Code.html#variant.DeclareWord
	///
	/// # Panics
	///
	/// - Panics if `index` is invalid
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `index`: Index (0-7)
	/// * `new_value`: New value
	#[inline]
	pub fn set_declare_word_value_i16(&mut self, index: usize, new_value: i16) {
		self.set_declare_word_value(index, new_value as u16);
	}

	/// Sets a new `dw` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareWord`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareWord`]: enum.Code.html#variant.DeclareWord
	///
	/// # Panics
	///
	/// - Panics if `index` is invalid
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `index`: Index (0-7)
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_declare_word_value(&mut self, index: usize, new_value: u16) {
		if cfg!(feature = "db") {
			match index {
				0 => {
					self.reg0 = new_value as u8;
					self.reg1 = (new_value >> 8) as u8;
				}
				1 => {
					self.reg2 = new_value as u8;
					self.reg3 = (new_value >> 8) as u8;
				}
				2 => self.immediate = (self.immediate & 0xFFFF_0000) | new_value as u32,
				3 => self.immediate = self.immediate as u16 as u32 | (new_value as u32) << 16,
				4 => self.mem_displ = (self.mem_displ & 0xFFFF_0000) | new_value as u32,
				5 => self.mem_displ = self.mem_displ as u16 as u32 | (new_value as u32) << 16,
				6 => {
					self.mem_base_reg = new_value as u8;
					self.mem_index_reg = (new_value >> 8) as u8;
				}
				7 => self.op_kind_flags = (self.op_kind_flags & 0xFFFF_0000) | new_value as u32,
				_ => panic!(),
			}
		} else {
			panic!();
		}
	}

	/// Gets a `dw` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareWord`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareWord`]: enum.Code.html#variant.DeclareWord
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-7)
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn get_declare_word_value(&self, index: usize) -> u16 {
		match index {
			0 => self.reg0 as u16 | ((self.reg1 as u16) << 8),
			1 => self.reg2 as u16 | ((self.reg3 as u16) << 8),
			2 => self.immediate as u16,
			3 => (self.immediate >> 16) as u16,
			4 => self.mem_displ as u16,
			5 => (self.mem_displ >> 16) as u16,
			6 => self.mem_base_reg as u16 | ((self.mem_index_reg as u16) << 8),
			7 => self.op_kind_flags as u16,
			_ => panic!(),
		}
	}

	/// Sets a new `dd` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareDword`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareDword`]: enum.Code.html#variant.DeclareDword
	///
	/// # Panics
	///
	/// - Panics if `index` is invalid
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `index`: Index (0-3)
	/// * `new_value`: New value
	#[inline]
	pub fn set_declare_dword_value_i32(&mut self, index: usize, new_value: i32) {
		self.set_declare_dword_value(index, new_value as u32);
	}

	/// Sets a new `dd` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareDword`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareDword`]: enum.Code.html#variant.DeclareDword
	///
	/// # Panics
	///
	/// - Panics if `index` is invalid
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `index`: Index (0-3)
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_declare_dword_value(&mut self, index: usize, new_value: u32) {
		if cfg!(feature = "db") {
			match index {
				0 => {
					self.reg0 = new_value as u8;
					self.reg1 = (new_value >> 8) as u8;
					self.reg2 = (new_value >> 16) as u8;
					self.reg3 = (new_value >> 24) as u8;
				}
				1 => self.immediate = new_value,
				2 => self.mem_displ = new_value,
				3 => {
					self.mem_base_reg = new_value as u8;
					self.mem_index_reg = (new_value >> 8) as u8;
					self.op_kind_flags = (self.op_kind_flags & 0xFFFF_0000) | (new_value >> 16);
				}
				_ => panic!(),
			}
		} else {
			panic!();
		}
	}

	/// Gets a `dd` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareDword`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareDword`]: enum.Code.html#variant.DeclareDword
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-3)
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn get_declare_dword_value(&self, index: usize) -> u32 {
		match index {
			0 => self.reg0 as u32 | ((self.reg1 as u32) << 8) | ((self.reg2 as u32) << 16) | ((self.reg3 as u32) << 24),
			1 => self.immediate,
			2 => self.mem_displ,
			3 => self.mem_base_reg as u32 | ((self.mem_index_reg as u32) << 8) | (self.op_kind_flags << 16),
			_ => panic!(),
		}
	}

	/// Sets a new `dq` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareQword`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareQword`]: enum.Code.html#variant.DeclareQword
	///
	/// # Panics
	///
	/// - Panics if `index` is invalid
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `index`: Index (0-1)
	/// * `new_value`: New value
	#[inline]
	pub fn set_declare_qword_value_i64(&mut self, index: usize, new_value: i64) {
		self.set_declare_qword_value(index, new_value as u64);
	}

	/// Sets a new `dq` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareQword`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareQword`]: enum.Code.html#variant.DeclareQword
	///
	/// # Panics
	///
	/// - Panics if `index` is invalid
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `index`: Index (0-1)
	/// * `new_value`: New value
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn set_declare_qword_value(&mut self, index: usize, new_value: u64) {
		if cfg!(feature = "db") {
			match index {
				0 => {
					self.reg0 = new_value as u8;
					self.reg1 = (new_value >> 8) as u8;
					self.reg2 = (new_value >> 16) as u8;
					self.reg3 = (new_value >> 24) as u8;
					self.immediate = (new_value >> 32) as u32;
				}
				1 => {
					self.mem_displ = new_value as u32;
					self.mem_base_reg = (new_value >> 32) as u8;
					self.mem_index_reg = (new_value >> 40) as u8;
					self.op_kind_flags = (self.op_kind_flags & 0xFFFF_0000) | (new_value >> 48) as u32;
				}
				_ => panic!(),
			}
		} else {
			panic!();
		}
	}

	/// Gets a `dq` value, see also [`declare_data_len()`].
	/// Can only be called if [`code()`] is [`Code::DeclareQword`]
	///
	/// [`declare_data_len()`]: #method.declare_data_len
	/// [`code()`]: #method.code
	/// [`Code::DeclareQword`]: enum.Code.html#variant.DeclareQword
	///
	/// # Panics
	///
	/// Panics if `index` is invalid
	///
	/// # Arguments
	///
	/// * `index`: Index (0-1)
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn get_declare_qword_value(&self, index: usize) -> u64 {
		match index {
			0 => {
				self.reg0 as u64
					| ((self.reg1 as u64) << 8)
					| ((self.reg2 as u64) << 16)
					| ((self.reg3 as u64) << 24)
					| ((self.immediate as u64) << 32)
			}
			1 => {
				self.mem_displ as u64 | ((self.mem_base_reg as u64) << 32) | ((self.mem_index_reg as u64) << 40) | ((self.op_kind_flags as u64) << 48)
			}
			_ => panic!(),
		}
	}

	/// Checks if this is a VSIB instruction, see also [`is_vsib32()`], [`is_vsib64()`]
	///
	/// [`is_vsib32()`]: #method.is_vsib32
	/// [`is_vsib64()`]: #method.is_vsib64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_vsib(&self) -> bool {
		self.vsib().is_some()
	}

	/// VSIB instructions only ([`is_vsib()`]): `true` if it's using 32-bit indexes, `false` if it's using 64-bit indexes
	///
	/// [`is_vsib()`]: #method.is_vsib
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_vsib32(&self) -> bool {
		if let Some(is_vsib64) = self.vsib() {
			!is_vsib64
		} else {
			false
		}
	}

	/// VSIB instructions only ([`is_vsib()`]): `true` if it's using 64-bit indexes, `false` if it's using 32-bit indexes
	///
	/// [`is_vsib()`]: #method.is_vsib
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_vsib64(&self) -> bool {
		if let Some(is_vsib64) = self.vsib() {
			is_vsib64
		} else {
			false
		}
	}

	/// Checks if it's a vsib instruction.
	///
	/// # Returns
	///
	/// * `Some(true)` if it's a VSIB instruction with 64-bit indexes
	/// * `Some(false)` if it's a VSIB instruction with 32-bit indexes
	/// * `None` if it's not a VSIB instruction.
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::match_single_binding))]
	pub fn vsib(&self) -> Option<bool> {
		#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
		match self.code() {
			// GENERATOR-BEGIN: Vsib32
			// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
			Code::VEX_Vpgatherdd_xmm_vm32x_xmm
			| Code::VEX_Vpgatherdd_ymm_vm32y_ymm
			| Code::VEX_Vpgatherdq_xmm_vm32x_xmm
			| Code::VEX_Vpgatherdq_ymm_vm32x_ymm
			| Code::EVEX_Vpgatherdd_xmm_k1_vm32x
			| Code::EVEX_Vpgatherdd_ymm_k1_vm32y
			| Code::EVEX_Vpgatherdd_zmm_k1_vm32z
			| Code::EVEX_Vpgatherdq_xmm_k1_vm32x
			| Code::EVEX_Vpgatherdq_ymm_k1_vm32x
			| Code::EVEX_Vpgatherdq_zmm_k1_vm32y
			| Code::VEX_Vgatherdps_xmm_vm32x_xmm
			| Code::VEX_Vgatherdps_ymm_vm32y_ymm
			| Code::VEX_Vgatherdpd_xmm_vm32x_xmm
			| Code::VEX_Vgatherdpd_ymm_vm32x_ymm
			| Code::EVEX_Vgatherdps_xmm_k1_vm32x
			| Code::EVEX_Vgatherdps_ymm_k1_vm32y
			| Code::EVEX_Vgatherdps_zmm_k1_vm32z
			| Code::EVEX_Vgatherdpd_xmm_k1_vm32x
			| Code::EVEX_Vgatherdpd_ymm_k1_vm32x
			| Code::EVEX_Vgatherdpd_zmm_k1_vm32y
			| Code::EVEX_Vpscatterdd_vm32x_k1_xmm
			| Code::EVEX_Vpscatterdd_vm32y_k1_ymm
			| Code::EVEX_Vpscatterdd_vm32z_k1_zmm
			| Code::EVEX_Vpscatterdq_vm32x_k1_xmm
			| Code::EVEX_Vpscatterdq_vm32x_k1_ymm
			| Code::EVEX_Vpscatterdq_vm32y_k1_zmm
			| Code::EVEX_Vscatterdps_vm32x_k1_xmm
			| Code::EVEX_Vscatterdps_vm32y_k1_ymm
			| Code::EVEX_Vscatterdps_vm32z_k1_zmm
			| Code::EVEX_Vscatterdpd_vm32x_k1_xmm
			| Code::EVEX_Vscatterdpd_vm32x_k1_ymm
			| Code::EVEX_Vscatterdpd_vm32y_k1_zmm
			| Code::EVEX_Vgatherpf0dps_vm32z_k1
			| Code::EVEX_Vgatherpf0dpd_vm32y_k1
			| Code::EVEX_Vgatherpf1dps_vm32z_k1
			| Code::EVEX_Vgatherpf1dpd_vm32y_k1
			| Code::EVEX_Vscatterpf0dps_vm32z_k1
			| Code::EVEX_Vscatterpf0dpd_vm32y_k1
			| Code::EVEX_Vscatterpf1dps_vm32z_k1
			| Code::EVEX_Vscatterpf1dpd_vm32y_k1
			=> Some(false),
			// GENERATOR-END: Vsib32

			// GENERATOR-BEGIN: Vsib64
			// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
			Code::VEX_Vpgatherqd_xmm_vm64x_xmm
			| Code::VEX_Vpgatherqd_xmm_vm64y_xmm
			| Code::VEX_Vpgatherqq_xmm_vm64x_xmm
			| Code::VEX_Vpgatherqq_ymm_vm64y_ymm
			| Code::EVEX_Vpgatherqd_xmm_k1_vm64x
			| Code::EVEX_Vpgatherqd_xmm_k1_vm64y
			| Code::EVEX_Vpgatherqd_ymm_k1_vm64z
			| Code::EVEX_Vpgatherqq_xmm_k1_vm64x
			| Code::EVEX_Vpgatherqq_ymm_k1_vm64y
			| Code::EVEX_Vpgatherqq_zmm_k1_vm64z
			| Code::VEX_Vgatherqps_xmm_vm64x_xmm
			| Code::VEX_Vgatherqps_xmm_vm64y_xmm
			| Code::VEX_Vgatherqpd_xmm_vm64x_xmm
			| Code::VEX_Vgatherqpd_ymm_vm64y_ymm
			| Code::EVEX_Vgatherqps_xmm_k1_vm64x
			| Code::EVEX_Vgatherqps_xmm_k1_vm64y
			| Code::EVEX_Vgatherqps_ymm_k1_vm64z
			| Code::EVEX_Vgatherqpd_xmm_k1_vm64x
			| Code::EVEX_Vgatherqpd_ymm_k1_vm64y
			| Code::EVEX_Vgatherqpd_zmm_k1_vm64z
			| Code::EVEX_Vpscatterqd_vm64x_k1_xmm
			| Code::EVEX_Vpscatterqd_vm64y_k1_xmm
			| Code::EVEX_Vpscatterqd_vm64z_k1_ymm
			| Code::EVEX_Vpscatterqq_vm64x_k1_xmm
			| Code::EVEX_Vpscatterqq_vm64y_k1_ymm
			| Code::EVEX_Vpscatterqq_vm64z_k1_zmm
			| Code::EVEX_Vscatterqps_vm64x_k1_xmm
			| Code::EVEX_Vscatterqps_vm64y_k1_xmm
			| Code::EVEX_Vscatterqps_vm64z_k1_ymm
			| Code::EVEX_Vscatterqpd_vm64x_k1_xmm
			| Code::EVEX_Vscatterqpd_vm64y_k1_ymm
			| Code::EVEX_Vscatterqpd_vm64z_k1_zmm
			| Code::EVEX_Vgatherpf0qps_vm64z_k1
			| Code::EVEX_Vgatherpf0qpd_vm64z_k1
			| Code::EVEX_Vgatherpf1qps_vm64z_k1
			| Code::EVEX_Vgatherpf1qpd_vm64z_k1
			| Code::EVEX_Vscatterpf0qps_vm64z_k1
			| Code::EVEX_Vscatterpf0qpd_vm64z_k1
			| Code::EVEX_Vscatterpf1qps_vm64z_k1
			| Code::EVEX_Vscatterpf1qpd_vm64z_k1
			=> Some(true),
			// GENERATOR-END: Vsib64

			_ => None,
		}
	}

	/// Gets the suppress all exceptions flag (EVEX encoded instructions). Note that if [`rounding_control()`] is
	/// not [`RoundingControl::None`], SAE is implied but this method will still return `false`.
	///
	/// [`rounding_control()`]: #method.rounding_control
	/// [`RoundingControl::None`]: enum.RoundingControl.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn suppress_all_exceptions(&self) -> bool {
		(self.code_flags & CodeFlags::SUPPRESS_ALL_EXCEPTIONS) != 0
	}

	/// Sets the suppress all exceptions flag (EVEX encoded instructions). Note that if [`rounding_control()`] is
	/// not [`RoundingControl::None`], SAE is implied but this method will still return `false`.
	///
	/// [`rounding_control()`]: #method.rounding_control
	/// [`RoundingControl::None`]: enum.RoundingControl.html#variant.None
	///
	/// # Arguments
	///
	/// * `new_value`: New value
	#[inline]
	pub fn set_suppress_all_exceptions(&mut self, new_value: bool) {
		if new_value {
			self.code_flags |= CodeFlags::SUPPRESS_ALL_EXCEPTIONS;
		} else {
			self.code_flags &= !CodeFlags::SUPPRESS_ALL_EXCEPTIONS;
		}
	}

	/// Checks if the memory operand is `RIP`/`EIP` relative
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_ip_rel_memory_operand(&self) -> bool {
		let base_reg = self.memory_base();
		base_reg == Register::RIP || base_reg == Register::EIP
	}

	/// Gets the `RIP`/`EIP` releative address (([`next_ip()`] or [`next_ip32()`]) + [`memory_displacement()`]).
	/// This method is only valid if there's a memory operand with `RIP`/`EIP` relative addressing, see [`is_ip_rel_memory_operand()`]
	///
	/// [`next_ip()`]: #method.next_ip
	/// [`next_ip32()`]: #method.next_ip32
	/// [`memory_displacement()`]: #method.memory_displacement
	/// [`is_ip_rel_memory_operand()`]: #method.is_ip_rel_memory_operand
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn ip_rel_memory_address(&self) -> u64 {
		let mut result = self.next_ip().wrapping_add(self.memory_displacement() as i32 as u64);
		if self.memory_base() == Register::EIP {
			result = result as u32 as u64;
		}
		result
	}

	/// Gets the virtual address of a memory operand
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, must be a memory operand
	/// * `element_index`: Only used if it's a vsib memory operand. This is the element index of the vector index register.
	/// * `get_register_value`: Function that returns the value of a register or the base address of a segment register, or `None` for unsupported
	///    registers.
	///
	/// # Call-back function args
	///
	/// * Arg 1: `register`: Register (GPR8, GPR16, GPR32, GPR64, XMM, YMM, ZMM, seg). If it's a segment register, the call-back function should return the segment's base value, not the segment register value.
	/// * Arg 2: `element_index`: Only used if it's a vsib memory operand. This is the element index of the vector index register.
	/// * Arg 3: `element_size`: Only used if it's a vsib memory operand. Size in bytes of elements in vector index register (4 or 8).
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // add [rdi+r12*8-5AA5EDCCh],esi
	/// let bytes = b"\x42\x01\xB4\xE7\x34\x12\x5A\xA5";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// let va = instr.try_virtual_address(0, 0, |register, element_index, element_size| {
	///     match register {
	///         // The base address of ES, CS, SS and DS is always 0 in 64-bit mode
	///         Register::DS => Some(0x0000_0000_0000_0000),
	///         Register::RDI => Some(0x0000_0000_1000_0000),
	///         Register::R12 => Some(0x0000_0004_0000_0000),
	///         _ => None,
	///     }
	/// });
	/// assert_eq!(Some(0x0000_001F_B55A_1234), va);
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn try_virtual_address<F>(&self, operand: u32, element_index: usize, mut get_register_value: F) -> Option<u64>
	where
		F: FnMut(Register, usize, usize) -> Option<u64>,
	{
		Some(match self.op_kind(operand) {
			OpKind::Register
			| OpKind::NearBranch16
			| OpKind::NearBranch32
			| OpKind::NearBranch64
			| OpKind::FarBranch16
			| OpKind::FarBranch32
			| OpKind::Immediate8
			| OpKind::Immediate8_2nd
			| OpKind::Immediate16
			| OpKind::Immediate32
			| OpKind::Immediate64
			| OpKind::Immediate8to16
			| OpKind::Immediate8to32
			| OpKind::Immediate8to64
			| OpKind::Immediate32to64 => 0,

			OpKind::MemorySegSI => {
				let v1 = match get_register_value(self.memory_segment(), 0, 0) {
					Some(v) => v,
					None => return None,
				};
				let v2 = match get_register_value(Register::SI, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(v2 as u16 as u64)
			}
			OpKind::MemorySegESI => {
				let v1 = match get_register_value(self.memory_segment(), 0, 0) {
					Some(v) => v,
					None => return None,
				};
				let v2 = match get_register_value(Register::ESI, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(v2 as u32 as u64)
			}
			OpKind::MemorySegRSI => {
				let v1 = match get_register_value(self.memory_segment(), 0, 0) {
					Some(v) => v,
					None => return None,
				};
				let v2 = match get_register_value(Register::RSI, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(v2)
			}
			OpKind::MemorySegDI => {
				let v1 = match get_register_value(self.memory_segment(), 0, 0) {
					Some(v) => v,
					None => return None,
				};
				let v2 = match get_register_value(Register::DI, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(v2 as u16 as u64)
			}
			OpKind::MemorySegEDI => {
				let v1 = match get_register_value(self.memory_segment(), 0, 0) {
					Some(v) => v,
					None => return None,
				};
				let v2 = match get_register_value(Register::EDI, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(v2 as u32 as u64)
			}
			OpKind::MemorySegRDI => {
				let v1 = match get_register_value(self.memory_segment(), 0, 0) {
					Some(v) => v,
					None => return None,
				};
				let v2 = match get_register_value(Register::RDI, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(v2)
			}
			OpKind::MemoryESDI => {
				let v1 = match get_register_value(Register::ES, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				let v2 = match get_register_value(Register::DI, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(v2 as u16 as u64)
			}
			OpKind::MemoryESEDI => {
				let v1 = match get_register_value(Register::ES, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				let v2 = match get_register_value(Register::EDI, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(v2 as u32 as u64)
			}
			OpKind::MemoryESRDI => {
				let v1 = match get_register_value(Register::ES, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				let v2 = match get_register_value(Register::RDI, 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(v2)
			}
			OpKind::Memory64 => {
				let v1 = match get_register_value(self.memory_segment(), 0, 0) {
					Some(v) => v,
					None => return None,
				};
				v1.wrapping_add(self.memory_address64())
			}

			OpKind::Memory => {
				let base_reg = self.memory_base();
				let index_reg = self.memory_index();
				let addr_size =
					super::instruction_internal::get_address_size_in_bytes(base_reg, index_reg, self.memory_displ_size(), self.code_size());
				let mut offset = self.memory_displacement() as u64;
				let offset_mask = match addr_size {
					8 => {
						offset = offset as i32 as u64;
						u64::MAX
					}
					4 => u32::MAX as u64,
					_ => {
						debug_assert_eq!(2, addr_size);
						u16::MAX as u64
					}
				};
				match base_reg {
					Register::None => {}
					Register::RIP => offset = offset.wrapping_add(self.next_ip()),
					Register::EIP => offset = offset.wrapping_add(self.next_ip32() as u64),
					_ => {
						let v1 = match get_register_value(base_reg, 0, 0) {
							Some(v) => v,
							None => return None,
						};
						offset = offset.wrapping_add(v1)
					}
				}
				if index_reg != Register::None {
					if let Some(is_vsib64) = self.vsib() {
						if is_vsib64 {
							let v1 = match get_register_value(index_reg, element_index, 8) {
								Some(v) => v,
								None => return None,
							};
							offset = offset.wrapping_add(v1 << super::instruction_internal::internal_get_memory_index_scale(self));
						} else {
							let v1 = match get_register_value(index_reg, element_index, 4) {
								Some(v) => v,
								None => return None,
							};
							offset = offset.wrapping_add((v1 as u32 as u64) << super::instruction_internal::internal_get_memory_index_scale(self));
						}
					} else {
						let v1 = match get_register_value(index_reg, element_index, 0) {
							Some(v) => v,
							None => return None,
						};
						offset = offset.wrapping_add(v1 << super::instruction_internal::internal_get_memory_index_scale(self));
					}
				}
				offset &= offset_mask;
				match get_register_value(self.memory_segment(), 0, 0) {
					Some(v) => v.wrapping_add(offset),
					None => return None,
				}
			}
		})
	}

	/// Gets the virtual address of a memory operand. See also [`try_virtual_address()`]
	///
	/// [`try_virtual_address()`]: #method.try_virtual_address
	///
	/// # Panics
	///
	/// Panics if `operand` is invalid
	///
	/// # Arguments
	///
	/// * `operand`: Operand number, must be a memory operand
	/// * `element_index`: Only used if it's a vsib memory operand. This is the element index of the vector index register.
	/// * `get_register_value`: Function that returns the value of a register or the base address of a segment register.
	///
	/// # Call-back function args
	///
	/// * Arg 1: `register`: Register (GPR8, GPR16, GPR32, GPR64, XMM, YMM, ZMM, seg). If it's a segment register, the call-back function should return the segment's base value, not the segment register value.
	/// * Arg 2: `element_index`: Only used if it's a vsib memory operand. This is the element index of the vector index register.
	/// * Arg 3: `element_size`: Only used if it's a vsib memory operand. Size in bytes of elements in vector index register (4 or 8).
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // add [rdi+r12*8-5AA5EDCCh],esi
	/// let bytes = b"\x42\x01\xB4\xE7\x34\x12\x5A\xA5";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// let va = instr.virtual_address(0, 0, |register, element_index, element_size| {
	///     match register {
	///         // The base address of ES, CS, SS and DS is always 0 in 64-bit mode
	///         Register::DS => 0x0000_0000_0000_0000,
	///         Register::RDI => 0x0000_0000_1000_0000,
	///         Register::R12 => 0x0000_0004_0000_0000,
	///         _ => unimplemented!(),
	///     }
	/// });
	/// assert_eq!(0x0000_001F_B55A_1234, va);
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn virtual_address<F>(&self, operand: u32, element_index: usize, mut get_register_value: F) -> u64
	where
		F: FnMut(Register, usize, usize) -> u64,
	{
		self.try_virtual_address(operand, element_index, |x, y, z| Some(get_register_value(x, y, z))).unwrap()
	}
}

#[cfg(feature = "instr_info")]
impl Instruction {
	/// Gets the number of bytes added to `SP`/`ESP`/`RSP` or 0 if it's not an instruction that pushes or pops data. This method assumes
	/// the instruction doesn't change the privilege level (eg. `IRET/D/Q`). If it's the `LEAVE` instruction, this method returns 0.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // pushfq
	/// let bytes = b"\x9C";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert!(instr.is_stack_instruction());
	/// assert_eq!(-8, instr.stack_pointer_increment());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn stack_pointer_increment(&self) -> i32 {
		match self.code() {
			Code::Pushw_ES
			| Code::Pushw_CS
			| Code::Pushw_SS
			| Code::Pushw_DS
			| Code::Push_r16
			| Code::Push_imm16
			| Code::Pushw_imm8
			| Code::Pushfw
			| Code::Push_rm16
			| Code::Pushw_FS
			| Code::Pushw_GS => -2,
			Code::Pushd_ES
			| Code::Pushd_CS
			| Code::Pushd_SS
			| Code::Pushd_DS
			| Code::Push_r32
			| Code::Pushd_imm32
			| Code::Pushd_imm8
			| Code::Pushfd
			| Code::Push_rm32
			| Code::Pushd_FS
			| Code::Pushd_GS => -4,
			Code::Push_r64 | Code::Pushq_imm32 | Code::Pushq_imm8 | Code::Pushfq | Code::Push_rm64 | Code::Pushq_FS | Code::Pushq_GS => -8,
			Code::Pushaw => -2 * 8,
			Code::Pushad => -4 * 8,
			Code::Popw_ES
			| Code::Popw_CS
			| Code::Popw_SS
			| Code::Popw_DS
			| Code::Pop_r16
			| Code::Pop_rm16
			| Code::Popfw
			| Code::Popw_FS
			| Code::Popw_GS => 2,
			Code::Popd_ES | Code::Popd_SS | Code::Popd_DS | Code::Pop_r32 | Code::Pop_rm32 | Code::Popfd | Code::Popd_FS | Code::Popd_GS => 4,
			Code::Pop_r64 | Code::Pop_rm64 | Code::Popfq | Code::Popq_FS | Code::Popq_GS => 8,
			Code::Popaw => 2 * 8,
			Code::Popad => 4 * 8,
			Code::Call_ptr1616 | Code::Call_m1616 => -(2 + 2),
			Code::Call_ptr1632 | Code::Call_m1632 => -(4 + 4),
			Code::Call_m1664 => -(8 + 8),
			Code::Call_rel16 | Code::Call_rm16 => -2,
			Code::Call_rel32_32 | Code::Call_rm32 => -4,
			Code::Call_rel32_64 | Code::Call_rm64 => -8,
			Code::Retnw_imm16 => 2 + self.immediate16() as i32,
			Code::Retnd_imm16 => 4 + self.immediate16() as i32,
			Code::Retnq_imm16 => 8 + self.immediate16() as i32,
			Code::Retnw => 2,
			Code::Retnd => 4,
			Code::Retnq => 8,
			Code::Retfw_imm16 => 2 + 2 + self.immediate16() as i32,
			Code::Retfd_imm16 => 4 + 4 + self.immediate16() as i32,
			Code::Retfq_imm16 => 8 + 8 + self.immediate16() as i32,
			Code::Retfw => 2 + 2,
			Code::Retfd => 4 + 4,
			Code::Retfq => 8 + 8,
			Code::Iretw => {
				if self.code_size() == CodeSize::Code64 {
					2 * 5
				} else {
					2 * 3
				}
			}
			Code::Iretd => {
				if self.code_size() == CodeSize::Code64 {
					4 * 5
				} else {
					4 * 3
				}
			}
			Code::Iretq => 8 * 5,
			Code::Enterw_imm16_imm8 => -(2 + (self.immediate8_2nd() as i32 & 0x1F) * 2 + self.immediate16() as i32),
			Code::Enterd_imm16_imm8 => -(4 + (self.immediate8_2nd() as i32 & 0x1F) * 4 + self.immediate16() as i32),
			Code::Enterq_imm16_imm8 => -(8 + (self.immediate8_2nd() as i32 & 0x1F) * 8 + self.immediate16() as i32),
			Code::Leavew | Code::Leaved | Code::Leaveq => 0,
			Code::Uiret => 8 * 3,
			_ => 0,
		}
	}

	/// Instruction encoding, eg. legacy, VEX, EVEX, ...
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // vmovaps xmm1,xmm5
	/// let bytes = b"\xC5\xF8\x28\xCD";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	/// let instr = decoder.decode();
	///
	/// assert_eq!(EncodingKind::VEX, instr.encoding());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn encoding(&self) -> EncodingKind {
		self.code().encoding()
	}

	/// Gets the CPU or CPUID feature flags
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // vmovaps xmm1,xmm5
	/// // vmovaps xmm10{k3}{z},xmm19
	/// let bytes = b"\xC5\xF8\x28\xCD\x62\x31\x7C\x8B\x28\xD3";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // vmovaps xmm1,xmm5
	/// let instr = decoder.decode();
	/// let cpuid = instr.cpuid_features();
	/// assert_eq!(1, cpuid.len());
	/// assert_eq!(CpuidFeature::AVX, cpuid[0]);
	///
	/// // vmovaps xmm10{k3}{z},xmm19
	/// let instr = decoder.decode();
	/// let cpuid = instr.cpuid_features();
	/// assert_eq!(2, cpuid.len());
	/// assert_eq!(CpuidFeature::AVX512VL, cpuid[0]);
	/// assert_eq!(CpuidFeature::AVX512F, cpuid[1]);
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	pub fn cpuid_features(&self) -> &'static [CpuidFeature] {
		let flags2 = unsafe { *super::info::info_table::TABLE.get_unchecked((self.code() as usize) * 2 + 1) };
		let index = ((flags2 >> InfoFlags2::CPUID_FEATURE_INTERNAL_SHIFT) & InfoFlags2::CPUID_FEATURE_INTERNAL_MASK) as usize;
		unsafe { *super::info::cpuid_table::CPUID.get_unchecked(index) }
	}

	/// Flow control info
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // or ecx,esi
	/// // ud0 rcx,rsi
	/// // call rcx
	/// let bytes = b"\x0B\xCE\x48\x0F\xFF\xCE\xFF\xD1";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // or ecx,esi
	/// let instr = decoder.decode();
	/// assert_eq!(FlowControl::Next, instr.flow_control());
	///
	/// // ud0 rcx,rsi
	/// let instr = decoder.decode();
	/// assert_eq!(FlowControl::Exception, instr.flow_control());
	///
	/// // call rcx
	/// let instr = decoder.decode();
	/// assert_eq!(FlowControl::IndirectCall, instr.flow_control());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn flow_control(&self) -> FlowControl {
		self.code().flow_control()
	}

	/// `true` if it's a privileged instruction (all CPL=0 instructions (except `VMCALL`) and IOPL instructions `IN`, `INS`, `OUT`, `OUTS`, `CLI`, `STI`)
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_privileged(&self) -> bool {
		self.code().is_privileged()
	}

	/// `true` if this is an instruction that implicitly uses the stack pointer (`SP`/`ESP`/`RSP`), eg. `CALL`, `PUSH`, `POP`, `RET`, etc.
	/// See also [`stack_pointer_increment()`]
	///
	/// [`stack_pointer_increment()`]: #method.stack_pointer_increment
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // or ecx,esi
	/// // push rax
	/// let bytes = b"\x0B\xCE\x50";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // or ecx,esi
	/// let instr = decoder.decode();
	/// assert!(!instr.is_stack_instruction());
	///
	/// // push rax
	/// let instr = decoder.decode();
	/// assert!(instr.is_stack_instruction());
	/// assert_eq!(-8, instr.stack_pointer_increment());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_stack_instruction(&self) -> bool {
		self.code().is_stack_instruction()
	}

	/// `true` if it's an instruction that saves or restores too many registers (eg. `FXRSTOR`, `XSAVE`, etc).
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_save_restore_instruction(&self) -> bool {
		self.code().is_save_restore_instruction()
	}

	#[cfg_attr(has_must_use, must_use)]
	fn rflags_info(&self) -> usize {
		let flags1 = unsafe { *super::info::info_table::TABLE.get_unchecked((self.code() as usize) * 2) };
		let code_info = (flags1 >> InfoFlags1::CODE_INFO_SHIFT) & InfoFlags1::CODE_INFO_MASK;
		const_assert!(CodeInfo::Shift_Ib_MASK1FMOD9 as u32 + 1 == CodeInfo::Shift_Ib_MASK1FMOD11 as u32);
		const_assert!(CodeInfo::Shift_Ib_MASK1FMOD9 as u32 + 2 == CodeInfo::Shift_Ib_MASK1F as u32);
		const_assert!(CodeInfo::Shift_Ib_MASK1FMOD9 as u32 + 3 == CodeInfo::Shift_Ib_MASK3F as u32);
		const_assert!(CodeInfo::Shift_Ib_MASK1FMOD9 as u32 + 4 == CodeInfo::Clear_rflags as u32);
		let result = ((flags1 >> InfoFlags1::RFLAGS_INFO_SHIFT) & InfoFlags1::RFLAGS_INFO_MASK) as usize;
		let e = code_info.wrapping_sub(CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
		match e {
			0 | 1 => {
				const_assert_eq!(0, CodeInfo::Shift_Ib_MASK1FMOD9 as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				const_assert_eq!(1, CodeInfo::Shift_Ib_MASK1FMOD11 as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				let m = if e == 0 { 9 } else { 17 };
				match (self.immediate8() & 0x1F) % m {
					0 => return RflagsInfo::None as usize,
					1 => return RflagsInfo::R_c_W_co as usize,
					_ => {}
				}
			}
			2 | 3 => {
				const_assert_eq!(2, CodeInfo::Shift_Ib_MASK1F as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				const_assert_eq!(3, CodeInfo::Shift_Ib_MASK3F as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				let mask = if e == 2 { 0x1F } else { 0x3F };
				match self.immediate8() & mask {
					0 => return RflagsInfo::None as usize,
					1 => {
						if result == RflagsInfo::W_c_U_o as usize {
							return RflagsInfo::W_co as usize;
						} else if result == RflagsInfo::R_c_W_c_U_o as usize {
							return RflagsInfo::R_c_W_co as usize;
						} else {
							debug_assert_eq!(RflagsInfo::W_cpsz_U_ao as usize, result);
							return RflagsInfo::W_copsz_U_a as usize;
						}
					}
					_ => {}
				}
			}
			4 => {
				const_assert_eq!(4, CodeInfo::Clear_rflags as u32 - CodeInfo::Shift_Ib_MASK1FMOD9 as u32);
				if self.op0_register() == self.op1_register() && self.op0_kind() == OpKind::Register && self.op1_kind() == OpKind::Register {
					if self.code().mnemonic() == Mnemonic::Xor {
						return RflagsInfo::C_cos_S_pz_U_a as usize;
					} else {
						return RflagsInfo::C_acos_S_pz as usize;
					}
				}
			}
			_ => {}
		}
		result
	}

	/// All flags that are read by the CPU when executing the instruction.
	/// This method returns a [`RflagsBits`] value. See also [`rflags_modified()`].
	///
	/// [`RflagsBits`]: struct.RflagsBits.html
	/// [`rflags_modified()`]: #method.rflags_modified
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_read(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_READ.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are written by the CPU, except those flags that are known to be undefined, always set or always cleared.
	/// This method returns a [`RflagsBits`] value. See also [`rflags_modified()`].
	///
	/// [`RflagsBits`]: struct.RflagsBits.html
	/// [`rflags_modified()`]: #method.rflags_modified
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_written(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_WRITTEN.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are always cleared by the CPU.
	/// This method returns a [`RflagsBits`] value. See also [`rflags_modified()`].
	///
	/// [`RflagsBits`]: struct.RflagsBits.html
	/// [`rflags_modified()`]: #method.rflags_modified
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_cleared(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_CLEARED.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are always set by the CPU.
	/// This method returns a [`RflagsBits`] value. See also [`rflags_modified()`].
	///
	/// [`RflagsBits`]: struct.RflagsBits.html
	/// [`rflags_modified()`]: #method.rflags_modified
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_set(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_SET.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are undefined after executing the instruction.
	/// This method returns a [`RflagsBits`] value. See also [`rflags_modified()`].
	///
	/// [`RflagsBits`]: struct.RflagsBits.html
	/// [`rflags_modified()`]: #method.rflags_modified
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_undefined(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_UNDEFINED.get_unchecked(self.rflags_info()) as u32 }
	}

	/// All flags that are modified by the CPU. This is `rflags_written() + rflags_cleared() + rflags_set() + rflags_undefined()`. This method returns a [`RflagsBits`] value.
	///
	/// [`RflagsBits`]: struct.RflagsBits.html
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // adc rsi,rcx
	/// // xor rdi,5Ah
	/// let bytes = b"\x48\x11\xCE\x48\x83\xF7\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // adc rsi,rcx
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::CF, instr.rflags_read());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	///
	/// // xor rdi,5Ah
	/// let instr = decoder.decode();
	/// assert_eq!(RflagsBits::NONE, instr.rflags_read());
	/// assert_eq!(RflagsBits::SF | RflagsBits::ZF | RflagsBits::PF, instr.rflags_written());
	/// assert_eq!(RflagsBits::OF | RflagsBits::CF, instr.rflags_cleared());
	/// assert_eq!(RflagsBits::NONE, instr.rflags_set());
	/// assert_eq!(RflagsBits::AF, instr.rflags_undefined());
	/// assert_eq!(RflagsBits::OF | RflagsBits::SF | RflagsBits::ZF | RflagsBits::AF | RflagsBits::CF | RflagsBits::PF, instr.rflags_modified());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn rflags_modified(&self) -> u32 {
		unsafe { *super::info::rflags_table::FLAGS_MODIFIED.get_unchecked(self.rflags_info()) as u32 }
	}

	/// Checks if it's a `Jcc SHORT` or `Jcc NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jcc_short_or_near(&self) -> bool {
		self.code().is_jcc_short_or_near()
	}

	/// Checks if it's a `Jcc NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jcc_near(&self) -> bool {
		self.code().is_jcc_near()
	}

	/// Checks if it's a `Jcc SHORT` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jcc_short(&self) -> bool {
		self.code().is_jcc_short()
	}

	/// Checks if it's a `JMP SHORT` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_short(&self) -> bool {
		self.code().is_jmp_short()
	}

	/// Checks if it's a `JMP NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_near(&self) -> bool {
		self.code().is_jmp_near()
	}

	/// Checks if it's a `JMP SHORT` or a `JMP NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_short_or_near(&self) -> bool {
		self.code().is_jmp_short_or_near()
	}

	/// Checks if it's a `JMP FAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_far(&self) -> bool {
		self.code().is_jmp_far()
	}

	/// Checks if it's a `CALL NEAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_call_near(&self) -> bool {
		self.code().is_call_near()
	}

	/// Checks if it's a `CALL FAR` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_call_far(&self) -> bool {
		self.code().is_call_far()
	}

	/// Checks if it's a `JMP NEAR reg/[mem]` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_near_indirect(&self) -> bool {
		self.code().is_jmp_near_indirect()
	}

	/// Checks if it's a `JMP FAR [mem]` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_jmp_far_indirect(&self) -> bool {
		self.code().is_jmp_far_indirect()
	}

	/// Checks if it's a `CALL NEAR reg/[mem]` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_call_near_indirect(&self) -> bool {
		self.code().is_call_near_indirect()
	}

	/// Checks if it's a `CALL FAR [mem]` instruction
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn is_call_far_indirect(&self) -> bool {
		self.code().is_call_far_indirect()
	}

	/// Negates the condition code, eg. `JE` -> `JNE`. Can be used if it's `Jcc`, `SETcc`, `CMOVcc`, `LOOPcc`
	/// and does nothing if the instruction doesn't have a condition code.
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // setbe al
	/// let bytes = b"\x0F\x96\xC0";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// let mut instr = decoder.decode();
	/// assert_eq!(Code::Setbe_rm8, instr.code());
	/// assert_eq!(ConditionCode::be, instr.condition_code());
	/// instr.negate_condition_code();
	/// assert_eq!(Code::Seta_rm8, instr.code());
	/// assert_eq!(ConditionCode::a, instr.condition_code());
	/// ```
	#[inline]
	pub fn negate_condition_code(&mut self) {
		// Temp needed if rustc < 1.36.0 (2015 edition)
		let t = self.code().negate_condition_code();
		self.set_code(t)
	}

	/// Converts `Jcc/JMP NEAR` to `Jcc/JMP SHORT` and does nothing if it's not a `Jcc/JMP NEAR` instruction
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // jbe near ptr label
	/// let bytes = b"\x0F\x86\x5A\xA5\x12\x34";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// let mut instr = decoder.decode();
	/// assert_eq!(Code::Jbe_rel32_64, instr.code());
	/// instr.as_short_branch();
	/// assert_eq!(Code::Jbe_rel8_64, instr.code());
	/// instr.as_short_branch();
	/// assert_eq!(Code::Jbe_rel8_64, instr.code());
	/// ```
	#[inline]
	pub fn as_short_branch(&mut self) {
		// Temp needed if rustc < 1.36.0 (2015 edition)
		let t = self.code().as_short_branch();
		self.set_code(t)
	}

	/// Converts `Jcc/JMP SHORT` to `Jcc/JMP NEAR` and does nothing if it's not a `Jcc/JMP SHORT` instruction
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // jbe short label
	/// let bytes = b"\x76\x5A";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// let mut instr = decoder.decode();
	/// assert_eq!(Code::Jbe_rel8_64, instr.code());
	/// instr.as_near_branch();
	/// assert_eq!(Code::Jbe_rel32_64, instr.code());
	/// instr.as_near_branch();
	/// assert_eq!(Code::Jbe_rel32_64, instr.code());
	/// ```
	#[inline]
	pub fn as_near_branch(&mut self) {
		// Temp needed if rustc < 1.36.0 (2015 edition)
		let t = self.code().as_near_branch();
		self.set_code(t)
	}

	/// Gets the condition code if it's `Jcc`, `SETcc`, `CMOVcc`, `LOOPcc` else [`ConditionCode::None`] is returned
	///
	/// [`ConditionCode::None`]: enum.ConditionCode.html#variant.None
	///
	/// # Examples
	///
	/// ```
	/// use iced_x86::*;
	///
	/// // setbe al
	/// // jl short label
	/// // cmovne ecx,esi
	/// // nop
	/// let bytes = b"\x0F\x96\xC0\x7C\x5A\x0F\x45\xCE\x90";
	/// let mut decoder = Decoder::new(64, bytes, DecoderOptions::NONE);
	///
	/// // setbe al
	/// let instr = decoder.decode();
	/// assert_eq!(ConditionCode::be, instr.condition_code());
	///
	/// // jl short label
	/// let instr = decoder.decode();
	/// assert_eq!(ConditionCode::l, instr.condition_code());
	///
	/// // cmovne ecx,esi
	/// let instr = decoder.decode();
	/// assert_eq!(ConditionCode::ne, instr.condition_code());
	///
	/// // nop
	/// let instr = decoder.decode();
	/// assert_eq!(ConditionCode::None, instr.condition_code());
	/// ```
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn condition_code(&self) -> ConditionCode {
		self.code().condition_code()
	}
}

#[cfg(all(feature = "encoder", feature = "op_code_info"))]
impl Instruction {
	/// Gets the [`OpCodeInfo`]
	///
	/// [`OpCodeInfo`]: struct.OpCodeInfo.html
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	pub fn op_code(&self) -> &'static OpCodeInfo {
		self.code().op_code()
	}
}

#[cfg(feature = "encoder")]
impl Instruction {
	// GENERATOR-BEGIN: Create
	// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
	/// Creates an instruction with no operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with(code: Code) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 1 operand
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg(code: Code, register: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		debug_assert_eq!(1, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 1 operand
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_i32(code: Code, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 0, immediate as i64);

		debug_assert_eq!(1, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 1 operand
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_u32(code: Code, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 0, immediate as u64);

		debug_assert_eq!(1, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 1 operand
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_mem(code: Code, memory: MemoryOperand) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		debug_assert_eq!(1, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg(code: Code, register1: Register, register2: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_i32(code: Code, register: Register, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate as i64);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_u32(code: Code, register: Register, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate as u64);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_i64(code: Code, register: Register, immediate: i64) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_u64(code: Code, register: Register, immediate: u64) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `memory`: op1: Memory operand
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_mem(code: Code, register: Register, memory: MemoryOperand) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	/// * `register`: op1: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_i32_reg(code: Code, immediate: i32, register: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 0, immediate as i64);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	/// * `register`: op1: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_u32_reg(code: Code, immediate: u32, register: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 0, immediate as u64);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate1`: op0: Immediate value
	/// * `immediate2`: op1: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_i32_i32(code: Code, immediate1: i32, immediate2: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 0, immediate1 as i64);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate2 as i64);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate1`: op0: Immediate value
	/// * `immediate2`: op1: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_u32_u32(code: Code, immediate1: u32, immediate2: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 0, immediate1 as u64);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate2 as u64);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register`: op1: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_mem_reg(code: Code, memory: MemoryOperand, register: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `immediate`: op1: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_mem_i32(code: Code, memory: MemoryOperand, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate as i64);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `immediate`: op1: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_mem_u32(code: Code, memory: MemoryOperand, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate as u64);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_reg(code: Code, register1: Register, register2: Register, register3: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register3);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_i32(code: Code, register1: Register, register2: Register, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate as i64);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_u32(code: Code, register1: Register, register2: Register, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate as u64);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_mem(code: Code, register1: Register, register2: Register, memory: MemoryOperand) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate1`: op1: Immediate value
	/// * `immediate2`: op2: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_i32_i32(code: Code, register: Register, immediate1: i32, immediate2: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate1 as i64);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate2 as i64);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate1`: op1: Immediate value
	/// * `immediate2`: op2: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_u32_u32(code: Code, register: Register, immediate1: u32, immediate2: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate1 as u64);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate2 as u64);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `memory`: op1: Memory operand
	/// * `register2`: op2: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_mem_reg(code: Code, register1: Register, memory: MemoryOperand, register2: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register2);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `memory`: op1: Memory operand
	/// * `immediate`: op2: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_mem_i32(code: Code, register: Register, memory: MemoryOperand, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate as i64);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `memory`: op1: Memory operand
	/// * `immediate`: op2: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_mem_u32(code: Code, register: Register, memory: MemoryOperand, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate as u64);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register1`: op1: Register
	/// * `register2`: op2: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_mem_reg_reg(code: Code, memory: MemoryOperand, register1: Register, register2: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register2);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_mem_reg_i32(code: Code, memory: MemoryOperand, register: Register, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate as i64);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_mem_reg_u32(code: Code, memory: MemoryOperand, register: Register, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate as u64);

		debug_assert_eq!(3, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `register4`: op3: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_reg_reg(code: Code, register1: Register, register2: Register, register3: Register, register4: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register3);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op3_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op3_register(&mut instruction, register4);

		debug_assert_eq!(4, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `immediate`: op3: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_reg_i32(code: Code, register1: Register, register2: Register, register3: Register, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register3);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 3, immediate as i64);

		debug_assert_eq!(4, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `immediate`: op3: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_reg_u32(code: Code, register1: Register, register2: Register, register3: Register, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register3);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 3, immediate as u64);

		debug_assert_eq!(4, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `memory`: op3: Memory operand
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_reg_mem(code: Code, register1: Register, register2: Register, register3: Register, memory: MemoryOperand) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register3);

		super::instruction_internal::internal_set_op3_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		debug_assert_eq!(4, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate1`: op2: Immediate value
	/// * `immediate2`: op3: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_i32_i32(code: Code, register1: Register, register2: Register, immediate1: i32, immediate2: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate1 as i64);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 3, immediate2 as i64);

		debug_assert_eq!(4, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate1`: op2: Immediate value
	/// * `immediate2`: op3: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_u32_u32(code: Code, register1: Register, register2: Register, immediate1: u32, immediate2: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate1 as u64);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 3, immediate2 as u64);

		debug_assert_eq!(4, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `register3`: op3: Register
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_mem_reg(code: Code, register1: Register, register2: Register, memory: MemoryOperand, register3: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op3_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op3_register(&mut instruction, register3);

		debug_assert_eq!(4, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `immediate`: op3: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_mem_i32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 3, immediate as i64);

		debug_assert_eq!(4, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `immediate`: op3: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_mem_u32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 3, immediate as u64);

		debug_assert_eq!(4, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `register4`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_reg_reg_i32(code: Code, register1: Register, register2: Register, register3: Register, register4: Register, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register3);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op3_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op3_register(&mut instruction, register4);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 4, immediate as i64);

		debug_assert_eq!(5, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `register4`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_reg_reg_u32(code: Code, register1: Register, register2: Register, register3: Register, register4: Register, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register3);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op3_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op3_register(&mut instruction, register4);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 4, immediate as u64);

		debug_assert_eq!(5, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `memory`: op3: Memory operand
	/// * `immediate`: op4: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_reg_mem_i32(code: Code, register1: Register, register2: Register, register3: Register, memory: MemoryOperand, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register3);

		super::instruction_internal::internal_set_op3_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 4, immediate as i64);

		debug_assert_eq!(5, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `memory`: op3: Memory operand
	/// * `immediate`: op4: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_reg_mem_u32(code: Code, register1: Register, register2: Register, register3: Register, memory: MemoryOperand, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op2_register(&mut instruction, register3);

		super::instruction_internal::internal_set_op3_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 4, immediate as u64);

		debug_assert_eq!(5, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `register3`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_mem_reg_i32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, register3: Register, immediate: i32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op3_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op3_register(&mut instruction, register3);

		super::instruction_internal::initialize_signed_immediate(&mut instruction, 4, immediate as i64);

		debug_assert_eq!(5, instruction.op_count());
		instruction
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `register3`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_reg_mem_reg_u32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, register3: Register, immediate: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register1);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register2);

		super::instruction_internal::internal_set_op2_kind(&mut instruction, OpKind::Memory);
		super::instruction_internal::internal_set_memory_base(&mut instruction, memory.base);
		super::instruction_internal::internal_set_memory_index(&mut instruction, memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		instruction.set_memory_displacement(memory.displacement as u32);
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op3_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op3_register(&mut instruction, register3);

		super::instruction_internal::initialize_unsigned_immediate(&mut instruction, 4, immediate as u64);

		debug_assert_eq!(5, instruction.op_count());
		instruction
	}

	/// Creates a new near/short branch instruction
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `target`: Target address
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_branch(code: Code, target: u64) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, super::instruction_internal::get_near_branch_op_kind(code, 0));
		instruction.set_near_branch64(target);

		debug_assert_eq!(1, instruction.op_count());
		instruction
	}

	/// Creates a new far branch instruction
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `selector`: Selector/segment value
	/// * `offset`: Offset
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_far_branch(code: Code, selector: u16, offset: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, super::instruction_internal::get_far_branch_op_kind(code, 0));
		instruction.set_far_branch_selector(selector);
		instruction.set_far_branch32(offset);

		debug_assert_eq!(1, instruction.op_count());
		instruction
	}

	/// Creates a new `XBEGIN` instruction
	///
	/// # Panics
	///
	/// Panics if `bitness` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `bitness`: 16, 32, or 64
	/// * `target`: Target address
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_xbegin(bitness: u32, target: u64) -> Self {
		let mut instruction = Self::default();

		match bitness {
			16 => {
				super::instruction_internal::internal_set_code(&mut instruction, Code::Xbegin_rel16);
				super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::NearBranch32);
				instruction.set_near_branch32(target as u32);
			}

			32 => {
				super::instruction_internal::internal_set_code(&mut instruction, Code::Xbegin_rel32);
				super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::NearBranch32);
				instruction.set_near_branch32(target as u32);
			}

			64 => {
				super::instruction_internal::internal_set_code(&mut instruction, Code::Xbegin_rel32);
				super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::NearBranch64);
				instruction.set_near_branch64(target);
			}

			_ => panic!(),
		}

		debug_assert_eq!(1, instruction.op_count());
		instruction
	}

	/// Creates an instruction with a 64-bit memory offset as the second operand, eg. `mov al,[123456789ABCDEF0]`
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: Register (`AL`, `AX`, `EAX`, `RAX`)
	/// * `address`: 64-bit address
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_reg_mem64(code: Code, register: Register, address: u64, segment_prefix: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Memory64);
		instruction.set_memory_address64(address);
		super::instruction_internal::internal_set_memory_displ_size(&mut instruction, 4);
		instruction.set_segment_prefix(segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op0_register(&mut instruction, register);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates an instruction with a 64-bit memory offset as the first operand, eg. `mov [123456789ABCDEF0],al`
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `address`: 64-bit address
	/// * `register`: Register (`AL`, `AX`, `EAX`, `RAX`)
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_mem64_reg(code: Code, address: u64, register: Register, segment_prefix: Register) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, code);

		super::instruction_internal::internal_set_op0_kind(&mut instruction, OpKind::Memory64);
		instruction.set_memory_address64(address);
		super::instruction_internal::internal_set_memory_displ_size(&mut instruction, 4);
		instruction.set_segment_prefix(segment_prefix);

		const_assert_eq!(0, OpKind::Register as u32);
		//super::instruction_internal::internal_set_op1_kind(&mut instruction, OpKind::Register);
		super::instruction_internal::internal_set_op1_register(&mut instruction, register);

		debug_assert_eq!(2, instruction.op_count());
		instruction
	}

	/// Creates a `OUTSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_outsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Outsb_DX_m8, address_size, Register::DX, segment_prefix, rep_prefix)
	}

	/// Creates a `REP OUTSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_outsb(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Outsb_DX_m8, address_size, Register::DX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `OUTSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_outsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Outsw_DX_m16, address_size, Register::DX, segment_prefix, rep_prefix)
	}

	/// Creates a `REP OUTSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_outsw(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Outsw_DX_m16, address_size, Register::DX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `OUTSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_outsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Outsd_DX_m32, address_size, Register::DX, segment_prefix, rep_prefix)
	}

	/// Creates a `REP OUTSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_outsd(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Outsd_DX_m32, address_size, Register::DX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `LODSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_lodsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Lodsb_AL_m8, address_size, Register::AL, segment_prefix, rep_prefix)
	}

	/// Creates a `REP LODSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_lodsb(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Lodsb_AL_m8, address_size, Register::AL, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `LODSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_lodsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Lodsw_AX_m16, address_size, Register::AX, segment_prefix, rep_prefix)
	}

	/// Creates a `REP LODSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_lodsw(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Lodsw_AX_m16, address_size, Register::AX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `LODSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_lodsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Lodsd_EAX_m32, address_size, Register::EAX, segment_prefix, rep_prefix)
	}

	/// Creates a `REP LODSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_lodsd(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Lodsd_EAX_m32, address_size, Register::EAX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `LODSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_lodsq(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Lodsq_RAX_m64, address_size, Register::RAX, segment_prefix, rep_prefix)
	}

	/// Creates a `REP LODSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_lodsq(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_segrsi(Code::Lodsq_RAX_m64, address_size, Register::RAX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `SCASB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_scasb(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasb_AL_m8, address_size, Register::AL, rep_prefix)
	}

	/// Creates a `REPE SCASB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repe_scasb(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasb_AL_m8, address_size, Register::AL, RepPrefixKind::Repe)
	}

	/// Creates a `REPNE SCASB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repne_scasb(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasb_AL_m8, address_size, Register::AL, RepPrefixKind::Repne)
	}

	/// Creates a `SCASW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_scasw(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasw_AX_m16, address_size, Register::AX, rep_prefix)
	}

	/// Creates a `REPE SCASW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repe_scasw(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasw_AX_m16, address_size, Register::AX, RepPrefixKind::Repe)
	}

	/// Creates a `REPNE SCASW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repne_scasw(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasw_AX_m16, address_size, Register::AX, RepPrefixKind::Repne)
	}

	/// Creates a `SCASD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_scasd(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasd_EAX_m32, address_size, Register::EAX, rep_prefix)
	}

	/// Creates a `REPE SCASD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repe_scasd(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasd_EAX_m32, address_size, Register::EAX, RepPrefixKind::Repe)
	}

	/// Creates a `REPNE SCASD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repne_scasd(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasd_EAX_m32, address_size, Register::EAX, RepPrefixKind::Repne)
	}

	/// Creates a `SCASQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_scasq(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasq_RAX_m64, address_size, Register::RAX, rep_prefix)
	}

	/// Creates a `REPE SCASQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repe_scasq(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasq_RAX_m64, address_size, Register::RAX, RepPrefixKind::Repe)
	}

	/// Creates a `REPNE SCASQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repne_scasq(address_size: u32) -> Self {
		super::instruction_internal::with_string_reg_esrdi(Code::Scasq_RAX_m64, address_size, Register::RAX, RepPrefixKind::Repne)
	}

	/// Creates a `INSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_insb(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Insb_m8_DX, address_size, Register::DX, rep_prefix)
	}

	/// Creates a `REP INSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_insb(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Insb_m8_DX, address_size, Register::DX, RepPrefixKind::Repe)
	}

	/// Creates a `INSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_insw(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Insw_m16_DX, address_size, Register::DX, rep_prefix)
	}

	/// Creates a `REP INSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_insw(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Insw_m16_DX, address_size, Register::DX, RepPrefixKind::Repe)
	}

	/// Creates a `INSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_insd(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Insd_m32_DX, address_size, Register::DX, rep_prefix)
	}

	/// Creates a `REP INSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_insd(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Insd_m32_DX, address_size, Register::DX, RepPrefixKind::Repe)
	}

	/// Creates a `STOSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_stosb(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Stosb_m8_AL, address_size, Register::AL, rep_prefix)
	}

	/// Creates a `REP STOSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_stosb(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Stosb_m8_AL, address_size, Register::AL, RepPrefixKind::Repe)
	}

	/// Creates a `STOSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_stosw(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Stosw_m16_AX, address_size, Register::AX, rep_prefix)
	}

	/// Creates a `REP STOSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_stosw(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Stosw_m16_AX, address_size, Register::AX, RepPrefixKind::Repe)
	}

	/// Creates a `STOSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_stosd(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Stosd_m32_EAX, address_size, Register::EAX, rep_prefix)
	}

	/// Creates a `REP STOSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_stosd(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Stosd_m32_EAX, address_size, Register::EAX, RepPrefixKind::Repe)
	}

	/// Creates a `STOSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_stosq(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Stosq_m64_RAX, address_size, Register::RAX, rep_prefix)
	}

	/// Creates a `REP STOSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_stosq(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_reg(Code::Stosq_m64_RAX, address_size, Register::RAX, RepPrefixKind::Repe)
	}

	/// Creates a `CMPSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_cmpsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsb_m8_m8, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `REPE CMPSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repe_cmpsb(address_size: u32) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsb_m8_m8, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REPNE CMPSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repne_cmpsb(address_size: u32) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsb_m8_m8, address_size, Register::None, RepPrefixKind::Repne)
	}

	/// Creates a `CMPSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_cmpsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsw_m16_m16, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `REPE CMPSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repe_cmpsw(address_size: u32) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsw_m16_m16, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REPNE CMPSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repne_cmpsw(address_size: u32) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsw_m16_m16, address_size, Register::None, RepPrefixKind::Repne)
	}

	/// Creates a `CMPSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_cmpsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsd_m32_m32, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `REPE CMPSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repe_cmpsd(address_size: u32) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsd_m32_m32, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REPNE CMPSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repne_cmpsd(address_size: u32) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsd_m32_m32, address_size, Register::None, RepPrefixKind::Repne)
	}

	/// Creates a `CMPSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_cmpsq(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsq_m64_m64, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `REPE CMPSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repe_cmpsq(address_size: u32) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsq_m64_m64, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REPNE CMPSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_repne_cmpsq(address_size: u32) -> Self {
		super::instruction_internal::with_string_segrsi_esrdi(Code::Cmpsq_m64_m64, address_size, Register::None, RepPrefixKind::Repne)
	}

	/// Creates a `MOVSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_movsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_segrsi(Code::Movsb_m8_m8, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `REP MOVSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_movsb(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_segrsi(Code::Movsb_m8_m8, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `MOVSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_movsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_segrsi(Code::Movsw_m16_m16, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `REP MOVSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_movsw(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_segrsi(Code::Movsw_m16_m16, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `MOVSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_movsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_segrsi(Code::Movsd_m32_m32, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `REP MOVSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_movsd(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_segrsi(Code::Movsd_m32_m32, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `MOVSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_movsq(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		super::instruction_internal::with_string_esrdi_segrsi(Code::Movsq_m64_m64, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `REP MOVSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_rep_movsq(address_size: u32) -> Self {
		super::instruction_internal::with_string_esrdi_segrsi(Code::Movsq_m64_m64, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `MASKMOVQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `register1`: Register
	/// * `register2`: Register
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_maskmovq(address_size: u32, register1: Register, register2: Register, segment_prefix: Register) -> Self {
		super::instruction_internal::with_maskmov(Code::Maskmovq_rDI_mm_mm, address_size, register1, register2, segment_prefix)
	}

	/// Creates a `MASKMOVDQU` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `register1`: Register
	/// * `register2`: Register
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_maskmovdqu(address_size: u32, register1: Register, register2: Register, segment_prefix: Register) -> Self {
		super::instruction_internal::with_maskmov(Code::Maskmovdqu_rDI_xmm_xmm, address_size, register1, register2, segment_prefix)
	}

	/// Creates a `VMASKMOVDQU` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `register1`: Register
	/// * `register2`: Register
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[cfg_attr(has_must_use, must_use)]
	#[inline]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_vmaskmovdqu(address_size: u32, register1: Register, register2: Register, segment_prefix: Register) -> Self {
		super::instruction_internal::with_maskmov(Code::VEX_Vmaskmovdqu_rDI_xmm_xmm, address_size, register1, register2, segment_prefix)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_1(b0: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 1);

		instruction.set_declare_byte_value(0, b0);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_2(b0: u8, b1: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 2);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_3(b0: u8, b1: u8, b2: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 3);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_4(b0: u8, b1: u8, b2: u8, b3: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 4);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_5(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 5);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_6(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 6);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_7(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 7);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_8(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 8);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);
		instruction.set_declare_byte_value(7, b7);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_9(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 9);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);
		instruction.set_declare_byte_value(7, b7);
		instruction.set_declare_byte_value(8, b8);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_10(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 10);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);
		instruction.set_declare_byte_value(7, b7);
		instruction.set_declare_byte_value(8, b8);
		instruction.set_declare_byte_value(9, b9);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_11(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 11);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);
		instruction.set_declare_byte_value(7, b7);
		instruction.set_declare_byte_value(8, b8);
		instruction.set_declare_byte_value(9, b9);
		instruction.set_declare_byte_value(10, b10);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_12(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 12);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);
		instruction.set_declare_byte_value(7, b7);
		instruction.set_declare_byte_value(8, b8);
		instruction.set_declare_byte_value(9, b9);
		instruction.set_declare_byte_value(10, b10);
		instruction.set_declare_byte_value(11, b11);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_13(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 13);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);
		instruction.set_declare_byte_value(7, b7);
		instruction.set_declare_byte_value(8, b8);
		instruction.set_declare_byte_value(9, b9);
		instruction.set_declare_byte_value(10, b10);
		instruction.set_declare_byte_value(11, b11);
		instruction.set_declare_byte_value(12, b12);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	/// * `b13`: Byte 13
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_14(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 14);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);
		instruction.set_declare_byte_value(7, b7);
		instruction.set_declare_byte_value(8, b8);
		instruction.set_declare_byte_value(9, b9);
		instruction.set_declare_byte_value(10, b10);
		instruction.set_declare_byte_value(11, b11);
		instruction.set_declare_byte_value(12, b12);
		instruction.set_declare_byte_value(13, b13);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	/// * `b13`: Byte 13
	/// * `b14`: Byte 14
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_15(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8, b14: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 15);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);
		instruction.set_declare_byte_value(7, b7);
		instruction.set_declare_byte_value(8, b8);
		instruction.set_declare_byte_value(9, b9);
		instruction.set_declare_byte_value(10, b10);
		instruction.set_declare_byte_value(11, b11);
		instruction.set_declare_byte_value(12, b12);
		instruction.set_declare_byte_value(13, b13);
		instruction.set_declare_byte_value(14, b14);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	/// * `b13`: Byte 13
	/// * `b14`: Byte 14
	/// * `b15`: Byte 15
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte_16(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8, b14: u8, b15: u8) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 16);

		instruction.set_declare_byte_value(0, b0);
		instruction.set_declare_byte_value(1, b1);
		instruction.set_declare_byte_value(2, b2);
		instruction.set_declare_byte_value(3, b3);
		instruction.set_declare_byte_value(4, b4);
		instruction.set_declare_byte_value(5, b5);
		instruction.set_declare_byte_value(6, b6);
		instruction.set_declare_byte_value(7, b7);
		instruction.set_declare_byte_value(8, b8);
		instruction.set_declare_byte_value(9, b9);
		instruction.set_declare_byte_value(10, b10);
		instruction.set_declare_byte_value(11, b11);
		instruction.set_declare_byte_value(12, b12);
		instruction.set_declare_byte_value(13, b13);
		instruction.set_declare_byte_value(14, b14);
		instruction.set_declare_byte_value(15, b15);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// - Panics if `data.len()` is not 1-16
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_byte(data: &[u8]) -> Self {
		if data.len().wrapping_sub(1) > 16 - 1 {
			panic!();
		}

		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareByte);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32);

		for i in data.iter().enumerate() {
			instruction.set_declare_byte_value(i.0, *i.1);
		}

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_word_1(w0: u16) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 1);

		instruction.set_declare_word_value(0, w0);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_word_2(w0: u16, w1: u16) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 2);

		instruction.set_declare_word_value(0, w0);
		instruction.set_declare_word_value(1, w1);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_word_3(w0: u16, w1: u16, w2: u16) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 3);

		instruction.set_declare_word_value(0, w0);
		instruction.set_declare_word_value(1, w1);
		instruction.set_declare_word_value(2, w2);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_word_4(w0: u16, w1: u16, w2: u16, w3: u16) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 4);

		instruction.set_declare_word_value(0, w0);
		instruction.set_declare_word_value(1, w1);
		instruction.set_declare_word_value(2, w2);
		instruction.set_declare_word_value(3, w3);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_word_5(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 5);

		instruction.set_declare_word_value(0, w0);
		instruction.set_declare_word_value(1, w1);
		instruction.set_declare_word_value(2, w2);
		instruction.set_declare_word_value(3, w3);
		instruction.set_declare_word_value(4, w4);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	/// * `w5`: Word 5
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_word_6(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16, w5: u16) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 6);

		instruction.set_declare_word_value(0, w0);
		instruction.set_declare_word_value(1, w1);
		instruction.set_declare_word_value(2, w2);
		instruction.set_declare_word_value(3, w3);
		instruction.set_declare_word_value(4, w4);
		instruction.set_declare_word_value(5, w5);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	/// * `w5`: Word 5
	/// * `w6`: Word 6
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_word_7(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16, w5: u16, w6: u16) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 7);

		instruction.set_declare_word_value(0, w0);
		instruction.set_declare_word_value(1, w1);
		instruction.set_declare_word_value(2, w2);
		instruction.set_declare_word_value(3, w3);
		instruction.set_declare_word_value(4, w4);
		instruction.set_declare_word_value(5, w5);
		instruction.set_declare_word_value(6, w6);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	/// * `w5`: Word 5
	/// * `w6`: Word 6
	/// * `w7`: Word 7
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_word_8(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16, w5: u16, w6: u16, w7: u16) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 8);

		instruction.set_declare_word_value(0, w0);
		instruction.set_declare_word_value(1, w1);
		instruction.set_declare_word_value(2, w2);
		instruction.set_declare_word_value(3, w3);
		instruction.set_declare_word_value(4, w4);
		instruction.set_declare_word_value(5, w5);
		instruction.set_declare_word_value(6, w6);
		instruction.set_declare_word_value(7, w7);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// - Panics if `data.len()` is not 2-16 or not a multiple of 2
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	#[allow(trivial_casts)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::cast_ptr_alignment))]
	pub fn with_declare_word_slice_u8(data: &[u8]) -> Self {
		if data.len().wrapping_sub(1) > 16 - 1 || (data.len() & 1) != 0 {
			panic!();
		}

		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32 / 2);

		for i in 0..data.len() / 2 {
			let v = unsafe { u16::from_le(ptr::read_unaligned(data.get_unchecked(i * 2) as *const _ as *const u16)) };
			instruction.set_declare_word_value(i, v);
		}

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// - Panics if `data.len()` is not 1-8
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_word(data: &[u16]) -> Self {
		if data.len().wrapping_sub(1) > 8 - 1 {
			panic!();
		}

		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareWord);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32);

		for i in data.iter().enumerate() {
			instruction.set_declare_word_value(i.0, *i.1);
		}

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_dword_1(d0: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareDword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 1);

		instruction.set_declare_dword_value(0, d0);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	/// * `d1`: Dword 1
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_dword_2(d0: u32, d1: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareDword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 2);

		instruction.set_declare_dword_value(0, d0);
		instruction.set_declare_dword_value(1, d1);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	/// * `d1`: Dword 1
	/// * `d2`: Dword 2
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_dword_3(d0: u32, d1: u32, d2: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareDword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 3);

		instruction.set_declare_dword_value(0, d0);
		instruction.set_declare_dword_value(1, d1);
		instruction.set_declare_dword_value(2, d2);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	/// * `d1`: Dword 1
	/// * `d2`: Dword 2
	/// * `d3`: Dword 3
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_dword_4(d0: u32, d1: u32, d2: u32, d3: u32) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareDword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 4);

		instruction.set_declare_dword_value(0, d0);
		instruction.set_declare_dword_value(1, d1);
		instruction.set_declare_dword_value(2, d2);
		instruction.set_declare_dword_value(3, d3);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Panics
	///
	/// - Panics if `data.len()` is not 4-16 or not a multiple of 4
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	#[allow(trivial_casts)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::cast_ptr_alignment))]
	pub fn with_declare_dword_slice_u8(data: &[u8]) -> Self {
		if data.len().wrapping_sub(1) > 16 - 1 || (data.len() & 3) != 0 {
			panic!();
		}

		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareDword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32 / 4);

		for i in 0..data.len() / 4 {
			let v = unsafe { u32::from_le(ptr::read_unaligned(data.get_unchecked(i * 4) as *const _ as *const u32)) };
			instruction.set_declare_dword_value(i, v);
		}

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Panics
	///
	/// - Panics if `data.len()` is not 1-4
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_dword(data: &[u32]) -> Self {
		if data.len().wrapping_sub(1) > 4 - 1 {
			panic!();
		}

		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareDword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32);

		for i in data.iter().enumerate() {
			instruction.set_declare_dword_value(i.0, *i.1);
		}

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `q0`: Qword 0
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_qword_1(q0: u64) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareQword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 1);

		instruction.set_declare_qword_value(0, q0);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Panics
	///
	/// Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `q0`: Qword 0
	/// * `q1`: Qword 1
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_qword_2(q0: u64, q1: u64) -> Self {
		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareQword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, 2);

		instruction.set_declare_qword_value(0, q0);
		instruction.set_declare_qword_value(1, q1);

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Panics
	///
	/// - Panics if `data.len()` is not 8-16 or not a multiple of 8
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	#[allow(trivial_casts)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::cast_ptr_alignment))]
	pub fn with_declare_qword_slice_u8(data: &[u8]) -> Self {
		if data.len().wrapping_sub(1) > 16 - 1 || (data.len() & 7) != 0 {
			panic!();
		}

		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareQword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32 / 8);

		for i in 0..data.len() / 8 {
			let v = unsafe { u64::from_le(ptr::read_unaligned(data.get_unchecked(i * 8) as *const _ as *const u64)) };
			instruction.set_declare_qword_value(i, v);
		}

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Panics
	///
	/// - Panics if `data.len()` is not 1-2
	/// - Panics if `db` feature wasn't enabled
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	#[cfg_attr(feature = "cargo-fmt", rustfmt::skip)]
	pub fn with_declare_qword(data: &[u64]) -> Self {
		if data.len().wrapping_sub(1) > 2 - 1 {
			panic!();
		}

		let mut instruction = Self::default();
		super::instruction_internal::internal_set_code(&mut instruction, Code::DeclareQword);
		super::instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32);

		for i in data.iter().enumerate() {
			instruction.set_declare_qword_value(i.0, *i.1);
		}

		debug_assert_eq!(0, instruction.op_count());
		instruction
	}
	// GENERATOR-END: Create
}

impl Eq for Instruction {}

impl PartialEq<Instruction> for Instruction {
	#[cfg_attr(has_must_use, must_use)]
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	fn eq(&self, other: &Self) -> bool {
		((self.code_flags ^ other.code_flags) & !CodeFlags::EQUALS_IGNORE_MASK) == 0
			&& ((self.op_kind_flags ^ other.op_kind_flags) & !OpKindFlags::EQUALS_IGNORE_MASK) == 0
			&& self.immediate == other.immediate
			&& self.mem_displ == other.mem_displ
			&& self.memory_flags == other.memory_flags
			&& self.mem_base_reg == other.mem_base_reg
			&& self.mem_index_reg == other.mem_index_reg
			&& self.reg0 == other.reg0
			&& self.reg1 == other.reg1
			&& self.reg2 == other.reg2
			&& self.reg3 == other.reg3
	}
}

impl Hash for Instruction {
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	fn hash<'a, H: Hasher>(&self, state: &'a mut H) {
		state.write_u32(self.code_flags & !CodeFlags::EQUALS_IGNORE_MASK);
		state.write_u32(self.op_kind_flags & !OpKindFlags::EQUALS_IGNORE_MASK);
		state.write_u32(self.immediate);
		state.write_u32(self.mem_displ);
		state.write_u16(self.memory_flags);
		state.write_u8(self.mem_base_reg);
		state.write_u8(self.mem_index_reg);
		state.write_u8(self.reg0);
		state.write_u8(self.reg1);
		state.write_u8(self.reg2);
		state.write_u8(self.reg3);
	}
}

#[cfg(any(feature = "gas", feature = "intel", feature = "masm", feature = "nasm"))]
struct FmtFormatterOutput<'a, 'b: 'a> {
	f: &'a mut fmt::Formatter<'b>,
	result: fmt::Result,
}
#[cfg(any(feature = "gas", feature = "intel", feature = "masm", feature = "nasm"))]
impl<'a, 'b: 'a> FmtFormatterOutput<'a, 'b> {
	fn new(f: &'a mut fmt::Formatter<'b>) -> Self {
		Self { f, result: Ok(()) }
	}
}
#[cfg(any(feature = "gas", feature = "intel", feature = "masm", feature = "nasm"))]
impl<'a, 'b: 'a> FormatterOutput for FmtFormatterOutput<'a, 'b> {
	fn write(&mut self, text: &str, _kind: FormatterTextKind) {
		if self.result.is_ok() {
			self.result = self.f.write_str(text);
		}
	}
}

#[cfg(any(feature = "gas", feature = "intel", feature = "masm", feature = "nasm", feature = "fast_fmt"))]
impl fmt::Display for Instruction {
	#[cfg_attr(feature = "cargo-clippy", allow(clippy::missing_inline_in_public_items))]
	fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> fmt::Result {
		//
		// if the order of #[cfg()] checks gets updated, also update the `display_trait()` test method
		//
		#[cfg(any(feature = "gas", feature = "intel", feature = "masm", feature = "nasm"))]
		{
			#[cfg(feature = "masm")]
			let mut formatter = MasmFormatter::new();

			#[cfg(all(not(feature = "masm"), feature = "nasm"))]
			let mut formatter = NasmFormatter::new();

			#[cfg(all(not(feature = "masm"), not(feature = "nasm"), feature = "intel"))]
			let mut formatter = IntelFormatter::new();

			#[cfg(all(not(feature = "masm"), not(feature = "nasm"), not(feature = "intel"), feature = "gas"))]
			let mut formatter = GasFormatter::new();

			let mut output = FmtFormatterOutput::new(f);
			formatter.format(self, &mut output);
			output.result
		}
		#[cfg(not(any(feature = "gas", feature = "intel", feature = "masm", feature = "nasm")))]
		{
			let mut formatter = FastFormatter::new();

			let mut output = String::new();
			formatter.format(self, &mut output);
			f.write_str(&output)
		}
	}
}
