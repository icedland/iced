// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// âš ï¸This file was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸

#![allow(clippy::missing_errors_doc)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]

use crate::IcedError;

#[rustfmt::skip]
pub trait CodeAsmAaa {
	fn aaa(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAad<T> {
	fn aad(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAadd<T, U> {
	fn aadd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAam<T> {
	fn aam(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAand<T, U> {
	fn aand(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAas {
	fn aas(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAdc<T, U> {
	fn adc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAdcx<T, U> {
	fn adcx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAdd<T, U> {
	fn add(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAddpd<T, U> {
	fn addpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAddps<T, U> {
	fn addps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAddsd<T, U> {
	fn addsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAddss<T, U> {
	fn addss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAddsubpd<T, U> {
	fn addsubpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAddsubps<T, U> {
	fn addsubps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAdox<T, U> {
	fn adox(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesdec<T, U> {
	fn aesdec(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesdec128kl<T, U> {
	fn aesdec128kl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesdec256kl<T, U> {
	fn aesdec256kl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesdeclast<T, U> {
	fn aesdeclast(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesdecwide128kl<T> {
	fn aesdecwide128kl(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesdecwide256kl<T> {
	fn aesdecwide256kl(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesenc<T, U> {
	fn aesenc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesenc128kl<T, U> {
	fn aesenc128kl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesenc256kl<T, U> {
	fn aesenc256kl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesenclast<T, U> {
	fn aesenclast(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesencwide128kl<T> {
	fn aesencwide128kl(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesencwide256kl<T> {
	fn aesencwide256kl(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAesimc<T, U> {
	fn aesimc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAeskeygenassist<T, U, V> {
	fn aeskeygenassist(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAltinst {
	fn altinst(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAnd<T, U> {
	fn and(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAndn<T, U, V> {
	fn andn(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAndnpd<T, U> {
	fn andnpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAndnps<T, U> {
	fn andnps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAndpd<T, U> {
	fn andpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAndps<T, U> {
	fn andps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAor<T, U> {
	fn aor(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmArpl<T, U> {
	fn arpl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmAxor<T, U> {
	fn axor(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBb0_reset {
	fn bb0_reset(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBb1_reset {
	fn bb1_reset(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBextr<T, U, V> {
	fn bextr(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlcfill<T, U> {
	fn blcfill(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlci<T, U> {
	fn blci(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlcic<T, U> {
	fn blcic(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlcmsk<T, U> {
	fn blcmsk(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlcs<T, U> {
	fn blcs(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlendpd<T, U, V> {
	fn blendpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlendps<T, U, V> {
	fn blendps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlendvpd<T, U> {
	fn blendvpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlendvps<T, U> {
	fn blendvps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlsfill<T, U> {
	fn blsfill(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlsi<T, U> {
	fn blsi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlsic<T, U> {
	fn blsic(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlsmsk<T, U> {
	fn blsmsk(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBlsr<T, U> {
	fn blsr(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBndcl<T, U> {
	fn bndcl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBndcn<T, U> {
	fn bndcn(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBndcu<T, U> {
	fn bndcu(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBndldx<T, U> {
	fn bndldx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBndmk<T, U> {
	fn bndmk(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBndmov<T, U> {
	fn bndmov(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBndstx<T, U> {
	fn bndstx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBound<T, U> {
	fn bound(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBsf<T, U> {
	fn bsf(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBsr<T, U> {
	fn bsr(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBswap<T> {
	fn bswap(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBt<T, U> {
	fn bt(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBtc<T, U> {
	fn btc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBtr<T, U> {
	fn btr(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBts<T, U> {
	fn bts(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmBzhi<T, U, V> {
	fn bzhi(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCall<T> {
	fn call(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCbw {
	fn cbw(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCcs_encrypt {
	fn ccs_encrypt(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCcs_hash {
	fn ccs_hash(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCdq {
	fn cdq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCdqe {
	fn cdqe(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCl1invmb {
	fn cl1invmb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClac {
	fn clac(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClc {
	fn clc(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCld {
	fn cld(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCldemote<T> {
	fn cldemote(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClflush<T> {
	fn clflush(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClflushopt<T> {
	fn clflushopt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClgi {
	fn clgi(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCli {
	fn cli(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClrssbsy<T> {
	fn clrssbsy(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClts {
	fn clts(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClui {
	fn clui(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClwb<T> {
	fn clwb(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmClzero {
	fn clzero(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmc {
	fn cmc(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmova<T, U> {
	fn cmova(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovae<T, U> {
	fn cmovae(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovb<T, U> {
	fn cmovb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovbe<T, U> {
	fn cmovbe(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovc<T, U> {
	fn cmovc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmove<T, U> {
	fn cmove(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovg<T, U> {
	fn cmovg(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovge<T, U> {
	fn cmovge(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovl<T, U> {
	fn cmovl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovle<T, U> {
	fn cmovle(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovna<T, U> {
	fn cmovna(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovnae<T, U> {
	fn cmovnae(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovnb<T, U> {
	fn cmovnb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovnbe<T, U> {
	fn cmovnbe(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovnc<T, U> {
	fn cmovnc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovne<T, U> {
	fn cmovne(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovng<T, U> {
	fn cmovng(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovnge<T, U> {
	fn cmovnge(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovnl<T, U> {
	fn cmovnl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovnle<T, U> {
	fn cmovnle(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovno<T, U> {
	fn cmovno(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovnp<T, U> {
	fn cmovnp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovns<T, U> {
	fn cmovns(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovnz<T, U> {
	fn cmovnz(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovo<T, U> {
	fn cmovo(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovp<T, U> {
	fn cmovp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovpe<T, U> {
	fn cmovpe(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovpo<T, U> {
	fn cmovpo(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovs<T, U> {
	fn cmovs(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmovz<T, U> {
	fn cmovz(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmp<T, U> {
	fn cmp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpbexadd<T, U, V> {
	fn cmpbexadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpbxadd<T, U, V> {
	fn cmpbxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpcxadd<T, U, V> {
	fn cmpcxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpeqpd<T, U> {
	fn cmpeqpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpeqps<T, U> {
	fn cmpeqps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpeqsd<T, U> {
	fn cmpeqsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpeqss<T, U> {
	fn cmpeqss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmplepd<T, U> {
	fn cmplepd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpleps<T, U> {
	fn cmpleps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmplesd<T, U> {
	fn cmplesd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpless<T, U> {
	fn cmpless(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmplexadd<T, U, V> {
	fn cmplexadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpltpd<T, U> {
	fn cmpltpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpltps<T, U> {
	fn cmpltps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpltsd<T, U> {
	fn cmpltsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpltss<T, U> {
	fn cmpltss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmplxadd<T, U, V> {
	fn cmplxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnaexadd<T, U, V> {
	fn cmpnaexadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnaxadd<T, U, V> {
	fn cmpnaxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnbexadd<T, U, V> {
	fn cmpnbexadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnbxadd<T, U, V> {
	fn cmpnbxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpncxadd<T, U, V> {
	fn cmpncxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpneqpd<T, U> {
	fn cmpneqpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpneqps<T, U> {
	fn cmpneqps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpneqsd<T, U> {
	fn cmpneqsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpneqss<T, U> {
	fn cmpneqss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpngexadd<T, U, V> {
	fn cmpngexadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpngxadd<T, U, V> {
	fn cmpngxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnlepd<T, U> {
	fn cmpnlepd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnleps<T, U> {
	fn cmpnleps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnlesd<T, U> {
	fn cmpnlesd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnless<T, U> {
	fn cmpnless(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnlexadd<T, U, V> {
	fn cmpnlexadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnltpd<T, U> {
	fn cmpnltpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnltps<T, U> {
	fn cmpnltps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnltsd<T, U> {
	fn cmpnltsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnltss<T, U> {
	fn cmpnltss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnlxadd<T, U, V> {
	fn cmpnlxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnoxadd<T, U, V> {
	fn cmpnoxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnpxadd<T, U, V> {
	fn cmpnpxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnsxadd<T, U, V> {
	fn cmpnsxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpnzxadd<T, U, V> {
	fn cmpnzxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpordpd<T, U> {
	fn cmpordpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpordps<T, U> {
	fn cmpordps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpordsd<T, U> {
	fn cmpordsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpordss<T, U> {
	fn cmpordss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpoxadd<T, U, V> {
	fn cmpoxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmppd<T, U, V> {
	fn cmppd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmppexadd<T, U, V> {
	fn cmppexadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmppoxadd<T, U, V> {
	fn cmppoxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpps<T, U, V> {
	fn cmpps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmppxadd<T, U, V> {
	fn cmppxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpsb {
	fn cmpsb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpsd {
	fn cmpsd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpsd3<T, U, V> {
	fn cmpsd_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpsq {
	fn cmpsq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpss<T, U, V> {
	fn cmpss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpsw {
	fn cmpsw(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpsxadd<T, U, V> {
	fn cmpsxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpunordpd<T, U> {
	fn cmpunordpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpunordps<T, U> {
	fn cmpunordps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpunordsd<T, U> {
	fn cmpunordsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpunordss<T, U> {
	fn cmpunordss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpxchg<T, U> {
	fn cmpxchg(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpxchg16b<T> {
	fn cmpxchg16b(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpxchg8b<T> {
	fn cmpxchg8b(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCmpzxadd<T, U, V> {
	fn cmpzxadd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmComisd<T, U> {
	fn comisd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmComiss<T, U> {
	fn comiss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCpu_read {
	fn cpu_read(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCpu_write {
	fn cpu_write(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCpuid {
	fn cpuid(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCqo {
	fn cqo(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCrc32<T, U> {
	fn crc32(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtdq2pd<T, U> {
	fn cvtdq2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtdq2ps<T, U> {
	fn cvtdq2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtpd2dq<T, U> {
	fn cvtpd2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtpd2pi<T, U> {
	fn cvtpd2pi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtpd2ps<T, U> {
	fn cvtpd2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtpi2pd<T, U> {
	fn cvtpi2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtpi2ps<T, U> {
	fn cvtpi2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtps2dq<T, U> {
	fn cvtps2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtps2pd<T, U> {
	fn cvtps2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtps2pi<T, U> {
	fn cvtps2pi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtsd2si<T, U> {
	fn cvtsd2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtsd2ss<T, U> {
	fn cvtsd2ss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtsi2sd<T, U> {
	fn cvtsi2sd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtsi2ss<T, U> {
	fn cvtsi2ss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtss2sd<T, U> {
	fn cvtss2sd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvtss2si<T, U> {
	fn cvtss2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvttpd2dq<T, U> {
	fn cvttpd2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvttpd2pi<T, U> {
	fn cvttpd2pi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvttps2dq<T, U> {
	fn cvttps2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvttps2pi<T, U> {
	fn cvttps2pi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvttsd2si<T, U> {
	fn cvttsd2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCvttss2si<T, U> {
	fn cvttss2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCwd {
	fn cwd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmCwde {
	fn cwde(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDaa {
	fn daa(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDas {
	fn das(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDec<T> {
	fn dec(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDiv<T> {
	fn div(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDivpd<T, U> {
	fn divpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDivps<T, U> {
	fn divps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDivsd<T, U> {
	fn divsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDivss<T, U> {
	fn divss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDmint {
	fn dmint(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDppd<T, U, V> {
	fn dppd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmDpps<T, U, V> {
	fn dpps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEmms {
	fn emms(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEncls {
	fn encls(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEnclu {
	fn enclu(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEnclv {
	fn enclv(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEncodekey128<T, U> {
	fn encodekey128(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEncodekey256<T, U> {
	fn encodekey256(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEndbr32 {
	fn endbr32(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEndbr64 {
	fn endbr64(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEnqcmd<T, U> {
	fn enqcmd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEnqcmds<T, U> {
	fn enqcmds(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEnter<T, U> {
	fn enter(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmErets {
	fn erets(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmEretu {
	fn eretu(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmExtractps<T, U, V> {
	fn extractps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmExtrq<T, U> {
	fn extrq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmExtrq3<T, U, V> {
	fn extrq_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmF2xm1 {
	fn f2xm1(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFabs {
	fn fabs(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFadd<T> {
	fn fadd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFadd2<T, U> {
	fn fadd_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFaddp<T, U> {
	fn faddp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFbld<T> {
	fn fbld(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFbstp<T> {
	fn fbstp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFchs {
	fn fchs(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFclex {
	fn fclex(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcmovb<T, U> {
	fn fcmovb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcmovbe<T, U> {
	fn fcmovbe(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcmove<T, U> {
	fn fcmove(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcmovnb<T, U> {
	fn fcmovnb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcmovnbe<T, U> {
	fn fcmovnbe(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcmovne<T, U> {
	fn fcmovne(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcmovnu<T, U> {
	fn fcmovnu(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcmovu<T, U> {
	fn fcmovu(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcom<T> {
	fn fcom(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcom2<T, U> {
	fn fcom_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcomi<T, U> {
	fn fcomi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcomip<T, U> {
	fn fcomip(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcomp<T> {
	fn fcomp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcomp2<T, U> {
	fn fcomp_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcompp {
	fn fcompp(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFcos {
	fn fcos(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFdecstp {
	fn fdecstp(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFdisi {
	fn fdisi(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFdiv<T> {
	fn fdiv(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFdiv2<T, U> {
	fn fdiv_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFdivp<T, U> {
	fn fdivp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFdivr<T> {
	fn fdivr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFdivr2<T, U> {
	fn fdivr_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFdivrp<T, U> {
	fn fdivrp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFemms {
	fn femms(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFeni {
	fn feni(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFfree<T> {
	fn ffree(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFfreep<T> {
	fn ffreep(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFiadd<T> {
	fn fiadd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFicom<T> {
	fn ficom(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFicomp<T> {
	fn ficomp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFidiv<T> {
	fn fidiv(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFidivr<T> {
	fn fidivr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFild<T> {
	fn fild(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFimul<T> {
	fn fimul(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFincstp {
	fn fincstp(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFinit {
	fn finit(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFist<T> {
	fn fist(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFistp<T> {
	fn fistp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFisttp<T> {
	fn fisttp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFisub<T> {
	fn fisub(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFisubr<T> {
	fn fisubr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFld<T> {
	fn fld(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFld1 {
	fn fld1(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFldcw<T> {
	fn fldcw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFldenv<T> {
	fn fldenv(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFldl2e {
	fn fldl2e(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFldl2t {
	fn fldl2t(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFldlg2 {
	fn fldlg2(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFldln2 {
	fn fldln2(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFldpi {
	fn fldpi(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFldz {
	fn fldz(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFmul<T> {
	fn fmul(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFmul2<T, U> {
	fn fmul_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFmulp<T, U> {
	fn fmulp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFnclex {
	fn fnclex(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFndisi {
	fn fndisi(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFneni {
	fn fneni(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFninit {
	fn fninit(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFnop {
	fn fnop(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFnsave<T> {
	fn fnsave(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFnsetpm {
	fn fnsetpm(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFnstcw<T> {
	fn fnstcw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFnstdw<T> {
	fn fnstdw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFnstenv<T> {
	fn fnstenv(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFnstsg<T> {
	fn fnstsg(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFnstsw<T> {
	fn fnstsw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFpatan {
	fn fpatan(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFprem {
	fn fprem(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFprem1 {
	fn fprem1(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFptan {
	fn fptan(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFrndint {
	fn frndint(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFrstor<T> {
	fn frstor(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFrstpm {
	fn frstpm(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsave<T> {
	fn fsave(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFscale {
	fn fscale(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsetpm {
	fn fsetpm(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsin {
	fn fsin(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsincos {
	fn fsincos(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsqrt {
	fn fsqrt(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFst<T> {
	fn fst(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFstcw<T> {
	fn fstcw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFstdw<T> {
	fn fstdw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFstenv<T> {
	fn fstenv(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFstp<T> {
	fn fstp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFstpnce<T> {
	fn fstpnce(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFstsg<T> {
	fn fstsg(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFstsw<T> {
	fn fstsw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsub<T> {
	fn fsub(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsub2<T, U> {
	fn fsub_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsubp<T, U> {
	fn fsubp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsubr<T> {
	fn fsubr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsubr2<T, U> {
	fn fsubr_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFsubrp<T, U> {
	fn fsubrp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFtst {
	fn ftst(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFucom<T, U> {
	fn fucom(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFucomi<T, U> {
	fn fucomi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFucomip<T, U> {
	fn fucomip(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFucomp<T, U> {
	fn fucomp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFucompp {
	fn fucompp(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFxam {
	fn fxam(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFxch<T, U> {
	fn fxch(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFxrstor<T> {
	fn fxrstor(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFxrstor64<T> {
	fn fxrstor64(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFxsave<T> {
	fn fxsave(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFxsave64<T> {
	fn fxsave64(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFxtract {
	fn fxtract(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFyl2x {
	fn fyl2x(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmFyl2xp1 {
	fn fyl2xp1(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmGetsec {
	fn getsec(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmGetsecq {
	fn getsecq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmGf2p8affineinvqb<T, U, V> {
	fn gf2p8affineinvqb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmGf2p8affineqb<T, U, V> {
	fn gf2p8affineqb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmGf2p8mulb<T, U> {
	fn gf2p8mulb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmHaddpd<T, U> {
	fn haddpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmHaddps<T, U> {
	fn haddps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmHlt {
	fn hlt(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmHreset<T> {
	fn hreset(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmHsubpd<T, U> {
	fn hsubpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmHsubps<T, U> {
	fn hsubps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmIbts<T, U> {
	fn ibts(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmIdiv<T> {
	fn idiv(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmImul<T> {
	fn imul(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmImul2<T, U> {
	fn imul_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmImul3<T, U, V> {
	fn imul_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmIn<T, U> {
	fn in_(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInc<T> {
	fn inc(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmIncsspd<T> {
	fn incsspd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmIncsspq<T> {
	fn incsspq(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInsb {
	fn insb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInsd {
	fn insd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInsertps<T, U, V> {
	fn insertps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInsertq<T, U> {
	fn insertq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInsertq4<T, U, V, W> {
	fn insertq_4(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInsw {
	fn insw(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInt<T> {
	fn int(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInt1 {
	fn int1(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInt3 {
	fn int3(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInto {
	fn into(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInvd {
	fn invd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInvept<T, U> {
	fn invept(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInvlpg<T> {
	fn invlpg(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInvlpga {
	fn invlpga(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInvlpgb {
	fn invlpgb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInvpcid<T, U> {
	fn invpcid(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmInvvpid<T, U> {
	fn invvpid(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmIret {
	fn iret(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmIretd {
	fn iretd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmIretq {
	fn iretq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJa<T> {
	fn ja(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJae<T> {
	fn jae(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJb<T> {
	fn jb(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJbe<T> {
	fn jbe(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJc<T> {
	fn jc(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJcxz<T> {
	fn jcxz(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJe<T> {
	fn je(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJecxz<T> {
	fn jecxz(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJg<T> {
	fn jg(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJge<T> {
	fn jge(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJl<T> {
	fn jl(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJle<T> {
	fn jle(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJmp<T> {
	fn jmp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJmpe<T> {
	fn jmpe(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJna<T> {
	fn jna(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJnae<T> {
	fn jnae(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJnb<T> {
	fn jnb(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJnbe<T> {
	fn jnbe(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJnc<T> {
	fn jnc(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJne<T> {
	fn jne(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJng<T> {
	fn jng(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJnge<T> {
	fn jnge(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJnl<T> {
	fn jnl(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJnle<T> {
	fn jnle(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJno<T> {
	fn jno(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJnp<T> {
	fn jnp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJns<T> {
	fn jns(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJnz<T> {
	fn jnz(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJo<T> {
	fn jo(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJp<T> {
	fn jp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJpe<T> {
	fn jpe(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJpo<T> {
	fn jpo(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJrcxz<T> {
	fn jrcxz(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJs<T> {
	fn js(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmJz<T> {
	fn jz(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKaddb<T, U, V> {
	fn kaddb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKaddd<T, U, V> {
	fn kaddd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKaddq<T, U, V> {
	fn kaddq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKaddw<T, U, V> {
	fn kaddw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKandb<T, U, V> {
	fn kandb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKandd<T, U, V> {
	fn kandd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKandnb<T, U, V> {
	fn kandnb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKandnd<T, U, V> {
	fn kandnd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKandnq<T, U, V> {
	fn kandnq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKandnw<T, U, V> {
	fn kandnw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKandq<T, U, V> {
	fn kandq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKandw<T, U, V> {
	fn kandw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKmovb<T, U> {
	fn kmovb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKmovd<T, U> {
	fn kmovd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKmovq<T, U> {
	fn kmovq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKmovw<T, U> {
	fn kmovw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKnotb<T, U> {
	fn knotb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKnotd<T, U> {
	fn knotd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKnotq<T, U> {
	fn knotq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKnotw<T, U> {
	fn knotw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKorb<T, U, V> {
	fn korb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKord<T, U, V> {
	fn kord(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKorq<T, U, V> {
	fn korq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKortestb<T, U> {
	fn kortestb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKortestd<T, U> {
	fn kortestd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKortestq<T, U> {
	fn kortestq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKortestw<T, U> {
	fn kortestw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKorw<T, U, V> {
	fn korw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKshiftlb<T, U, V> {
	fn kshiftlb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKshiftld<T, U, V> {
	fn kshiftld(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKshiftlq<T, U, V> {
	fn kshiftlq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKshiftlw<T, U, V> {
	fn kshiftlw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKshiftrb<T, U, V> {
	fn kshiftrb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKshiftrd<T, U, V> {
	fn kshiftrd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKshiftrq<T, U, V> {
	fn kshiftrq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKshiftrw<T, U, V> {
	fn kshiftrw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKtestb<T, U> {
	fn ktestb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKtestd<T, U> {
	fn ktestd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKtestq<T, U> {
	fn ktestq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKtestw<T, U> {
	fn ktestw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKunpckbw<T, U, V> {
	fn kunpckbw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKunpckdq<T, U, V> {
	fn kunpckdq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKunpckwd<T, U, V> {
	fn kunpckwd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKxnorb<T, U, V> {
	fn kxnorb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKxnord<T, U, V> {
	fn kxnord(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKxnorq<T, U, V> {
	fn kxnorq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKxnorw<T, U, V> {
	fn kxnorw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKxorb<T, U, V> {
	fn kxorb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKxord<T, U, V> {
	fn kxord(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKxorq<T, U, V> {
	fn kxorq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmKxorw<T, U, V> {
	fn kxorw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLahf {
	fn lahf(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLar<T, U> {
	fn lar(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLddqu<T, U> {
	fn lddqu(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLdmxcsr<T> {
	fn ldmxcsr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLds<T, U> {
	fn lds(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLdtilecfg<T> {
	fn ldtilecfg(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLea<T, U> {
	fn lea(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLeave {
	fn leave(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLes<T, U> {
	fn les(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLfence {
	fn lfence(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLfs<T, U> {
	fn lfs(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLgdt<T> {
	fn lgdt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLgs<T, U> {
	fn lgs(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLidt<T> {
	fn lidt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLkgs<T> {
	fn lkgs(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLldt<T> {
	fn lldt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLlwpcb<T> {
	fn llwpcb(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLmsw<T> {
	fn lmsw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLoadall {
	fn loadall(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLoadiwkey<T, U> {
	fn loadiwkey(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLodsb {
	fn lodsb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLodsd {
	fn lodsd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLodsq {
	fn lodsq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLodsw {
	fn lodsw(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLoop<T> {
	fn loop_(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLoope<T> {
	fn loope(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLoopne<T> {
	fn loopne(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLoopnz<T> {
	fn loopnz(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLoopz<T> {
	fn loopz(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLsl<T, U> {
	fn lsl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLss<T, U> {
	fn lss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLtr<T> {
	fn ltr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLwpins<T, U, V> {
	fn lwpins(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLwpval<T, U, V> {
	fn lwpval(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmLzcnt<T, U> {
	fn lzcnt(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMaskmovdqu<T, U> {
	fn maskmovdqu(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMaskmovq<T, U> {
	fn maskmovq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMaxpd<T, U> {
	fn maxpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMaxps<T, U> {
	fn maxps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMaxsd<T, U> {
	fn maxsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMaxss<T, U> {
	fn maxss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMcommit {
	fn mcommit(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMfence {
	fn mfence(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMinpd<T, U> {
	fn minpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMinps<T, U> {
	fn minps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMinsd<T, U> {
	fn minsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMinss<T, U> {
	fn minss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMonitor {
	fn monitor(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMonitorx {
	fn monitorx(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMontmul {
	fn montmul(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMov<T, U> {
	fn mov(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovapd<T, U> {
	fn movapd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovaps<T, U> {
	fn movaps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovbe<T, U> {
	fn movbe(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovd<T, U> {
	fn movd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovddup<T, U> {
	fn movddup(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovdir64b<T, U> {
	fn movdir64b(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovdiri<T, U> {
	fn movdiri(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovdq2q<T, U> {
	fn movdq2q(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovdqa<T, U> {
	fn movdqa(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovdqu<T, U> {
	fn movdqu(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovhlps<T, U> {
	fn movhlps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovhpd<T, U> {
	fn movhpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovhps<T, U> {
	fn movhps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovlhps<T, U> {
	fn movlhps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovlpd<T, U> {
	fn movlpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovlps<T, U> {
	fn movlps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovmskpd<T, U> {
	fn movmskpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovmskps<T, U> {
	fn movmskps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovntdq<T, U> {
	fn movntdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovntdqa<T, U> {
	fn movntdqa(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovnti<T, U> {
	fn movnti(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovntpd<T, U> {
	fn movntpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovntps<T, U> {
	fn movntps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovntq<T, U> {
	fn movntq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovntsd<T, U> {
	fn movntsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovntss<T, U> {
	fn movntss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovq<T, U> {
	fn movq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovq2dq<T, U> {
	fn movq2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovsb {
	fn movsb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovsd {
	fn movsd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovsd2<T, U> {
	fn movsd_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovshdup<T, U> {
	fn movshdup(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovsldup<T, U> {
	fn movsldup(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovsq {
	fn movsq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovss<T, U> {
	fn movss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovsw {
	fn movsw(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovsx<T, U> {
	fn movsx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovsxd<T, U> {
	fn movsxd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovupd<T, U> {
	fn movupd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovups<T, U> {
	fn movups(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMovzx<T, U> {
	fn movzx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMpsadbw<T, U, V> {
	fn mpsadbw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMul<T> {
	fn mul(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMulpd<T, U> {
	fn mulpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMulps<T, U> {
	fn mulps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMulsd<T, U> {
	fn mulsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMulss<T, U> {
	fn mulss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMulx<T, U, V> {
	fn mulx(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMwait {
	fn mwait(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmMwaitx {
	fn mwaitx(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmNeg<T> {
	fn neg(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmNop {
	fn nop(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmNop1<T> {
	fn nop_1(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmNot<T> {
	fn not(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmOr<T, U> {
	fn or(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmOrpd<T, U> {
	fn orpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmOrps<T, U> {
	fn orps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmOut<T, U> {
	fn out(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmOutsb {
	fn outsb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmOutsd {
	fn outsd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmOutsw {
	fn outsw(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPabsb<T, U> {
	fn pabsb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPabsd<T, U> {
	fn pabsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPabsw<T, U> {
	fn pabsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPackssdw<T, U> {
	fn packssdw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPacksswb<T, U> {
	fn packsswb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPackusdw<T, U> {
	fn packusdw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPackuswb<T, U> {
	fn packuswb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaddb<T, U> {
	fn paddb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaddd<T, U> {
	fn paddd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaddq<T, U> {
	fn paddq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaddsb<T, U> {
	fn paddsb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaddsiw<T, U> {
	fn paddsiw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaddsw<T, U> {
	fn paddsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaddusb<T, U> {
	fn paddusb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaddusw<T, U> {
	fn paddusw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaddw<T, U> {
	fn paddw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPalignr<T, U, V> {
	fn palignr(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPand<T, U> {
	fn pand(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPandn<T, U> {
	fn pandn(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPause {
	fn pause(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPaveb<T, U> {
	fn paveb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPavgb<T, U> {
	fn pavgb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPavgusb<T, U> {
	fn pavgusb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPavgw<T, U> {
	fn pavgw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPblendvb<T, U> {
	fn pblendvb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPblendw<T, U, V> {
	fn pblendw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPbndkb {
	fn pbndkb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPclmulhqhqdq<T, U> {
	fn pclmulhqhqdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPclmulhqlqdq<T, U> {
	fn pclmulhqlqdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPclmullqhqdq<T, U> {
	fn pclmullqhqdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPclmullqlqdq<T, U> {
	fn pclmullqlqdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPclmulqdq<T, U, V> {
	fn pclmulqdq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpeqb<T, U> {
	fn pcmpeqb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpeqd<T, U> {
	fn pcmpeqd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpeqq<T, U> {
	fn pcmpeqq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpeqw<T, U> {
	fn pcmpeqw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpestri<T, U, V> {
	fn pcmpestri(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpestri64<T, U, V> {
	fn pcmpestri64(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpestrm<T, U, V> {
	fn pcmpestrm(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpestrm64<T, U, V> {
	fn pcmpestrm64(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpgtb<T, U> {
	fn pcmpgtb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpgtd<T, U> {
	fn pcmpgtd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpgtq<T, U> {
	fn pcmpgtq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpgtw<T, U> {
	fn pcmpgtw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpistri<T, U, V> {
	fn pcmpistri(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcmpistrm<T, U, V> {
	fn pcmpistrm(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPcommit {
	fn pcommit(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPconfig {
	fn pconfig(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPdep<T, U, V> {
	fn pdep(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPdistib<T, U> {
	fn pdistib(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPext<T, U, V> {
	fn pext(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPextrb<T, U, V> {
	fn pextrb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPextrd<T, U, V> {
	fn pextrd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPextrq<T, U, V> {
	fn pextrq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPextrw<T, U, V> {
	fn pextrw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPf2id<T, U> {
	fn pf2id(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPf2iw<T, U> {
	fn pf2iw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfacc<T, U> {
	fn pfacc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfadd<T, U> {
	fn pfadd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfcmpeq<T, U> {
	fn pfcmpeq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfcmpge<T, U> {
	fn pfcmpge(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfcmpgt<T, U> {
	fn pfcmpgt(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfmax<T, U> {
	fn pfmax(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfmin<T, U> {
	fn pfmin(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfmul<T, U> {
	fn pfmul(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfnacc<T, U> {
	fn pfnacc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfpnacc<T, U> {
	fn pfpnacc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfrcp<T, U> {
	fn pfrcp(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfrcpit1<T, U> {
	fn pfrcpit1(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfrcpit2<T, U> {
	fn pfrcpit2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfrcpv<T, U> {
	fn pfrcpv(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfrsqit1<T, U> {
	fn pfrsqit1(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfrsqrt<T, U> {
	fn pfrsqrt(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfrsqrtv<T, U> {
	fn pfrsqrtv(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfsub<T, U> {
	fn pfsub(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPfsubr<T, U> {
	fn pfsubr(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPhaddd<T, U> {
	fn phaddd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPhaddsw<T, U> {
	fn phaddsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPhaddw<T, U> {
	fn phaddw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPhminposuw<T, U> {
	fn phminposuw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPhsubd<T, U> {
	fn phsubd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPhsubsw<T, U> {
	fn phsubsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPhsubw<T, U> {
	fn phsubw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPi2fd<T, U> {
	fn pi2fd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPi2fw<T, U> {
	fn pi2fw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPinsrb<T, U, V> {
	fn pinsrb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPinsrd<T, U, V> {
	fn pinsrd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPinsrq<T, U, V> {
	fn pinsrq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPinsrw<T, U, V> {
	fn pinsrw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmachriw<T, U> {
	fn pmachriw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmaddubsw<T, U> {
	fn pmaddubsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmaddwd<T, U> {
	fn pmaddwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmagw<T, U> {
	fn pmagw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmaxsb<T, U> {
	fn pmaxsb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmaxsd<T, U> {
	fn pmaxsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmaxsw<T, U> {
	fn pmaxsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmaxub<T, U> {
	fn pmaxub(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmaxud<T, U> {
	fn pmaxud(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmaxuw<T, U> {
	fn pmaxuw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPminsb<T, U> {
	fn pminsb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPminsd<T, U> {
	fn pminsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPminsw<T, U> {
	fn pminsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPminub<T, U> {
	fn pminub(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPminud<T, U> {
	fn pminud(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPminuw<T, U> {
	fn pminuw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovmskb<T, U> {
	fn pmovmskb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovsxbd<T, U> {
	fn pmovsxbd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovsxbq<T, U> {
	fn pmovsxbq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovsxbw<T, U> {
	fn pmovsxbw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovsxdq<T, U> {
	fn pmovsxdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovsxwd<T, U> {
	fn pmovsxwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovsxwq<T, U> {
	fn pmovsxwq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovzxbd<T, U> {
	fn pmovzxbd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovzxbq<T, U> {
	fn pmovzxbq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovzxbw<T, U> {
	fn pmovzxbw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovzxdq<T, U> {
	fn pmovzxdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovzxwd<T, U> {
	fn pmovzxwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmovzxwq<T, U> {
	fn pmovzxwq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmuldq<T, U> {
	fn pmuldq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmulhriw<T, U> {
	fn pmulhriw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmulhrsw<T, U> {
	fn pmulhrsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmulhrw<T, U> {
	fn pmulhrw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmulhrw_cyrix<T, U> {
	fn pmulhrw_cyrix(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmulhuw<T, U> {
	fn pmulhuw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmulhw<T, U> {
	fn pmulhw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmulld<T, U> {
	fn pmulld(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmullw<T, U> {
	fn pmullw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmuludq<T, U> {
	fn pmuludq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmvgezb<T, U> {
	fn pmvgezb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmvlzb<T, U> {
	fn pmvlzb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmvnzb<T, U> {
	fn pmvnzb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPmvzb<T, U> {
	fn pmvzb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPop<T> {
	fn pop(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPopa {
	fn popa(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPopad {
	fn popad(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPopcnt<T, U> {
	fn popcnt(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPopf {
	fn popf(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPopfd {
	fn popfd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPopfq {
	fn popfq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPor<T, U> {
	fn por(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPrefetch<T> {
	fn prefetch(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPrefetchit0<T> {
	fn prefetchit0(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPrefetchit1<T> {
	fn prefetchit1(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPrefetchnta<T> {
	fn prefetchnta(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPrefetcht0<T> {
	fn prefetcht0(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPrefetcht1<T> {
	fn prefetcht1(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPrefetcht2<T> {
	fn prefetcht2(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPrefetchw<T> {
	fn prefetchw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPrefetchwt1<T> {
	fn prefetchwt1(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsadbw<T, U> {
	fn psadbw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPshufb<T, U> {
	fn pshufb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPshufd<T, U, V> {
	fn pshufd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPshufhw<T, U, V> {
	fn pshufhw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPshuflw<T, U, V> {
	fn pshuflw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPshufw<T, U, V> {
	fn pshufw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsignb<T, U> {
	fn psignb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsignd<T, U> {
	fn psignd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsignw<T, U> {
	fn psignw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPslld<T, U> {
	fn pslld(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPslldq<T, U> {
	fn pslldq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsllq<T, U> {
	fn psllq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsllw<T, U> {
	fn psllw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsmash {
	fn psmash(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsrad<T, U> {
	fn psrad(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsraw<T, U> {
	fn psraw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsrld<T, U> {
	fn psrld(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsrldq<T, U> {
	fn psrldq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsrlq<T, U> {
	fn psrlq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsrlw<T, U> {
	fn psrlw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsubb<T, U> {
	fn psubb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsubd<T, U> {
	fn psubd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsubq<T, U> {
	fn psubq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsubsb<T, U> {
	fn psubsb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsubsiw<T, U> {
	fn psubsiw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsubsw<T, U> {
	fn psubsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsubusb<T, U> {
	fn psubusb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsubusw<T, U> {
	fn psubusw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPsubw<T, U> {
	fn psubw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPswapd<T, U> {
	fn pswapd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPtest<T, U> {
	fn ptest(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPtwrite<T> {
	fn ptwrite(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPunpckhbw<T, U> {
	fn punpckhbw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPunpckhdq<T, U> {
	fn punpckhdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPunpckhqdq<T, U> {
	fn punpckhqdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPunpckhwd<T, U> {
	fn punpckhwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPunpcklbw<T, U> {
	fn punpcklbw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPunpckldq<T, U> {
	fn punpckldq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPunpcklqdq<T, U> {
	fn punpcklqdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPunpcklwd<T, U> {
	fn punpcklwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPush<T> {
	fn push(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPusha {
	fn pusha(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPushad {
	fn pushad(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPushf {
	fn pushf(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPushfd {
	fn pushfd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPushfq {
	fn pushfq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPvalidate {
	fn pvalidate(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmPxor<T, U> {
	fn pxor(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRcl<T, U> {
	fn rcl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRcpps<T, U> {
	fn rcpps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRcpss<T, U> {
	fn rcpss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRcr<T, U> {
	fn rcr(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdfsbase<T> {
	fn rdfsbase(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdgsbase<T> {
	fn rdgsbase(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdm {
	fn rdm(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdmsr {
	fn rdmsr(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdmsrlist {
	fn rdmsrlist(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdpid<T> {
	fn rdpid(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdpkru {
	fn rdpkru(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdpmc {
	fn rdpmc(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdpru {
	fn rdpru(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdrand<T> {
	fn rdrand(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdseed<T> {
	fn rdseed(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdshr<T> {
	fn rdshr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdsspd<T> {
	fn rdsspd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdsspq<T> {
	fn rdsspq(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdtsc {
	fn rdtsc(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdtscp {
	fn rdtscp(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRdudbg {
	fn rdudbg(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmReservednop_0f0d<T, U> {
	fn reservednop_0f0d(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmReservednop_0f18<T, U> {
	fn reservednop_0f18(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmReservednop_0f19<T, U> {
	fn reservednop_0f19(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmReservednop_0f1a<T, U> {
	fn reservednop_0f1a(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmReservednop_0f1b<T, U> {
	fn reservednop_0f1b(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmReservednop_0f1c<T, U> {
	fn reservednop_0f1c(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmReservednop_0f1d<T, U> {
	fn reservednop_0f1d(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmReservednop_0f1e<T, U> {
	fn reservednop_0f1e(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmReservednop_0f1f<T, U> {
	fn reservednop_0f1f(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRet {
	fn ret(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRet1<T> {
	fn ret_1(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRetf {
	fn retf(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRetf1<T> {
	fn retf_1(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRmpadjust {
	fn rmpadjust(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRmpquery {
	fn rmpquery(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRmpupdate {
	fn rmpupdate(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRol<T, U> {
	fn rol(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRor<T, U> {
	fn ror(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRorx<T, U, V> {
	fn rorx(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRoundpd<T, U, V> {
	fn roundpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRoundps<T, U, V> {
	fn roundps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRoundsd<T, U, V> {
	fn roundsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRoundss<T, U, V> {
	fn roundss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRsdc<T, U> {
	fn rsdc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRsldt<T> {
	fn rsldt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRsm {
	fn rsm(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRsqrtps<T, U> {
	fn rsqrtps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRsqrtss<T, U> {
	fn rsqrtss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRstorssp<T> {
	fn rstorssp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmRsts<T> {
	fn rsts(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSahf {
	fn sahf(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSal<T, U> {
	fn sal(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSalc {
	fn salc(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSar<T, U> {
	fn sar(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSarx<T, U, V> {
	fn sarx(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSaveprevssp {
	fn saveprevssp(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSbb<T, U> {
	fn sbb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmScasb {
	fn scasb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmScasd {
	fn scasd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmScasq {
	fn scasq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmScasw {
	fn scasw(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSeamcall {
	fn seamcall(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSeamops {
	fn seamops(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSeamret {
	fn seamret(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSenduipi<T> {
	fn senduipi(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSerialize {
	fn serialize(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSeta<T> {
	fn seta(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetae<T> {
	fn setae(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetb<T> {
	fn setb(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetbe<T> {
	fn setbe(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetc<T> {
	fn setc(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSete<T> {
	fn sete(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetg<T> {
	fn setg(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetge<T> {
	fn setge(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetl<T> {
	fn setl(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetle<T> {
	fn setle(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetna<T> {
	fn setna(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetnae<T> {
	fn setnae(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetnb<T> {
	fn setnb(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetnbe<T> {
	fn setnbe(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetnc<T> {
	fn setnc(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetne<T> {
	fn setne(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetng<T> {
	fn setng(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetnge<T> {
	fn setnge(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetnl<T> {
	fn setnl(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetnle<T> {
	fn setnle(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetno<T> {
	fn setno(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetnp<T> {
	fn setnp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetns<T> {
	fn setns(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetnz<T> {
	fn setnz(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSeto<T> {
	fn seto(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetp<T> {
	fn setp(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetpe<T> {
	fn setpe(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetpo<T> {
	fn setpo(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSets<T> {
	fn sets(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetssbsy {
	fn setssbsy(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSetz<T> {
	fn setz(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSfence {
	fn sfence(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSgdt<T> {
	fn sgdt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSha1msg1<T, U> {
	fn sha1msg1(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSha1msg2<T, U> {
	fn sha1msg2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSha1nexte<T, U> {
	fn sha1nexte(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSha1rnds4<T, U, V> {
	fn sha1rnds4(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSha256msg1<T, U> {
	fn sha256msg1(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSha256msg2<T, U> {
	fn sha256msg2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSha256rnds2<T, U> {
	fn sha256rnds2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmShl<T, U> {
	fn shl(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmShld<T, U, V> {
	fn shld(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmShlx<T, U, V> {
	fn shlx(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmShr<T, U> {
	fn shr(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmShrd<T, U, V> {
	fn shrd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmShrx<T, U, V> {
	fn shrx(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmShufpd<T, U, V> {
	fn shufpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmShufps<T, U, V> {
	fn shufps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSidt<T> {
	fn sidt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSkinit {
	fn skinit(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSldt<T> {
	fn sldt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSlwpcb<T> {
	fn slwpcb(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSmint {
	fn smint(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSmint_0f7e {
	fn smint_0f7e(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSmsw<T> {
	fn smsw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSqrtpd<T, U> {
	fn sqrtpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSqrtps<T, U> {
	fn sqrtps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSqrtsd<T, U> {
	fn sqrtsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSqrtss<T, U> {
	fn sqrtss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStac {
	fn stac(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStc {
	fn stc(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStd {
	fn std(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStgi {
	fn stgi(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSti {
	fn sti(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStmxcsr<T> {
	fn stmxcsr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStosb {
	fn stosb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStosd {
	fn stosd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStosq {
	fn stosq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStosw {
	fn stosw(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStr<T> {
	fn str(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSttilecfg<T> {
	fn sttilecfg(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmStui {
	fn stui(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSub<T, U> {
	fn sub(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSubpd<T, U> {
	fn subpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSubps<T, U> {
	fn subps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSubsd<T, U> {
	fn subsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSubss<T, U> {
	fn subss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSvdc<T, U> {
	fn svdc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSvldt<T> {
	fn svldt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSvts<T> {
	fn svts(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSwapgs {
	fn swapgs(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSyscall {
	fn syscall(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSysenter {
	fn sysenter(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSysexit {
	fn sysexit(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSysexitq {
	fn sysexitq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSysret {
	fn sysret(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmSysretq {
	fn sysretq(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmT1mskc<T, U> {
	fn t1mskc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTcmmimfp16ps<T, U, V> {
	fn tcmmimfp16ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTcmmrlfp16ps<T, U, V> {
	fn tcmmrlfp16ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTdcall {
	fn tdcall(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTdpbf16ps<T, U, V> {
	fn tdpbf16ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTdpbssd<T, U, V> {
	fn tdpbssd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTdpbsud<T, U, V> {
	fn tdpbsud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTdpbusd<T, U, V> {
	fn tdpbusd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTdpbuud<T, U, V> {
	fn tdpbuud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTdpfp16ps<T, U, V> {
	fn tdpfp16ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTest<T, U> {
	fn test(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTestui {
	fn testui(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTileloadd<T, U> {
	fn tileloadd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTileloaddt1<T, U> {
	fn tileloaddt1(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTilerelease {
	fn tilerelease(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTilestored<T, U> {
	fn tilestored(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTilezero<T> {
	fn tilezero(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTlbsync {
	fn tlbsync(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTpause<T> {
	fn tpause(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTzcnt<T, U> {
	fn tzcnt(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmTzmsk<T, U> {
	fn tzmsk(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUcomisd<T, U> {
	fn ucomisd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUcomiss<T, U> {
	fn ucomiss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUd0 {
	fn ud0(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUd02<T, U> {
	fn ud0_2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUd1<T, U> {
	fn ud1(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUd2 {
	fn ud2(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUiret {
	fn uiret(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUmonitor<T> {
	fn umonitor(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUmov<T, U> {
	fn umov(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUmwait<T> {
	fn umwait(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUnpckhpd<T, U> {
	fn unpckhpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUnpckhps<T, U> {
	fn unpckhps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUnpcklpd<T, U> {
	fn unpcklpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmUnpcklps<T, U> {
	fn unpcklps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmV4fmaddps<T, U, V> {
	fn v4fmaddps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmV4fmaddss<T, U, V> {
	fn v4fmaddss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmV4fnmaddps<T, U, V> {
	fn v4fnmaddps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmV4fnmaddss<T, U, V> {
	fn v4fnmaddss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaddpd<T, U, V> {
	fn vaddpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaddph<T, U, V> {
	fn vaddph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaddps<T, U, V> {
	fn vaddps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaddsd<T, U, V> {
	fn vaddsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaddsh<T, U, V> {
	fn vaddsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaddss<T, U, V> {
	fn vaddss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaddsubpd<T, U, V> {
	fn vaddsubpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaddsubps<T, U, V> {
	fn vaddsubps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaesdec<T, U, V> {
	fn vaesdec(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaesdeclast<T, U, V> {
	fn vaesdeclast(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaesenc<T, U, V> {
	fn vaesenc(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaesenclast<T, U, V> {
	fn vaesenclast(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaesimc<T, U> {
	fn vaesimc(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVaeskeygenassist<T, U, V> {
	fn vaeskeygenassist(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmValignd<T, U, V, W> {
	fn valignd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmValignq<T, U, V, W> {
	fn valignq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVandnpd<T, U, V> {
	fn vandnpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVandnps<T, U, V> {
	fn vandnps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVandpd<T, U, V> {
	fn vandpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVandps<T, U, V> {
	fn vandps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbcstnebf162ps<T, U> {
	fn vbcstnebf162ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbcstnesh2ps<T, U> {
	fn vbcstnesh2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVblendmpd<T, U, V> {
	fn vblendmpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVblendmps<T, U, V> {
	fn vblendmps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVblendpd<T, U, V, W> {
	fn vblendpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVblendps<T, U, V, W> {
	fn vblendps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVblendvpd<T, U, V, W> {
	fn vblendvpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVblendvps<T, U, V, W> {
	fn vblendvps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcastf128<T, U> {
	fn vbroadcastf128(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcastf32x2<T, U> {
	fn vbroadcastf32x2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcastf32x4<T, U> {
	fn vbroadcastf32x4(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcastf32x8<T, U> {
	fn vbroadcastf32x8(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcastf64x2<T, U> {
	fn vbroadcastf64x2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcastf64x4<T, U> {
	fn vbroadcastf64x4(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcasti128<T, U> {
	fn vbroadcasti128(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcasti32x2<T, U> {
	fn vbroadcasti32x2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcasti32x4<T, U> {
	fn vbroadcasti32x4(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcasti32x8<T, U> {
	fn vbroadcasti32x8(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcasti64x2<T, U> {
	fn vbroadcasti64x2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcasti64x4<T, U> {
	fn vbroadcasti64x4(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcastsd<T, U> {
	fn vbroadcastsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVbroadcastss<T, U> {
	fn vbroadcastss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_ospd<T, U, V> {
	fn vcmpeq_ospd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_osph<T, U, V> {
	fn vcmpeq_osph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_osps<T, U, V> {
	fn vcmpeq_osps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_ossd<T, U, V> {
	fn vcmpeq_ossd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_ossh<T, U, V> {
	fn vcmpeq_ossh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_osss<T, U, V> {
	fn vcmpeq_osss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_uqpd<T, U, V> {
	fn vcmpeq_uqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_uqph<T, U, V> {
	fn vcmpeq_uqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_uqps<T, U, V> {
	fn vcmpeq_uqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_uqsd<T, U, V> {
	fn vcmpeq_uqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_uqsh<T, U, V> {
	fn vcmpeq_uqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_uqss<T, U, V> {
	fn vcmpeq_uqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_uspd<T, U, V> {
	fn vcmpeq_uspd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_usph<T, U, V> {
	fn vcmpeq_usph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_usps<T, U, V> {
	fn vcmpeq_usps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_ussd<T, U, V> {
	fn vcmpeq_ussd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_ussh<T, U, V> {
	fn vcmpeq_ussh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeq_usss<T, U, V> {
	fn vcmpeq_usss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeqpd<T, U, V> {
	fn vcmpeqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeqph<T, U, V> {
	fn vcmpeqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeqps<T, U, V> {
	fn vcmpeqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeqsd<T, U, V> {
	fn vcmpeqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeqsh<T, U, V> {
	fn vcmpeqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpeqss<T, U, V> {
	fn vcmpeqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalse_ospd<T, U, V> {
	fn vcmpfalse_ospd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalse_osph<T, U, V> {
	fn vcmpfalse_osph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalse_osps<T, U, V> {
	fn vcmpfalse_osps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalse_ossd<T, U, V> {
	fn vcmpfalse_ossd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalse_ossh<T, U, V> {
	fn vcmpfalse_ossh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalse_osss<T, U, V> {
	fn vcmpfalse_osss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalsepd<T, U, V> {
	fn vcmpfalsepd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalseph<T, U, V> {
	fn vcmpfalseph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalseps<T, U, V> {
	fn vcmpfalseps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalsesd<T, U, V> {
	fn vcmpfalsesd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalsesh<T, U, V> {
	fn vcmpfalsesh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpfalsess<T, U, V> {
	fn vcmpfalsess(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpge_oqpd<T, U, V> {
	fn vcmpge_oqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpge_oqph<T, U, V> {
	fn vcmpge_oqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpge_oqps<T, U, V> {
	fn vcmpge_oqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpge_oqsd<T, U, V> {
	fn vcmpge_oqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpge_oqsh<T, U, V> {
	fn vcmpge_oqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpge_oqss<T, U, V> {
	fn vcmpge_oqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgepd<T, U, V> {
	fn vcmpgepd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgeph<T, U, V> {
	fn vcmpgeph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgeps<T, U, V> {
	fn vcmpgeps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgesd<T, U, V> {
	fn vcmpgesd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgesh<T, U, V> {
	fn vcmpgesh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgess<T, U, V> {
	fn vcmpgess(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgt_oqpd<T, U, V> {
	fn vcmpgt_oqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgt_oqph<T, U, V> {
	fn vcmpgt_oqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgt_oqps<T, U, V> {
	fn vcmpgt_oqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgt_oqsd<T, U, V> {
	fn vcmpgt_oqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgt_oqsh<T, U, V> {
	fn vcmpgt_oqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgt_oqss<T, U, V> {
	fn vcmpgt_oqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgtpd<T, U, V> {
	fn vcmpgtpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgtph<T, U, V> {
	fn vcmpgtph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgtps<T, U, V> {
	fn vcmpgtps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgtsd<T, U, V> {
	fn vcmpgtsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgtsh<T, U, V> {
	fn vcmpgtsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpgtss<T, U, V> {
	fn vcmpgtss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmple_oqpd<T, U, V> {
	fn vcmple_oqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmple_oqph<T, U, V> {
	fn vcmple_oqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmple_oqps<T, U, V> {
	fn vcmple_oqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmple_oqsd<T, U, V> {
	fn vcmple_oqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmple_oqsh<T, U, V> {
	fn vcmple_oqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmple_oqss<T, U, V> {
	fn vcmple_oqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmplepd<T, U, V> {
	fn vcmplepd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpleph<T, U, V> {
	fn vcmpleph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpleps<T, U, V> {
	fn vcmpleps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmplesd<T, U, V> {
	fn vcmplesd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmplesh<T, U, V> {
	fn vcmplesh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpless<T, U, V> {
	fn vcmpless(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmplt_oqpd<T, U, V> {
	fn vcmplt_oqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmplt_oqph<T, U, V> {
	fn vcmplt_oqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmplt_oqps<T, U, V> {
	fn vcmplt_oqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmplt_oqsd<T, U, V> {
	fn vcmplt_oqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmplt_oqsh<T, U, V> {
	fn vcmplt_oqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmplt_oqss<T, U, V> {
	fn vcmplt_oqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpltpd<T, U, V> {
	fn vcmpltpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpltph<T, U, V> {
	fn vcmpltph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpltps<T, U, V> {
	fn vcmpltps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpltsd<T, U, V> {
	fn vcmpltsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpltsh<T, U, V> {
	fn vcmpltsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpltss<T, U, V> {
	fn vcmpltss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_oqpd<T, U, V> {
	fn vcmpneq_oqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_oqph<T, U, V> {
	fn vcmpneq_oqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_oqps<T, U, V> {
	fn vcmpneq_oqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_oqsd<T, U, V> {
	fn vcmpneq_oqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_oqsh<T, U, V> {
	fn vcmpneq_oqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_oqss<T, U, V> {
	fn vcmpneq_oqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_ospd<T, U, V> {
	fn vcmpneq_ospd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_osph<T, U, V> {
	fn vcmpneq_osph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_osps<T, U, V> {
	fn vcmpneq_osps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_ossd<T, U, V> {
	fn vcmpneq_ossd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_ossh<T, U, V> {
	fn vcmpneq_ossh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_osss<T, U, V> {
	fn vcmpneq_osss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_uspd<T, U, V> {
	fn vcmpneq_uspd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_usph<T, U, V> {
	fn vcmpneq_usph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_usps<T, U, V> {
	fn vcmpneq_usps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_ussd<T, U, V> {
	fn vcmpneq_ussd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_ussh<T, U, V> {
	fn vcmpneq_ussh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneq_usss<T, U, V> {
	fn vcmpneq_usss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneqpd<T, U, V> {
	fn vcmpneqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneqph<T, U, V> {
	fn vcmpneqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneqps<T, U, V> {
	fn vcmpneqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneqsd<T, U, V> {
	fn vcmpneqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneqsh<T, U, V> {
	fn vcmpneqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpneqss<T, U, V> {
	fn vcmpneqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnge_uqpd<T, U, V> {
	fn vcmpnge_uqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnge_uqph<T, U, V> {
	fn vcmpnge_uqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnge_uqps<T, U, V> {
	fn vcmpnge_uqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnge_uqsd<T, U, V> {
	fn vcmpnge_uqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnge_uqsh<T, U, V> {
	fn vcmpnge_uqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnge_uqss<T, U, V> {
	fn vcmpnge_uqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngepd<T, U, V> {
	fn vcmpngepd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngeph<T, U, V> {
	fn vcmpngeph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngeps<T, U, V> {
	fn vcmpngeps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngesd<T, U, V> {
	fn vcmpngesd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngesh<T, U, V> {
	fn vcmpngesh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngess<T, U, V> {
	fn vcmpngess(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngt_uqpd<T, U, V> {
	fn vcmpngt_uqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngt_uqph<T, U, V> {
	fn vcmpngt_uqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngt_uqps<T, U, V> {
	fn vcmpngt_uqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngt_uqsd<T, U, V> {
	fn vcmpngt_uqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngt_uqsh<T, U, V> {
	fn vcmpngt_uqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngt_uqss<T, U, V> {
	fn vcmpngt_uqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngtpd<T, U, V> {
	fn vcmpngtpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngtph<T, U, V> {
	fn vcmpngtph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngtps<T, U, V> {
	fn vcmpngtps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngtsd<T, U, V> {
	fn vcmpngtsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngtsh<T, U, V> {
	fn vcmpngtsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpngtss<T, U, V> {
	fn vcmpngtss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnle_uqpd<T, U, V> {
	fn vcmpnle_uqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnle_uqph<T, U, V> {
	fn vcmpnle_uqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnle_uqps<T, U, V> {
	fn vcmpnle_uqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnle_uqsd<T, U, V> {
	fn vcmpnle_uqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnle_uqsh<T, U, V> {
	fn vcmpnle_uqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnle_uqss<T, U, V> {
	fn vcmpnle_uqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnlepd<T, U, V> {
	fn vcmpnlepd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnleph<T, U, V> {
	fn vcmpnleph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnleps<T, U, V> {
	fn vcmpnleps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnlesd<T, U, V> {
	fn vcmpnlesd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnlesh<T, U, V> {
	fn vcmpnlesh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnless<T, U, V> {
	fn vcmpnless(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnlt_uqpd<T, U, V> {
	fn vcmpnlt_uqpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnlt_uqph<T, U, V> {
	fn vcmpnlt_uqph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnlt_uqps<T, U, V> {
	fn vcmpnlt_uqps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnlt_uqsd<T, U, V> {
	fn vcmpnlt_uqsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnlt_uqsh<T, U, V> {
	fn vcmpnlt_uqsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnlt_uqss<T, U, V> {
	fn vcmpnlt_uqss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnltpd<T, U, V> {
	fn vcmpnltpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnltph<T, U, V> {
	fn vcmpnltph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnltps<T, U, V> {
	fn vcmpnltps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnltsd<T, U, V> {
	fn vcmpnltsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnltsh<T, U, V> {
	fn vcmpnltsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpnltss<T, U, V> {
	fn vcmpnltss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpord_spd<T, U, V> {
	fn vcmpord_spd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpord_sph<T, U, V> {
	fn vcmpord_sph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpord_sps<T, U, V> {
	fn vcmpord_sps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpord_ssd<T, U, V> {
	fn vcmpord_ssd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpord_ssh<T, U, V> {
	fn vcmpord_ssh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpord_sss<T, U, V> {
	fn vcmpord_sss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpordpd<T, U, V> {
	fn vcmpordpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpordph<T, U, V> {
	fn vcmpordph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpordps<T, U, V> {
	fn vcmpordps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpordsd<T, U, V> {
	fn vcmpordsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpordsh<T, U, V> {
	fn vcmpordsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpordss<T, U, V> {
	fn vcmpordss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmppd<T, U, V, W> {
	fn vcmppd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpph<T, U, V, W> {
	fn vcmpph(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpps<T, U, V, W> {
	fn vcmpps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpsd<T, U, V, W> {
	fn vcmpsd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpsh<T, U, V, W> {
	fn vcmpsh(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpss<T, U, V, W> {
	fn vcmpss(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptrue_uspd<T, U, V> {
	fn vcmptrue_uspd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptrue_usph<T, U, V> {
	fn vcmptrue_usph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptrue_usps<T, U, V> {
	fn vcmptrue_usps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptrue_ussd<T, U, V> {
	fn vcmptrue_ussd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptrue_ussh<T, U, V> {
	fn vcmptrue_ussh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptrue_usss<T, U, V> {
	fn vcmptrue_usss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptruepd<T, U, V> {
	fn vcmptruepd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptrueph<T, U, V> {
	fn vcmptrueph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptrueps<T, U, V> {
	fn vcmptrueps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptruesd<T, U, V> {
	fn vcmptruesd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptruesh<T, U, V> {
	fn vcmptruesh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmptruess<T, U, V> {
	fn vcmptruess(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunord_spd<T, U, V> {
	fn vcmpunord_spd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunord_sph<T, U, V> {
	fn vcmpunord_sph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunord_sps<T, U, V> {
	fn vcmpunord_sps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunord_ssd<T, U, V> {
	fn vcmpunord_ssd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunord_ssh<T, U, V> {
	fn vcmpunord_ssh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunord_sss<T, U, V> {
	fn vcmpunord_sss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunordpd<T, U, V> {
	fn vcmpunordpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunordph<T, U, V> {
	fn vcmpunordph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunordps<T, U, V> {
	fn vcmpunordps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunordsd<T, U, V> {
	fn vcmpunordsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunordsh<T, U, V> {
	fn vcmpunordsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcmpunordss<T, U, V> {
	fn vcmpunordss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcomisd<T, U> {
	fn vcomisd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcomish<T, U> {
	fn vcomish(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcomiss<T, U> {
	fn vcomiss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcompresspd<T, U> {
	fn vcompresspd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcompressps<T, U> {
	fn vcompressps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtdq2pd<T, U> {
	fn vcvtdq2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtdq2ph<T, U> {
	fn vcvtdq2ph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtdq2phx<T, U> {
	fn vcvtdq2phx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtdq2phy<T, U> {
	fn vcvtdq2phy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtdq2ps<T, U> {
	fn vcvtdq2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtne2ps2bf16<T, U, V> {
	fn vcvtne2ps2bf16(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtneebf162ps<T, U> {
	fn vcvtneebf162ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtneeph2ps<T, U> {
	fn vcvtneeph2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtneobf162ps<T, U> {
	fn vcvtneobf162ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtneoph2ps<T, U> {
	fn vcvtneoph2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtneps2bf16<T, U> {
	fn vcvtneps2bf16(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtneps2bf16x<T, U> {
	fn vcvtneps2bf16x(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtneps2bf16y<T, U> {
	fn vcvtneps2bf16y(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2dq<T, U> {
	fn vcvtpd2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2dqx<T, U> {
	fn vcvtpd2dqx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2dqy<T, U> {
	fn vcvtpd2dqy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2ph<T, U> {
	fn vcvtpd2ph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2phx<T, U> {
	fn vcvtpd2phx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2phy<T, U> {
	fn vcvtpd2phy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2phz<T, U> {
	fn vcvtpd2phz(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2ps<T, U> {
	fn vcvtpd2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2psx<T, U> {
	fn vcvtpd2psx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2psy<T, U> {
	fn vcvtpd2psy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2qq<T, U> {
	fn vcvtpd2qq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2udq<T, U> {
	fn vcvtpd2udq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2udqx<T, U> {
	fn vcvtpd2udqx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2udqy<T, U> {
	fn vcvtpd2udqy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtpd2uqq<T, U> {
	fn vcvtpd2uqq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtph2dq<T, U> {
	fn vcvtph2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtph2pd<T, U> {
	fn vcvtph2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtph2ps<T, U> {
	fn vcvtph2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtph2psx<T, U> {
	fn vcvtph2psx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtph2qq<T, U> {
	fn vcvtph2qq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtph2udq<T, U> {
	fn vcvtph2udq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtph2uqq<T, U> {
	fn vcvtph2uqq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtph2uw<T, U> {
	fn vcvtph2uw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtph2w<T, U> {
	fn vcvtph2w(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtps2dq<T, U> {
	fn vcvtps2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtps2pd<T, U> {
	fn vcvtps2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtps2ph<T, U, V> {
	fn vcvtps2ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtps2phx<T, U> {
	fn vcvtps2phx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtps2phxx<T, U> {
	fn vcvtps2phxx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtps2phxy<T, U> {
	fn vcvtps2phxy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtps2qq<T, U> {
	fn vcvtps2qq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtps2udq<T, U> {
	fn vcvtps2udq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtps2uqq<T, U> {
	fn vcvtps2uqq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtqq2pd<T, U> {
	fn vcvtqq2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtqq2ph<T, U> {
	fn vcvtqq2ph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtqq2phx<T, U> {
	fn vcvtqq2phx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtqq2phy<T, U> {
	fn vcvtqq2phy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtqq2phz<T, U> {
	fn vcvtqq2phz(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtqq2ps<T, U> {
	fn vcvtqq2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtqq2psx<T, U> {
	fn vcvtqq2psx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtqq2psy<T, U> {
	fn vcvtqq2psy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsd2sh<T, U, V> {
	fn vcvtsd2sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsd2si<T, U> {
	fn vcvtsd2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsd2ss<T, U, V> {
	fn vcvtsd2ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsd2usi<T, U> {
	fn vcvtsd2usi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsh2sd<T, U, V> {
	fn vcvtsh2sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsh2si<T, U> {
	fn vcvtsh2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsh2ss<T, U, V> {
	fn vcvtsh2ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsh2usi<T, U> {
	fn vcvtsh2usi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsi2sd<T, U, V> {
	fn vcvtsi2sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsi2sh<T, U, V> {
	fn vcvtsi2sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtsi2ss<T, U, V> {
	fn vcvtsi2ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtss2sd<T, U, V> {
	fn vcvtss2sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtss2sh<T, U, V> {
	fn vcvtss2sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtss2si<T, U> {
	fn vcvtss2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtss2usi<T, U> {
	fn vcvtss2usi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttpd2dq<T, U> {
	fn vcvttpd2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttpd2dqx<T, U> {
	fn vcvttpd2dqx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttpd2dqy<T, U> {
	fn vcvttpd2dqy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttpd2qq<T, U> {
	fn vcvttpd2qq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttpd2udq<T, U> {
	fn vcvttpd2udq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttpd2udqx<T, U> {
	fn vcvttpd2udqx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttpd2udqy<T, U> {
	fn vcvttpd2udqy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttpd2uqq<T, U> {
	fn vcvttpd2uqq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttph2dq<T, U> {
	fn vcvttph2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttph2qq<T, U> {
	fn vcvttph2qq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttph2udq<T, U> {
	fn vcvttph2udq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttph2uqq<T, U> {
	fn vcvttph2uqq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttph2uw<T, U> {
	fn vcvttph2uw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttph2w<T, U> {
	fn vcvttph2w(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttps2dq<T, U> {
	fn vcvttps2dq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttps2qq<T, U> {
	fn vcvttps2qq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttps2udq<T, U> {
	fn vcvttps2udq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttps2uqq<T, U> {
	fn vcvttps2uqq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttsd2si<T, U> {
	fn vcvttsd2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttsd2usi<T, U> {
	fn vcvttsd2usi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttsh2si<T, U> {
	fn vcvttsh2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttsh2usi<T, U> {
	fn vcvttsh2usi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttss2si<T, U> {
	fn vcvttss2si(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvttss2usi<T, U> {
	fn vcvttss2usi(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtudq2pd<T, U> {
	fn vcvtudq2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtudq2ph<T, U> {
	fn vcvtudq2ph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtudq2phx<T, U> {
	fn vcvtudq2phx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtudq2phy<T, U> {
	fn vcvtudq2phy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtudq2ps<T, U> {
	fn vcvtudq2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtuqq2pd<T, U> {
	fn vcvtuqq2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtuqq2ph<T, U> {
	fn vcvtuqq2ph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtuqq2phx<T, U> {
	fn vcvtuqq2phx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtuqq2phy<T, U> {
	fn vcvtuqq2phy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtuqq2phz<T, U> {
	fn vcvtuqq2phz(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtuqq2ps<T, U> {
	fn vcvtuqq2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtuqq2psx<T, U> {
	fn vcvtuqq2psx(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtuqq2psy<T, U> {
	fn vcvtuqq2psy(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtusi2sd<T, U, V> {
	fn vcvtusi2sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtusi2sh<T, U, V> {
	fn vcvtusi2sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtusi2ss<T, U, V> {
	fn vcvtusi2ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtuw2ph<T, U> {
	fn vcvtuw2ph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVcvtw2ph<T, U> {
	fn vcvtw2ph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdbpsadbw<T, U, V, W> {
	fn vdbpsadbw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdivpd<T, U, V> {
	fn vdivpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdivph<T, U, V> {
	fn vdivph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdivps<T, U, V> {
	fn vdivps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdivsd<T, U, V> {
	fn vdivsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdivsh<T, U, V> {
	fn vdivsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdivss<T, U, V> {
	fn vdivss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdpbf16ps<T, U, V> {
	fn vdpbf16ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdppd<T, U, V, W> {
	fn vdppd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVdpps<T, U, V, W> {
	fn vdpps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVerr<T> {
	fn verr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVerw<T> {
	fn verw(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVexp2pd<T, U> {
	fn vexp2pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVexp2ps<T, U> {
	fn vexp2ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVexpandpd<T, U> {
	fn vexpandpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVexpandps<T, U> {
	fn vexpandps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextractf128<T, U, V> {
	fn vextractf128(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextractf32x4<T, U, V> {
	fn vextractf32x4(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextractf32x8<T, U, V> {
	fn vextractf32x8(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextractf64x2<T, U, V> {
	fn vextractf64x2(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextractf64x4<T, U, V> {
	fn vextractf64x4(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextracti128<T, U, V> {
	fn vextracti128(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextracti32x4<T, U, V> {
	fn vextracti32x4(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextracti32x8<T, U, V> {
	fn vextracti32x8(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextracti64x2<T, U, V> {
	fn vextracti64x2(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextracti64x4<T, U, V> {
	fn vextracti64x4(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVextractps<T, U, V> {
	fn vextractps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfcmaddcph<T, U, V> {
	fn vfcmaddcph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfcmaddcsh<T, U, V> {
	fn vfcmaddcsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfcmulcph<T, U, V> {
	fn vfcmulcph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfcmulcsh<T, U, V> {
	fn vfcmulcsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfixupimmpd<T, U, V, W> {
	fn vfixupimmpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfixupimmps<T, U, V, W> {
	fn vfixupimmps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfixupimmsd<T, U, V, W> {
	fn vfixupimmsd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfixupimmss<T, U, V, W> {
	fn vfixupimmss(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd132pd<T, U, V> {
	fn vfmadd132pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd132ph<T, U, V> {
	fn vfmadd132ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd132ps<T, U, V> {
	fn vfmadd132ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd132sd<T, U, V> {
	fn vfmadd132sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd132sh<T, U, V> {
	fn vfmadd132sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd132ss<T, U, V> {
	fn vfmadd132ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd213pd<T, U, V> {
	fn vfmadd213pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd213ph<T, U, V> {
	fn vfmadd213ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd213ps<T, U, V> {
	fn vfmadd213ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd213sd<T, U, V> {
	fn vfmadd213sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd213sh<T, U, V> {
	fn vfmadd213sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd213ss<T, U, V> {
	fn vfmadd213ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd231pd<T, U, V> {
	fn vfmadd231pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd231ph<T, U, V> {
	fn vfmadd231ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd231ps<T, U, V> {
	fn vfmadd231ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd231sd<T, U, V> {
	fn vfmadd231sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd231sh<T, U, V> {
	fn vfmadd231sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmadd231ss<T, U, V> {
	fn vfmadd231ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddcph<T, U, V> {
	fn vfmaddcph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddcsh<T, U, V> {
	fn vfmaddcsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddpd<T, U, V, W> {
	fn vfmaddpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddps<T, U, V, W> {
	fn vfmaddps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsd<T, U, V, W> {
	fn vfmaddsd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddss<T, U, V, W> {
	fn vfmaddss(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsub132pd<T, U, V> {
	fn vfmaddsub132pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsub132ph<T, U, V> {
	fn vfmaddsub132ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsub132ps<T, U, V> {
	fn vfmaddsub132ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsub213pd<T, U, V> {
	fn vfmaddsub213pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsub213ph<T, U, V> {
	fn vfmaddsub213ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsub213ps<T, U, V> {
	fn vfmaddsub213ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsub231pd<T, U, V> {
	fn vfmaddsub231pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsub231ph<T, U, V> {
	fn vfmaddsub231ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsub231ps<T, U, V> {
	fn vfmaddsub231ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsubpd<T, U, V, W> {
	fn vfmaddsubpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmaddsubps<T, U, V, W> {
	fn vfmaddsubps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub132pd<T, U, V> {
	fn vfmsub132pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub132ph<T, U, V> {
	fn vfmsub132ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub132ps<T, U, V> {
	fn vfmsub132ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub132sd<T, U, V> {
	fn vfmsub132sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub132sh<T, U, V> {
	fn vfmsub132sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub132ss<T, U, V> {
	fn vfmsub132ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub213pd<T, U, V> {
	fn vfmsub213pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub213ph<T, U, V> {
	fn vfmsub213ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub213ps<T, U, V> {
	fn vfmsub213ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub213sd<T, U, V> {
	fn vfmsub213sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub213sh<T, U, V> {
	fn vfmsub213sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub213ss<T, U, V> {
	fn vfmsub213ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub231pd<T, U, V> {
	fn vfmsub231pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub231ph<T, U, V> {
	fn vfmsub231ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub231ps<T, U, V> {
	fn vfmsub231ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub231sd<T, U, V> {
	fn vfmsub231sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub231sh<T, U, V> {
	fn vfmsub231sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsub231ss<T, U, V> {
	fn vfmsub231ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubadd132pd<T, U, V> {
	fn vfmsubadd132pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubadd132ph<T, U, V> {
	fn vfmsubadd132ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubadd132ps<T, U, V> {
	fn vfmsubadd132ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubadd213pd<T, U, V> {
	fn vfmsubadd213pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubadd213ph<T, U, V> {
	fn vfmsubadd213ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubadd213ps<T, U, V> {
	fn vfmsubadd213ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubadd231pd<T, U, V> {
	fn vfmsubadd231pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubadd231ph<T, U, V> {
	fn vfmsubadd231ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubadd231ps<T, U, V> {
	fn vfmsubadd231ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubaddpd<T, U, V, W> {
	fn vfmsubaddpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubaddps<T, U, V, W> {
	fn vfmsubaddps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubpd<T, U, V, W> {
	fn vfmsubpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubps<T, U, V, W> {
	fn vfmsubps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubsd<T, U, V, W> {
	fn vfmsubsd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmsubss<T, U, V, W> {
	fn vfmsubss(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmulcph<T, U, V> {
	fn vfmulcph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfmulcsh<T, U, V> {
	fn vfmulcsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd132pd<T, U, V> {
	fn vfnmadd132pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd132ph<T, U, V> {
	fn vfnmadd132ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd132ps<T, U, V> {
	fn vfnmadd132ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd132sd<T, U, V> {
	fn vfnmadd132sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd132sh<T, U, V> {
	fn vfnmadd132sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd132ss<T, U, V> {
	fn vfnmadd132ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd213pd<T, U, V> {
	fn vfnmadd213pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd213ph<T, U, V> {
	fn vfnmadd213ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd213ps<T, U, V> {
	fn vfnmadd213ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd213sd<T, U, V> {
	fn vfnmadd213sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd213sh<T, U, V> {
	fn vfnmadd213sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd213ss<T, U, V> {
	fn vfnmadd213ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd231pd<T, U, V> {
	fn vfnmadd231pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd231ph<T, U, V> {
	fn vfnmadd231ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd231ps<T, U, V> {
	fn vfnmadd231ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd231sd<T, U, V> {
	fn vfnmadd231sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd231sh<T, U, V> {
	fn vfnmadd231sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmadd231ss<T, U, V> {
	fn vfnmadd231ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmaddpd<T, U, V, W> {
	fn vfnmaddpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmaddps<T, U, V, W> {
	fn vfnmaddps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmaddsd<T, U, V, W> {
	fn vfnmaddsd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmaddss<T, U, V, W> {
	fn vfnmaddss(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub132pd<T, U, V> {
	fn vfnmsub132pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub132ph<T, U, V> {
	fn vfnmsub132ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub132ps<T, U, V> {
	fn vfnmsub132ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub132sd<T, U, V> {
	fn vfnmsub132sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub132sh<T, U, V> {
	fn vfnmsub132sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub132ss<T, U, V> {
	fn vfnmsub132ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub213pd<T, U, V> {
	fn vfnmsub213pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub213ph<T, U, V> {
	fn vfnmsub213ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub213ps<T, U, V> {
	fn vfnmsub213ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub213sd<T, U, V> {
	fn vfnmsub213sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub213sh<T, U, V> {
	fn vfnmsub213sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub213ss<T, U, V> {
	fn vfnmsub213ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub231pd<T, U, V> {
	fn vfnmsub231pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub231ph<T, U, V> {
	fn vfnmsub231ph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub231ps<T, U, V> {
	fn vfnmsub231ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub231sd<T, U, V> {
	fn vfnmsub231sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub231sh<T, U, V> {
	fn vfnmsub231sh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsub231ss<T, U, V> {
	fn vfnmsub231ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsubpd<T, U, V, W> {
	fn vfnmsubpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsubps<T, U, V, W> {
	fn vfnmsubps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsubsd<T, U, V, W> {
	fn vfnmsubsd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfnmsubss<T, U, V, W> {
	fn vfnmsubss(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclasspd<T, U, V> {
	fn vfpclasspd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclasspdx<T, U, V> {
	fn vfpclasspdx(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclasspdy<T, U, V> {
	fn vfpclasspdy(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclasspdz<T, U, V> {
	fn vfpclasspdz(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclassph<T, U, V> {
	fn vfpclassph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclassphx<T, U, V> {
	fn vfpclassphx(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclassphy<T, U, V> {
	fn vfpclassphy(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclassphz<T, U, V> {
	fn vfpclassphz(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclassps<T, U, V> {
	fn vfpclassps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclasspsx<T, U, V> {
	fn vfpclasspsx(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclasspsy<T, U, V> {
	fn vfpclasspsy(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclasspsz<T, U, V> {
	fn vfpclasspsz(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclasssd<T, U, V> {
	fn vfpclasssd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclasssh<T, U, V> {
	fn vfpclasssh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfpclassss<T, U, V> {
	fn vfpclassss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfrczpd<T, U> {
	fn vfrczpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfrczps<T, U> {
	fn vfrczps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfrczsd<T, U> {
	fn vfrczsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVfrczss<T, U> {
	fn vfrczss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherdpd<T, U> {
	fn vgatherdpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherdpd3<T, U, V> {
	fn vgatherdpd_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherdps<T, U> {
	fn vgatherdps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherdps3<T, U, V> {
	fn vgatherdps_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherpf0dpd<T> {
	fn vgatherpf0dpd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherpf0dps<T> {
	fn vgatherpf0dps(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherpf0qpd<T> {
	fn vgatherpf0qpd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherpf0qps<T> {
	fn vgatherpf0qps(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherpf1dpd<T> {
	fn vgatherpf1dpd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherpf1dps<T> {
	fn vgatherpf1dps(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherpf1qpd<T> {
	fn vgatherpf1qpd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherpf1qps<T> {
	fn vgatherpf1qps(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherqpd<T, U> {
	fn vgatherqpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherqpd3<T, U, V> {
	fn vgatherqpd_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherqps<T, U> {
	fn vgatherqps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgatherqps3<T, U, V> {
	fn vgatherqps_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetexppd<T, U> {
	fn vgetexppd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetexpph<T, U> {
	fn vgetexpph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetexpps<T, U> {
	fn vgetexpps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetexpsd<T, U, V> {
	fn vgetexpsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetexpsh<T, U, V> {
	fn vgetexpsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetexpss<T, U, V> {
	fn vgetexpss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetmantpd<T, U, V> {
	fn vgetmantpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetmantph<T, U, V> {
	fn vgetmantph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetmantps<T, U, V> {
	fn vgetmantps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetmantsd<T, U, V, W> {
	fn vgetmantsd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetmantsh<T, U, V, W> {
	fn vgetmantsh(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgetmantss<T, U, V, W> {
	fn vgetmantss(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgf2p8affineinvqb<T, U, V, W> {
	fn vgf2p8affineinvqb(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgf2p8affineqb<T, U, V, W> {
	fn vgf2p8affineqb(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVgf2p8mulb<T, U, V> {
	fn vgf2p8mulb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVhaddpd<T, U, V> {
	fn vhaddpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVhaddps<T, U, V> {
	fn vhaddps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVhsubpd<T, U, V> {
	fn vhsubpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVhsubps<T, U, V> {
	fn vhsubps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinsertf128<T, U, V, W> {
	fn vinsertf128(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinsertf32x4<T, U, V, W> {
	fn vinsertf32x4(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinsertf32x8<T, U, V, W> {
	fn vinsertf32x8(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinsertf64x2<T, U, V, W> {
	fn vinsertf64x2(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinsertf64x4<T, U, V, W> {
	fn vinsertf64x4(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinserti128<T, U, V, W> {
	fn vinserti128(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinserti32x4<T, U, V, W> {
	fn vinserti32x4(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinserti32x8<T, U, V, W> {
	fn vinserti32x8(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinserti64x2<T, U, V, W> {
	fn vinserti64x2(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinserti64x4<T, U, V, W> {
	fn vinserti64x4(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVinsertps<T, U, V, W> {
	fn vinsertps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVlddqu<T, U> {
	fn vlddqu(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVldmxcsr<T> {
	fn vldmxcsr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmaskmovdqu<T, U> {
	fn vmaskmovdqu(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmaskmovpd<T, U, V> {
	fn vmaskmovpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmaskmovps<T, U, V> {
	fn vmaskmovps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmaxpd<T, U, V> {
	fn vmaxpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmaxph<T, U, V> {
	fn vmaxph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmaxps<T, U, V> {
	fn vmaxps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmaxsd<T, U, V> {
	fn vmaxsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmaxsh<T, U, V> {
	fn vmaxsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmaxss<T, U, V> {
	fn vmaxss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmcall {
	fn vmcall(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmclear<T> {
	fn vmclear(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmfunc {
	fn vmfunc(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmgexit {
	fn vmgexit(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVminpd<T, U, V> {
	fn vminpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVminph<T, U, V> {
	fn vminph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVminps<T, U, V> {
	fn vminps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVminsd<T, U, V> {
	fn vminsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVminsh<T, U, V> {
	fn vminsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVminss<T, U, V> {
	fn vminss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmlaunch {
	fn vmlaunch(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmload {
	fn vmload(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmmcall {
	fn vmmcall(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovapd<T, U> {
	fn vmovapd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovaps<T, U> {
	fn vmovaps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovd<T, U> {
	fn vmovd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovddup<T, U> {
	fn vmovddup(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovdqa<T, U> {
	fn vmovdqa(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovdqa32<T, U> {
	fn vmovdqa32(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovdqa64<T, U> {
	fn vmovdqa64(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovdqu<T, U> {
	fn vmovdqu(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovdqu16<T, U> {
	fn vmovdqu16(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovdqu32<T, U> {
	fn vmovdqu32(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovdqu64<T, U> {
	fn vmovdqu64(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovdqu8<T, U> {
	fn vmovdqu8(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovhlps<T, U, V> {
	fn vmovhlps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovhpd<T, U> {
	fn vmovhpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovhpd3<T, U, V> {
	fn vmovhpd_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovhps<T, U> {
	fn vmovhps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovhps3<T, U, V> {
	fn vmovhps_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovlhps<T, U, V> {
	fn vmovlhps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovlpd<T, U> {
	fn vmovlpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovlpd3<T, U, V> {
	fn vmovlpd_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovlps<T, U> {
	fn vmovlps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovlps3<T, U, V> {
	fn vmovlps_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovmskpd<T, U> {
	fn vmovmskpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovmskps<T, U> {
	fn vmovmskps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovntdq<T, U> {
	fn vmovntdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovntdqa<T, U> {
	fn vmovntdqa(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovntpd<T, U> {
	fn vmovntpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovntps<T, U> {
	fn vmovntps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovq<T, U> {
	fn vmovq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovsd<T, U> {
	fn vmovsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovsd3<T, U, V> {
	fn vmovsd_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovsh<T, U> {
	fn vmovsh(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovsh3<T, U, V> {
	fn vmovsh_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovshdup<T, U> {
	fn vmovshdup(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovsldup<T, U> {
	fn vmovsldup(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovss<T, U> {
	fn vmovss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovss3<T, U, V> {
	fn vmovss_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovupd<T, U> {
	fn vmovupd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovups<T, U> {
	fn vmovups(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmovw<T, U> {
	fn vmovw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmpsadbw<T, U, V, W> {
	fn vmpsadbw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmptrld<T> {
	fn vmptrld(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmptrst<T> {
	fn vmptrst(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmread<T, U> {
	fn vmread(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmresume {
	fn vmresume(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmrun {
	fn vmrun(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmsave {
	fn vmsave(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmulpd<T, U, V> {
	fn vmulpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmulph<T, U, V> {
	fn vmulph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmulps<T, U, V> {
	fn vmulps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmulsd<T, U, V> {
	fn vmulsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmulsh<T, U, V> {
	fn vmulsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmulss<T, U, V> {
	fn vmulss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmwrite<T, U> {
	fn vmwrite(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmxoff {
	fn vmxoff(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVmxon<T> {
	fn vmxon(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVorpd<T, U, V> {
	fn vorpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVorps<T, U, V> {
	fn vorps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVp2intersectd<T, U, V> {
	fn vp2intersectd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVp2intersectq<T, U, V> {
	fn vp2intersectq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVp4dpwssd<T, U, V> {
	fn vp4dpwssd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVp4dpwssds<T, U, V> {
	fn vp4dpwssds(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpabsb<T, U> {
	fn vpabsb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpabsd<T, U> {
	fn vpabsd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpabsq<T, U> {
	fn vpabsq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpabsw<T, U> {
	fn vpabsw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpackssdw<T, U, V> {
	fn vpackssdw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpacksswb<T, U, V> {
	fn vpacksswb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpackusdw<T, U, V> {
	fn vpackusdw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpackuswb<T, U, V> {
	fn vpackuswb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpaddb<T, U, V> {
	fn vpaddb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpaddd<T, U, V> {
	fn vpaddd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpaddq<T, U, V> {
	fn vpaddq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpaddsb<T, U, V> {
	fn vpaddsb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpaddsw<T, U, V> {
	fn vpaddsw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpaddusb<T, U, V> {
	fn vpaddusb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpaddusw<T, U, V> {
	fn vpaddusw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpaddw<T, U, V> {
	fn vpaddw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpalignr<T, U, V, W> {
	fn vpalignr(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpand<T, U, V> {
	fn vpand(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpandd<T, U, V> {
	fn vpandd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpandn<T, U, V> {
	fn vpandn(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpandnd<T, U, V> {
	fn vpandnd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpandnq<T, U, V> {
	fn vpandnq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpandq<T, U, V> {
	fn vpandq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpavgb<T, U, V> {
	fn vpavgb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpavgw<T, U, V> {
	fn vpavgw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpblendd<T, U, V, W> {
	fn vpblendd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpblendmb<T, U, V> {
	fn vpblendmb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpblendmd<T, U, V> {
	fn vpblendmd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpblendmq<T, U, V> {
	fn vpblendmq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpblendmw<T, U, V> {
	fn vpblendmw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpblendvb<T, U, V, W> {
	fn vpblendvb(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpblendw<T, U, V, W> {
	fn vpblendw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpbroadcastb<T, U> {
	fn vpbroadcastb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpbroadcastd<T, U> {
	fn vpbroadcastd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpbroadcastmb2q<T, U> {
	fn vpbroadcastmb2q(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpbroadcastmw2d<T, U> {
	fn vpbroadcastmw2d(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpbroadcastq<T, U> {
	fn vpbroadcastq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpbroadcastw<T, U> {
	fn vpbroadcastw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpclmulhqhqdq<T, U, V> {
	fn vpclmulhqhqdq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpclmulhqlqdq<T, U, V> {
	fn vpclmulhqlqdq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpclmullqhqdq<T, U, V> {
	fn vpclmullqhqdq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpclmullqlqdq<T, U, V> {
	fn vpclmullqlqdq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpclmulqdq<T, U, V, W> {
	fn vpclmulqdq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmov<T, U, V, W> {
	fn vpcmov(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpb<T, U, V, W> {
	fn vpcmpb(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpd<T, U, V, W> {
	fn vpcmpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpeqb<T, U, V> {
	fn vpcmpeqb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpeqd<T, U, V> {
	fn vpcmpeqd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpeqq<T, U, V> {
	fn vpcmpeqq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpequb<T, U, V> {
	fn vpcmpequb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpequd<T, U, V> {
	fn vpcmpequd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpequq<T, U, V> {
	fn vpcmpequq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpequw<T, U, V> {
	fn vpcmpequw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpeqw<T, U, V> {
	fn vpcmpeqw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpestri<T, U, V> {
	fn vpcmpestri(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpestri64<T, U, V> {
	fn vpcmpestri64(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpestrm<T, U, V> {
	fn vpcmpestrm(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpestrm64<T, U, V> {
	fn vpcmpestrm64(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpfalseb<T, U, V> {
	fn vpcmpfalseb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpfalsed<T, U, V> {
	fn vpcmpfalsed(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpfalseq<T, U, V> {
	fn vpcmpfalseq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpfalseub<T, U, V> {
	fn vpcmpfalseub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpfalseud<T, U, V> {
	fn vpcmpfalseud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpfalseuq<T, U, V> {
	fn vpcmpfalseuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpfalseuw<T, U, V> {
	fn vpcmpfalseuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpfalsew<T, U, V> {
	fn vpcmpfalsew(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpgtb<T, U, V> {
	fn vpcmpgtb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpgtd<T, U, V> {
	fn vpcmpgtd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpgtq<T, U, V> {
	fn vpcmpgtq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpgtw<T, U, V> {
	fn vpcmpgtw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpistri<T, U, V> {
	fn vpcmpistri(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpistrm<T, U, V> {
	fn vpcmpistrm(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpleb<T, U, V> {
	fn vpcmpleb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpled<T, U, V> {
	fn vpcmpled(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpleq<T, U, V> {
	fn vpcmpleq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpleub<T, U, V> {
	fn vpcmpleub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpleud<T, U, V> {
	fn vpcmpleud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpleuq<T, U, V> {
	fn vpcmpleuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpleuw<T, U, V> {
	fn vpcmpleuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmplew<T, U, V> {
	fn vpcmplew(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpltb<T, U, V> {
	fn vpcmpltb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpltd<T, U, V> {
	fn vpcmpltd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpltq<T, U, V> {
	fn vpcmpltq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpltub<T, U, V> {
	fn vpcmpltub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpltud<T, U, V> {
	fn vpcmpltud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpltuq<T, U, V> {
	fn vpcmpltuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpltuw<T, U, V> {
	fn vpcmpltuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpltw<T, U, V> {
	fn vpcmpltw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpneqb<T, U, V> {
	fn vpcmpneqb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpneqd<T, U, V> {
	fn vpcmpneqd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpneqq<T, U, V> {
	fn vpcmpneqq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnequb<T, U, V> {
	fn vpcmpnequb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnequd<T, U, V> {
	fn vpcmpnequd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnequq<T, U, V> {
	fn vpcmpnequq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnequw<T, U, V> {
	fn vpcmpnequw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpneqw<T, U, V> {
	fn vpcmpneqw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnleb<T, U, V> {
	fn vpcmpnleb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnled<T, U, V> {
	fn vpcmpnled(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnleq<T, U, V> {
	fn vpcmpnleq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnleub<T, U, V> {
	fn vpcmpnleub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnleud<T, U, V> {
	fn vpcmpnleud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnleuq<T, U, V> {
	fn vpcmpnleuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnleuw<T, U, V> {
	fn vpcmpnleuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnlew<T, U, V> {
	fn vpcmpnlew(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnltb<T, U, V> {
	fn vpcmpnltb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnltd<T, U, V> {
	fn vpcmpnltd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnltq<T, U, V> {
	fn vpcmpnltq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnltub<T, U, V> {
	fn vpcmpnltub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnltud<T, U, V> {
	fn vpcmpnltud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnltuq<T, U, V> {
	fn vpcmpnltuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnltuw<T, U, V> {
	fn vpcmpnltuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpnltw<T, U, V> {
	fn vpcmpnltw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpq<T, U, V, W> {
	fn vpcmpq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmptrueb<T, U, V> {
	fn vpcmptrueb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmptrued<T, U, V> {
	fn vpcmptrued(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmptrueq<T, U, V> {
	fn vpcmptrueq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmptrueub<T, U, V> {
	fn vpcmptrueub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmptrueud<T, U, V> {
	fn vpcmptrueud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmptrueuq<T, U, V> {
	fn vpcmptrueuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmptrueuw<T, U, V> {
	fn vpcmptrueuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmptruew<T, U, V> {
	fn vpcmptruew(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpub<T, U, V, W> {
	fn vpcmpub(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpud<T, U, V, W> {
	fn vpcmpud(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpuq<T, U, V, W> {
	fn vpcmpuq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpuw<T, U, V, W> {
	fn vpcmpuw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcmpw<T, U, V, W> {
	fn vpcmpw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomb<T, U, V, W> {
	fn vpcomb(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomd<T, U, V, W> {
	fn vpcomd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomeqb<T, U, V> {
	fn vpcomeqb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomeqd<T, U, V> {
	fn vpcomeqd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomeqq<T, U, V> {
	fn vpcomeqq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomequb<T, U, V> {
	fn vpcomequb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomequd<T, U, V> {
	fn vpcomequd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomequq<T, U, V> {
	fn vpcomequq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomequw<T, U, V> {
	fn vpcomequw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomeqw<T, U, V> {
	fn vpcomeqw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomfalseb<T, U, V> {
	fn vpcomfalseb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomfalsed<T, U, V> {
	fn vpcomfalsed(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomfalseq<T, U, V> {
	fn vpcomfalseq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomfalseub<T, U, V> {
	fn vpcomfalseub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomfalseud<T, U, V> {
	fn vpcomfalseud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomfalseuq<T, U, V> {
	fn vpcomfalseuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomfalseuw<T, U, V> {
	fn vpcomfalseuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomfalsew<T, U, V> {
	fn vpcomfalsew(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgeb<T, U, V> {
	fn vpcomgeb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomged<T, U, V> {
	fn vpcomged(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgeq<T, U, V> {
	fn vpcomgeq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgeub<T, U, V> {
	fn vpcomgeub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgeud<T, U, V> {
	fn vpcomgeud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgeuq<T, U, V> {
	fn vpcomgeuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgeuw<T, U, V> {
	fn vpcomgeuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgew<T, U, V> {
	fn vpcomgew(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgtb<T, U, V> {
	fn vpcomgtb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgtd<T, U, V> {
	fn vpcomgtd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgtq<T, U, V> {
	fn vpcomgtq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgtub<T, U, V> {
	fn vpcomgtub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgtud<T, U, V> {
	fn vpcomgtud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgtuq<T, U, V> {
	fn vpcomgtuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgtuw<T, U, V> {
	fn vpcomgtuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomgtw<T, U, V> {
	fn vpcomgtw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomleb<T, U, V> {
	fn vpcomleb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomled<T, U, V> {
	fn vpcomled(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomleq<T, U, V> {
	fn vpcomleq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomleub<T, U, V> {
	fn vpcomleub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomleud<T, U, V> {
	fn vpcomleud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomleuq<T, U, V> {
	fn vpcomleuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomleuw<T, U, V> {
	fn vpcomleuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomlew<T, U, V> {
	fn vpcomlew(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomltb<T, U, V> {
	fn vpcomltb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomltd<T, U, V> {
	fn vpcomltd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomltq<T, U, V> {
	fn vpcomltq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomltub<T, U, V> {
	fn vpcomltub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomltud<T, U, V> {
	fn vpcomltud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomltuq<T, U, V> {
	fn vpcomltuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomltuw<T, U, V> {
	fn vpcomltuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomltw<T, U, V> {
	fn vpcomltw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomneqb<T, U, V> {
	fn vpcomneqb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomneqd<T, U, V> {
	fn vpcomneqd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomneqq<T, U, V> {
	fn vpcomneqq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomnequb<T, U, V> {
	fn vpcomnequb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomnequd<T, U, V> {
	fn vpcomnequd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomnequq<T, U, V> {
	fn vpcomnequq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomnequw<T, U, V> {
	fn vpcomnequw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomneqw<T, U, V> {
	fn vpcomneqw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcompressb<T, U> {
	fn vpcompressb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcompressd<T, U> {
	fn vpcompressd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcompressq<T, U> {
	fn vpcompressq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcompressw<T, U> {
	fn vpcompressw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomq<T, U, V, W> {
	fn vpcomq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomtrueb<T, U, V> {
	fn vpcomtrueb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomtrued<T, U, V> {
	fn vpcomtrued(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomtrueq<T, U, V> {
	fn vpcomtrueq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomtrueub<T, U, V> {
	fn vpcomtrueub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomtrueud<T, U, V> {
	fn vpcomtrueud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomtrueuq<T, U, V> {
	fn vpcomtrueuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomtrueuw<T, U, V> {
	fn vpcomtrueuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomtruew<T, U, V> {
	fn vpcomtruew(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomub<T, U, V, W> {
	fn vpcomub(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomud<T, U, V, W> {
	fn vpcomud(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomuq<T, U, V, W> {
	fn vpcomuq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomuw<T, U, V, W> {
	fn vpcomuw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpcomw<T, U, V, W> {
	fn vpcomw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpconflictd<T, U> {
	fn vpconflictd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpconflictq<T, U> {
	fn vpconflictq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpbssd<T, U, V> {
	fn vpdpbssd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpbssds<T, U, V> {
	fn vpdpbssds(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpbsud<T, U, V> {
	fn vpdpbsud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpbsuds<T, U, V> {
	fn vpdpbsuds(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpbusd<T, U, V> {
	fn vpdpbusd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpbusds<T, U, V> {
	fn vpdpbusds(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpbuud<T, U, V> {
	fn vpdpbuud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpbuuds<T, U, V> {
	fn vpdpbuuds(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpwssd<T, U, V> {
	fn vpdpwssd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpwssds<T, U, V> {
	fn vpdpwssds(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpwsud<T, U, V> {
	fn vpdpwsud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpwsuds<T, U, V> {
	fn vpdpwsuds(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpwusd<T, U, V> {
	fn vpdpwusd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpwusds<T, U, V> {
	fn vpdpwusds(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpwuud<T, U, V> {
	fn vpdpwuud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpdpwuuds<T, U, V> {
	fn vpdpwuuds(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVperm2f128<T, U, V, W> {
	fn vperm2f128(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVperm2i128<T, U, V, W> {
	fn vperm2i128(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermb<T, U, V> {
	fn vpermb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermd<T, U, V> {
	fn vpermd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermi2b<T, U, V> {
	fn vpermi2b(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermi2d<T, U, V> {
	fn vpermi2d(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermi2pd<T, U, V> {
	fn vpermi2pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermi2ps<T, U, V> {
	fn vpermi2ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermi2q<T, U, V> {
	fn vpermi2q(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermi2w<T, U, V> {
	fn vpermi2w(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermil2pd<T, U, V, W, X> {
	fn vpermil2pd(&mut self, op0: T, op1: U, op2: V, op3: W, op4: X) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermil2ps<T, U, V, W, X> {
	fn vpermil2ps(&mut self, op0: T, op1: U, op2: V, op3: W, op4: X) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermilpd<T, U, V> {
	fn vpermilpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermilps<T, U, V> {
	fn vpermilps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermpd<T, U, V> {
	fn vpermpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermps<T, U, V> {
	fn vpermps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermq<T, U, V> {
	fn vpermq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermt2b<T, U, V> {
	fn vpermt2b(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermt2d<T, U, V> {
	fn vpermt2d(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermt2pd<T, U, V> {
	fn vpermt2pd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermt2ps<T, U, V> {
	fn vpermt2ps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermt2q<T, U, V> {
	fn vpermt2q(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermt2w<T, U, V> {
	fn vpermt2w(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpermw<T, U, V> {
	fn vpermw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpexpandb<T, U> {
	fn vpexpandb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpexpandd<T, U> {
	fn vpexpandd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpexpandq<T, U> {
	fn vpexpandq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpexpandw<T, U> {
	fn vpexpandw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpextrb<T, U, V> {
	fn vpextrb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpextrd<T, U, V> {
	fn vpextrd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpextrq<T, U, V> {
	fn vpextrq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpextrw<T, U, V> {
	fn vpextrw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpgatherdd<T, U> {
	fn vpgatherdd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpgatherdd3<T, U, V> {
	fn vpgatherdd_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpgatherdq<T, U> {
	fn vpgatherdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpgatherdq3<T, U, V> {
	fn vpgatherdq_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpgatherqd<T, U> {
	fn vpgatherqd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpgatherqd3<T, U, V> {
	fn vpgatherqd_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpgatherqq<T, U> {
	fn vpgatherqq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpgatherqq3<T, U, V> {
	fn vpgatherqq_3(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddbd<T, U> {
	fn vphaddbd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddbq<T, U> {
	fn vphaddbq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddbw<T, U> {
	fn vphaddbw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddd<T, U, V> {
	fn vphaddd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphadddq<T, U> {
	fn vphadddq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddsw<T, U, V> {
	fn vphaddsw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddubd<T, U> {
	fn vphaddubd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddubq<T, U> {
	fn vphaddubq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddubw<T, U> {
	fn vphaddubw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddudq<T, U> {
	fn vphaddudq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphadduwd<T, U> {
	fn vphadduwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphadduwq<T, U> {
	fn vphadduwq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddw<T, U, V> {
	fn vphaddw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddwd<T, U> {
	fn vphaddwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphaddwq<T, U> {
	fn vphaddwq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphminposuw<T, U> {
	fn vphminposuw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphsubbw<T, U> {
	fn vphsubbw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphsubd<T, U, V> {
	fn vphsubd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphsubdq<T, U> {
	fn vphsubdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphsubsw<T, U, V> {
	fn vphsubsw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphsubw<T, U, V> {
	fn vphsubw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVphsubwd<T, U> {
	fn vphsubwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpinsrb<T, U, V, W> {
	fn vpinsrb(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpinsrd<T, U, V, W> {
	fn vpinsrd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpinsrq<T, U, V, W> {
	fn vpinsrq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpinsrw<T, U, V, W> {
	fn vpinsrw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVplzcntd<T, U> {
	fn vplzcntd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVplzcntq<T, U> {
	fn vplzcntq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacsdd<T, U, V, W> {
	fn vpmacsdd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacsdqh<T, U, V, W> {
	fn vpmacsdqh(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacsdql<T, U, V, W> {
	fn vpmacsdql(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacssdd<T, U, V, W> {
	fn vpmacssdd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacssdqh<T, U, V, W> {
	fn vpmacssdqh(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacssdql<T, U, V, W> {
	fn vpmacssdql(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacsswd<T, U, V, W> {
	fn vpmacsswd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacssww<T, U, V, W> {
	fn vpmacssww(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacswd<T, U, V, W> {
	fn vpmacswd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmacsww<T, U, V, W> {
	fn vpmacsww(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmadcsswd<T, U, V, W> {
	fn vpmadcsswd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmadcswd<T, U, V, W> {
	fn vpmadcswd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmadd52huq<T, U, V> {
	fn vpmadd52huq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmadd52luq<T, U, V> {
	fn vpmadd52luq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaddubsw<T, U, V> {
	fn vpmaddubsw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaddwd<T, U, V> {
	fn vpmaddwd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaskmovd<T, U, V> {
	fn vpmaskmovd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaskmovq<T, U, V> {
	fn vpmaskmovq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaxsb<T, U, V> {
	fn vpmaxsb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaxsd<T, U, V> {
	fn vpmaxsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaxsq<T, U, V> {
	fn vpmaxsq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaxsw<T, U, V> {
	fn vpmaxsw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaxub<T, U, V> {
	fn vpmaxub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaxud<T, U, V> {
	fn vpmaxud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaxuq<T, U, V> {
	fn vpmaxuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmaxuw<T, U, V> {
	fn vpmaxuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpminsb<T, U, V> {
	fn vpminsb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpminsd<T, U, V> {
	fn vpminsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpminsq<T, U, V> {
	fn vpminsq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpminsw<T, U, V> {
	fn vpminsw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpminub<T, U, V> {
	fn vpminub(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpminud<T, U, V> {
	fn vpminud(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpminuq<T, U, V> {
	fn vpminuq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpminuw<T, U, V> {
	fn vpminuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovb2m<T, U> {
	fn vpmovb2m(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovd2m<T, U> {
	fn vpmovd2m(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovdb<T, U> {
	fn vpmovdb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovdw<T, U> {
	fn vpmovdw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovm2b<T, U> {
	fn vpmovm2b(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovm2d<T, U> {
	fn vpmovm2d(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovm2q<T, U> {
	fn vpmovm2q(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovm2w<T, U> {
	fn vpmovm2w(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovmskb<T, U> {
	fn vpmovmskb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovq2m<T, U> {
	fn vpmovq2m(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovqb<T, U> {
	fn vpmovqb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovqd<T, U> {
	fn vpmovqd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovqw<T, U> {
	fn vpmovqw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsdb<T, U> {
	fn vpmovsdb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsdw<T, U> {
	fn vpmovsdw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsqb<T, U> {
	fn vpmovsqb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsqd<T, U> {
	fn vpmovsqd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsqw<T, U> {
	fn vpmovsqw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovswb<T, U> {
	fn vpmovswb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsxbd<T, U> {
	fn vpmovsxbd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsxbq<T, U> {
	fn vpmovsxbq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsxbw<T, U> {
	fn vpmovsxbw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsxdq<T, U> {
	fn vpmovsxdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsxwd<T, U> {
	fn vpmovsxwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovsxwq<T, U> {
	fn vpmovsxwq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovusdb<T, U> {
	fn vpmovusdb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovusdw<T, U> {
	fn vpmovusdw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovusqb<T, U> {
	fn vpmovusqb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovusqd<T, U> {
	fn vpmovusqd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovusqw<T, U> {
	fn vpmovusqw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovuswb<T, U> {
	fn vpmovuswb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovw2m<T, U> {
	fn vpmovw2m(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovwb<T, U> {
	fn vpmovwb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovzxbd<T, U> {
	fn vpmovzxbd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovzxbq<T, U> {
	fn vpmovzxbq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovzxbw<T, U> {
	fn vpmovzxbw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovzxdq<T, U> {
	fn vpmovzxdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovzxwd<T, U> {
	fn vpmovzxwd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmovzxwq<T, U> {
	fn vpmovzxwq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmuldq<T, U, V> {
	fn vpmuldq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmulhrsw<T, U, V> {
	fn vpmulhrsw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmulhuw<T, U, V> {
	fn vpmulhuw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmulhw<T, U, V> {
	fn vpmulhw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmulld<T, U, V> {
	fn vpmulld(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmullq<T, U, V> {
	fn vpmullq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmullw<T, U, V> {
	fn vpmullw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmultishiftqb<T, U, V> {
	fn vpmultishiftqb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpmuludq<T, U, V> {
	fn vpmuludq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpopcntb<T, U> {
	fn vpopcntb(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpopcntd<T, U> {
	fn vpopcntd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpopcntq<T, U> {
	fn vpopcntq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpopcntw<T, U> {
	fn vpopcntw(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpor<T, U, V> {
	fn vpor(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpord<T, U, V> {
	fn vpord(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVporq<T, U, V> {
	fn vporq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpperm<T, U, V, W> {
	fn vpperm(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprold<T, U, V> {
	fn vprold(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprolq<T, U, V> {
	fn vprolq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprolvd<T, U, V> {
	fn vprolvd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprolvq<T, U, V> {
	fn vprolvq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprord<T, U, V> {
	fn vprord(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprorq<T, U, V> {
	fn vprorq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprorvd<T, U, V> {
	fn vprorvd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprorvq<T, U, V> {
	fn vprorvq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprotb<T, U, V> {
	fn vprotb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprotd<T, U, V> {
	fn vprotd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprotq<T, U, V> {
	fn vprotq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVprotw<T, U, V> {
	fn vprotw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsadbw<T, U, V> {
	fn vpsadbw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpscatterdd<T, U> {
	fn vpscatterdd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpscatterdq<T, U> {
	fn vpscatterdq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpscatterqd<T, U> {
	fn vpscatterqd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpscatterqq<T, U> {
	fn vpscatterqq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshab<T, U, V> {
	fn vpshab(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshad<T, U, V> {
	fn vpshad(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshaq<T, U, V> {
	fn vpshaq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshaw<T, U, V> {
	fn vpshaw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshlb<T, U, V> {
	fn vpshlb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshld<T, U, V> {
	fn vpshld(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshldd<T, U, V, W> {
	fn vpshldd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshldq<T, U, V, W> {
	fn vpshldq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshldvd<T, U, V> {
	fn vpshldvd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshldvq<T, U, V> {
	fn vpshldvq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshldvw<T, U, V> {
	fn vpshldvw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshldw<T, U, V, W> {
	fn vpshldw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshlq<T, U, V> {
	fn vpshlq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshlw<T, U, V> {
	fn vpshlw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshrdd<T, U, V, W> {
	fn vpshrdd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshrdq<T, U, V, W> {
	fn vpshrdq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshrdvd<T, U, V> {
	fn vpshrdvd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshrdvq<T, U, V> {
	fn vpshrdvq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshrdvw<T, U, V> {
	fn vpshrdvw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshrdw<T, U, V, W> {
	fn vpshrdw(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshufb<T, U, V> {
	fn vpshufb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshufbitqmb<T, U, V> {
	fn vpshufbitqmb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshufd<T, U, V> {
	fn vpshufd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshufhw<T, U, V> {
	fn vpshufhw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpshuflw<T, U, V> {
	fn vpshuflw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsignb<T, U, V> {
	fn vpsignb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsignd<T, U, V> {
	fn vpsignd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsignw<T, U, V> {
	fn vpsignw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpslld<T, U, V> {
	fn vpslld(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpslldq<T, U, V> {
	fn vpslldq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsllq<T, U, V> {
	fn vpsllq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsllvd<T, U, V> {
	fn vpsllvd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsllvq<T, U, V> {
	fn vpsllvq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsllvw<T, U, V> {
	fn vpsllvw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsllw<T, U, V> {
	fn vpsllw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsrad<T, U, V> {
	fn vpsrad(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsraq<T, U, V> {
	fn vpsraq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsravd<T, U, V> {
	fn vpsravd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsravq<T, U, V> {
	fn vpsravq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsravw<T, U, V> {
	fn vpsravw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsraw<T, U, V> {
	fn vpsraw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsrld<T, U, V> {
	fn vpsrld(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsrldq<T, U, V> {
	fn vpsrldq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsrlq<T, U, V> {
	fn vpsrlq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsrlvd<T, U, V> {
	fn vpsrlvd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsrlvq<T, U, V> {
	fn vpsrlvq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsrlvw<T, U, V> {
	fn vpsrlvw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsrlw<T, U, V> {
	fn vpsrlw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsubb<T, U, V> {
	fn vpsubb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsubd<T, U, V> {
	fn vpsubd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsubq<T, U, V> {
	fn vpsubq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsubsb<T, U, V> {
	fn vpsubsb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsubsw<T, U, V> {
	fn vpsubsw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsubusb<T, U, V> {
	fn vpsubusb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsubusw<T, U, V> {
	fn vpsubusw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpsubw<T, U, V> {
	fn vpsubw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpternlogd<T, U, V, W> {
	fn vpternlogd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpternlogq<T, U, V, W> {
	fn vpternlogq(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVptest<T, U> {
	fn vptest(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVptestmb<T, U, V> {
	fn vptestmb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVptestmd<T, U, V> {
	fn vptestmd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVptestmq<T, U, V> {
	fn vptestmq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVptestmw<T, U, V> {
	fn vptestmw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVptestnmb<T, U, V> {
	fn vptestnmb(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVptestnmd<T, U, V> {
	fn vptestnmd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVptestnmq<T, U, V> {
	fn vptestnmq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVptestnmw<T, U, V> {
	fn vptestnmw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpunpckhbw<T, U, V> {
	fn vpunpckhbw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpunpckhdq<T, U, V> {
	fn vpunpckhdq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpunpckhqdq<T, U, V> {
	fn vpunpckhqdq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpunpckhwd<T, U, V> {
	fn vpunpckhwd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpunpcklbw<T, U, V> {
	fn vpunpcklbw(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpunpckldq<T, U, V> {
	fn vpunpckldq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpunpcklqdq<T, U, V> {
	fn vpunpcklqdq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpunpcklwd<T, U, V> {
	fn vpunpcklwd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpxor<T, U, V> {
	fn vpxor(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpxord<T, U, V> {
	fn vpxord(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVpxorq<T, U, V> {
	fn vpxorq(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrangepd<T, U, V, W> {
	fn vrangepd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrangeps<T, U, V, W> {
	fn vrangeps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrangesd<T, U, V, W> {
	fn vrangesd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrangess<T, U, V, W> {
	fn vrangess(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcp14pd<T, U> {
	fn vrcp14pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcp14ps<T, U> {
	fn vrcp14ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcp14sd<T, U, V> {
	fn vrcp14sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcp14ss<T, U, V> {
	fn vrcp14ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcp28pd<T, U> {
	fn vrcp28pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcp28ps<T, U> {
	fn vrcp28ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcp28sd<T, U, V> {
	fn vrcp28sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcp28ss<T, U, V> {
	fn vrcp28ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcpph<T, U> {
	fn vrcpph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcpps<T, U> {
	fn vrcpps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcpsh<T, U, V> {
	fn vrcpsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrcpss<T, U, V> {
	fn vrcpss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVreducepd<T, U, V> {
	fn vreducepd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVreduceph<T, U, V> {
	fn vreduceph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVreduceps<T, U, V> {
	fn vreduceps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVreducesd<T, U, V, W> {
	fn vreducesd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVreducesh<T, U, V, W> {
	fn vreducesh(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVreducess<T, U, V, W> {
	fn vreducess(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrndscalepd<T, U, V> {
	fn vrndscalepd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrndscaleph<T, U, V> {
	fn vrndscaleph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrndscaleps<T, U, V> {
	fn vrndscaleps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrndscalesd<T, U, V, W> {
	fn vrndscalesd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrndscalesh<T, U, V, W> {
	fn vrndscalesh(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrndscaless<T, U, V, W> {
	fn vrndscaless(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVroundpd<T, U, V> {
	fn vroundpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVroundps<T, U, V> {
	fn vroundps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVroundsd<T, U, V, W> {
	fn vroundsd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVroundss<T, U, V, W> {
	fn vroundss(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrt14pd<T, U> {
	fn vrsqrt14pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrt14ps<T, U> {
	fn vrsqrt14ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrt14sd<T, U, V> {
	fn vrsqrt14sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrt14ss<T, U, V> {
	fn vrsqrt14ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrt28pd<T, U> {
	fn vrsqrt28pd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrt28ps<T, U> {
	fn vrsqrt28ps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrt28sd<T, U, V> {
	fn vrsqrt28sd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrt28ss<T, U, V> {
	fn vrsqrt28ss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrtph<T, U> {
	fn vrsqrtph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrtps<T, U> {
	fn vrsqrtps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrtsh<T, U, V> {
	fn vrsqrtsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVrsqrtss<T, U, V> {
	fn vrsqrtss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscalefpd<T, U, V> {
	fn vscalefpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscalefph<T, U, V> {
	fn vscalefph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscalefps<T, U, V> {
	fn vscalefps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscalefsd<T, U, V> {
	fn vscalefsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscalefsh<T, U, V> {
	fn vscalefsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscalefss<T, U, V> {
	fn vscalefss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterdpd<T, U> {
	fn vscatterdpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterdps<T, U> {
	fn vscatterdps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterpf0dpd<T> {
	fn vscatterpf0dpd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterpf0dps<T> {
	fn vscatterpf0dps(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterpf0qpd<T> {
	fn vscatterpf0qpd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterpf0qps<T> {
	fn vscatterpf0qps(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterpf1dpd<T> {
	fn vscatterpf1dpd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterpf1dps<T> {
	fn vscatterpf1dps(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterpf1qpd<T> {
	fn vscatterpf1qpd(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterpf1qps<T> {
	fn vscatterpf1qps(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterqpd<T, U> {
	fn vscatterqpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVscatterqps<T, U> {
	fn vscatterqps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsha512msg1<T, U> {
	fn vsha512msg1(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsha512msg2<T, U> {
	fn vsha512msg2(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsha512rnds2<T, U, V> {
	fn vsha512rnds2(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVshuff32x4<T, U, V, W> {
	fn vshuff32x4(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVshuff64x2<T, U, V, W> {
	fn vshuff64x2(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVshufi32x4<T, U, V, W> {
	fn vshufi32x4(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVshufi64x2<T, U, V, W> {
	fn vshufi64x2(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVshufpd<T, U, V, W> {
	fn vshufpd(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVshufps<T, U, V, W> {
	fn vshufps(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsm3msg1<T, U, V> {
	fn vsm3msg1(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsm3msg2<T, U, V> {
	fn vsm3msg2(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsm3rnds2<T, U, V, W> {
	fn vsm3rnds2(&mut self, op0: T, op1: U, op2: V, op3: W) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsm4key4<T, U, V> {
	fn vsm4key4(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsm4rnds4<T, U, V> {
	fn vsm4rnds4(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsqrtpd<T, U> {
	fn vsqrtpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsqrtph<T, U> {
	fn vsqrtph(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsqrtps<T, U> {
	fn vsqrtps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsqrtsd<T, U, V> {
	fn vsqrtsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsqrtsh<T, U, V> {
	fn vsqrtsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsqrtss<T, U, V> {
	fn vsqrtss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVstmxcsr<T> {
	fn vstmxcsr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsubpd<T, U, V> {
	fn vsubpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsubph<T, U, V> {
	fn vsubph(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsubps<T, U, V> {
	fn vsubps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsubsd<T, U, V> {
	fn vsubsd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsubsh<T, U, V> {
	fn vsubsh(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVsubss<T, U, V> {
	fn vsubss(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVtestpd<T, U> {
	fn vtestpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVtestps<T, U> {
	fn vtestps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVucomisd<T, U> {
	fn vucomisd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVucomish<T, U> {
	fn vucomish(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVucomiss<T, U> {
	fn vucomiss(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVunpckhpd<T, U, V> {
	fn vunpckhpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVunpckhps<T, U, V> {
	fn vunpckhps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVunpcklpd<T, U, V> {
	fn vunpcklpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVunpcklps<T, U, V> {
	fn vunpcklps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVxorpd<T, U, V> {
	fn vxorpd(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVxorps<T, U, V> {
	fn vxorps(&mut self, op0: T, op1: U, op2: V) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVzeroall {
	fn vzeroall(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmVzeroupper {
	fn vzeroupper(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWait {
	fn wait(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWbinvd {
	fn wbinvd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWbnoinvd {
	fn wbnoinvd(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrfsbase<T> {
	fn wrfsbase(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrgsbase<T> {
	fn wrgsbase(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrmsr {
	fn wrmsr(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrmsrlist {
	fn wrmsrlist(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrmsrns {
	fn wrmsrns(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrpkru {
	fn wrpkru(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrshr<T> {
	fn wrshr(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrssd<T, U> {
	fn wrssd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrssq<T, U> {
	fn wrssq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrudbg {
	fn wrudbg(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrussd<T, U> {
	fn wrussd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmWrussq<T, U> {
	fn wrussq(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXabort<T> {
	fn xabort(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXadd<T, U> {
	fn xadd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXbegin<T> {
	fn xbegin(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXbts<T, U> {
	fn xbts(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXchg<T, U> {
	fn xchg(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXcryptcbc {
	fn xcryptcbc(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXcryptcfb {
	fn xcryptcfb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXcryptctr {
	fn xcryptctr(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXcryptecb {
	fn xcryptecb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXcryptofb {
	fn xcryptofb(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXend {
	fn xend(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXgetbv {
	fn xgetbv(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXor<T, U> {
	fn xor(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXorpd<T, U> {
	fn xorpd(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXorps<T, U> {
	fn xorps(&mut self, op0: T, op1: U) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXresldtrk {
	fn xresldtrk(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXrstor<T> {
	fn xrstor(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXrstor64<T> {
	fn xrstor64(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXrstors<T> {
	fn xrstors(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXrstors64<T> {
	fn xrstors64(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsave<T> {
	fn xsave(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsave64<T> {
	fn xsave64(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsavec<T> {
	fn xsavec(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsavec64<T> {
	fn xsavec64(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsaveopt<T> {
	fn xsaveopt(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsaveopt64<T> {
	fn xsaveopt64(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsaves<T> {
	fn xsaves(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsaves64<T> {
	fn xsaves64(&mut self, op0: T) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsetbv {
	fn xsetbv(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsha1 {
	fn xsha1(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsha256 {
	fn xsha256(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsha512 {
	fn xsha512(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsha512_alt {
	fn xsha512_alt(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXstore {
	fn xstore(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXstore_alt {
	fn xstore_alt(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXsusldtrk {
	fn xsusldtrk(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmXtest {
	fn xtest(&mut self) -> Result<(), IcedError>;
}

#[rustfmt::skip]
pub trait CodeAsmZero_bytes {
	fn zero_bytes(&mut self) -> Result<(), IcedError>;
}
