// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// âš ï¸This file was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸

#![allow(clippy::if_same_then_else)]
#![allow(clippy::missing_inline_in_public_items)]

use crate::code_asm::asm_traits::*;
use crate::code_asm::mem::*;
use crate::code_asm::op_state::MemoryOperandSize;
use crate::code_asm::reg::*;
use crate::code_asm::{CodeAssembler, CodeLabel};
use crate::{Code, IcedError, Instruction, Register, RepPrefixKind};

#[rustfmt::skip]
impl CodeAsmAaa for CodeAssembler {
	#[inline]
	fn aaa(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Aaa))
	}
}

#[rustfmt::skip]
impl CodeAsmAad<i32> for CodeAssembler {
	#[inline]
	fn aad(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aad_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAad<u32> for CodeAssembler {
	#[inline]
	fn aad(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aad_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAadd<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn aadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aadd_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAadd<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn aadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aadd_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAam<i32> for CodeAssembler {
	#[inline]
	fn aam(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aam_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAam<u32> for CodeAssembler {
	#[inline]
	fn aam(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aam_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAand<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn aand(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aand_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAand<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn aand(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aand_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAas for CodeAssembler {
	#[inline]
	fn aas(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Aas))
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adc_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Adc_AL_imm8 } else { Code::Adc_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister16, i32> for CodeAssembler {
	fn adc(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Adc_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Adc_rm16_imm8
		} else {
			Code::Adc_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister32, i32> for CodeAssembler {
	fn adc(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Adc_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Adc_rm32_imm8
		} else {
			Code::Adc_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister64, i32> for CodeAssembler {
	fn adc(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Adc_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Adc_rm64_imm8
		} else {
			Code::Adc_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmMemoryOperand, i32> for CodeAssembler {
	fn adc(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Adc_rm64_imm8 } else { Code::Adc_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Adc_rm32_imm8 } else { Code::Adc_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Adc_rm16_imm8 } else { Code::Adc_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Adc_rm8_imm8
		} else {
			return Err(IcedError::new("adc: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn adc(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Adc_AL_imm8 } else { Code::Adc_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister16, u32> for CodeAssembler {
	fn adc(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Adc_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Adc_rm16_imm8
		} else {
			Code::Adc_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmRegister32, u32> for CodeAssembler {
	fn adc(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Adc_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Adc_rm32_imm8
		} else {
			Code::Adc_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdc<AsmMemoryOperand, u32> for CodeAssembler {
	fn adc(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Adc_rm32_imm8 } else { Code::Adc_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Adc_rm16_imm8 } else { Code::Adc_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Adc_rm8_imm8
		} else {
			return Err(IcedError::new("adc: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdcx<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn adcx(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adcx_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdcx<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn adcx(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adcx_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdcx<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adcx(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adcx_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdcx<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adcx(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adcx_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Add_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Add_AL_imm8 } else { Code::Add_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister16, i32> for CodeAssembler {
	fn add(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Add_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Add_rm16_imm8
		} else {
			Code::Add_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister32, i32> for CodeAssembler {
	fn add(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Add_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Add_rm32_imm8
		} else {
			Code::Add_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister64, i32> for CodeAssembler {
	fn add(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Add_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Add_rm64_imm8
		} else {
			Code::Add_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmMemoryOperand, i32> for CodeAssembler {
	fn add(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Add_rm64_imm8 } else { Code::Add_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Add_rm32_imm8 } else { Code::Add_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Add_rm16_imm8 } else { Code::Add_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Add_rm8_imm8
		} else {
			return Err(IcedError::new("add: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn add(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Add_AL_imm8 } else { Code::Add_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister16, u32> for CodeAssembler {
	fn add(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Add_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Add_rm16_imm8
		} else {
			Code::Add_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmRegister32, u32> for CodeAssembler {
	fn add(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Add_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Add_rm32_imm8
		} else {
			Code::Add_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdd<AsmMemoryOperand, u32> for CodeAssembler {
	fn add(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Add_rm32_imm8 } else { Code::Add_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Add_rm16_imm8 } else { Code::Add_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Add_rm8_imm8
		} else {
			return Err(IcedError::new("add: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsubpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsubpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsubpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsubpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsubps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn addsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsubps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAddsubps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn addsubps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Addsubps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdox<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn adox(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adox_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdox<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn adox(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adox_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdox<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adox(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adox_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAdox<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn adox(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Adox_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdec<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesdec(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdec_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdec<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdec(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdec_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdec128kl<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdec128kl(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdec128kl_xmm_m384, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdec256kl<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdec256kl(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdec256kl_xmm_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdeclast<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesdeclast(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdeclast_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdeclast<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdeclast(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesdeclast_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdecwide128kl<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdecwide128kl(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aesdecwide128kl_m384, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesdecwide256kl<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesdecwide256kl(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aesdecwide256kl_m512, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenc<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesenc(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenc_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenc<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesenc(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenc_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenc128kl<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesenc128kl(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenc128kl_xmm_m384, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenc256kl<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesenc256kl(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenc256kl_xmm_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenclast<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesenclast(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenclast_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesenclast<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesenclast(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesenclast_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesencwide128kl<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesencwide128kl(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aesencwide128kl_m384, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesencwide256kl<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesencwide256kl(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Aesencwide256kl_m512, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesimc<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn aesimc(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesimc_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAesimc<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn aesimc(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aesimc_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAeskeygenassist<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn aeskeygenassist(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Aeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAeskeygenassist<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn aeskeygenassist(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Aeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAeskeygenassist<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn aeskeygenassist(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Aeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAeskeygenassist<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn aeskeygenassist(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Aeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAltinst for CodeAssembler {
	#[inline]
	fn altinst(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Altinst))
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::And_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::And_AL_imm8 } else { Code::And_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister16, i32> for CodeAssembler {
	fn and(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::And_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::And_rm16_imm8
		} else {
			Code::And_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister32, i32> for CodeAssembler {
	fn and(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::And_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::And_rm32_imm8
		} else {
			Code::And_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister64, i32> for CodeAssembler {
	fn and(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::And_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::And_rm64_imm8
		} else {
			Code::And_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmMemoryOperand, i32> for CodeAssembler {
	fn and(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::And_rm64_imm8 } else { Code::And_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::And_rm32_imm8 } else { Code::And_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::And_rm16_imm8 } else { Code::And_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::And_rm8_imm8
		} else {
			return Err(IcedError::new("and: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn and(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::And_AL_imm8 } else { Code::And_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister16, u32> for CodeAssembler {
	fn and(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::And_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::And_rm16_imm8
		} else {
			Code::And_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmRegister32, u32> for CodeAssembler {
	fn and(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::And_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::And_rm32_imm8
		} else {
			Code::And_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAnd<AsmMemoryOperand, u32> for CodeAssembler {
	fn and(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::And_rm32_imm8 } else { Code::And_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::And_rm16_imm8 } else { Code::And_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::And_rm8_imm8
		} else {
			return Err(IcedError::new("and: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndn<AsmRegister32, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn andn(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Andn_r32_r32_rm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndn<AsmRegister64, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn andn(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Andn_r64_r64_rm64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndn<AsmRegister32, AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andn(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Andn_r32_r32_rm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndn<AsmRegister64, AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andn(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Andn_r64_r64_rm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndnpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn andnpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andnpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndnpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andnpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andnpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndnps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn andnps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andnps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndnps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andnps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andnps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn andpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn andps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAndps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn andps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Andps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmAor<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn aor(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aor_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAor<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn aor(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Aor_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmArpl<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn arpl(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Arpl_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmArpl<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn arpl(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Arpl_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmArpl<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn arpl(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Arpl_r32m16_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmArpl<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn arpl(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Arpl_r32m16_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAxor<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn axor(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Axor_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmAxor<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn axor(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Axor_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBb0_reset for CodeAssembler {
	#[inline]
	fn bb0_reset(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Bb0_reset))
	}
}

#[rustfmt::skip]
impl CodeAsmBb1_reset for CodeAssembler {
	#[inline]
	fn bb1_reset(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Bb1_reset))
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister32, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bextr_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister32, AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bextr_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister64, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bextr_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister64, AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bextr_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister32, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister64, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r64_rm64_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister32, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister64, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r64_rm64_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister32, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister64, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r64_rm64_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister32, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBextr<AsmRegister64, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn bextr(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Bextr_r64_rm64_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcfill<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blcfill(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcfill_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcfill<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blcfill(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcfill_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcfill<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcfill(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcfill_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcfill<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcfill(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcfill_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlci<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blci(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blci_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlci<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blci(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blci_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlci<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blci(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blci_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlci<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blci(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blci_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcic<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blcic(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcic_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcic<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blcic(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcic_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcic<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcic(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcic_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcic<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcic(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcic_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcmsk<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blcmsk(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcmsk_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcmsk<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blcmsk(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcmsk_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcmsk<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcmsk(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcmsk_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcmsk<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcmsk(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcmsk_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcs<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blcs(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcs_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcs<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blcs(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcs_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcs<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcs(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcs_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlcs<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blcs(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blcs_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendpd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn blendpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendpd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn blendpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendpd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn blendpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendpd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn blendpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn blendps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn blendps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn blendps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn blendps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Blendps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendvpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn blendvpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Blendvpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendvpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blendvpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Blendvpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendvps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn blendvps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Blendvps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlendvps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blendvps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Blendvps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsfill<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsfill(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsfill_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsfill<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsfill(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsfill_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsfill<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsfill(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsfill_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsfill<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsfill(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsfill_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsi<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsi(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsi_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsi<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsi(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsi_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsi<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsi(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsi_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsi<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsi(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsi_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsic<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsic(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsic_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsic<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsic(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsic_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsic<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsic(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsic_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsic<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsic(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Blsic_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsmsk<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsmsk(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsmsk_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsmsk<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsmsk(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsmsk_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsmsk<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsmsk(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsmsk_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsmsk<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsmsk(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsmsk_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsr<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn blsr(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsr_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsr<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn blsr(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsr_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsr<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsr(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsr_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBlsr<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn blsr(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Blsr_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcl<AsmRegisterBnd, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bndcl(&mut self, op0: AsmRegisterBnd, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcl_bnd_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcl<AsmRegisterBnd, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bndcl(&mut self, op0: AsmRegisterBnd, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcl_bnd_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcl<AsmRegisterBnd, AsmMemoryOperand> for CodeAssembler {
	fn bndcl(&mut self, op0: AsmRegisterBnd, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Bndcl_bnd_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Bndcl_bnd_rm32
		} else {
			return Err(IcedError::new("bndcl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcn<AsmRegisterBnd, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bndcn(&mut self, op0: AsmRegisterBnd, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcn_bnd_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcn<AsmRegisterBnd, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bndcn(&mut self, op0: AsmRegisterBnd, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcn_bnd_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcn<AsmRegisterBnd, AsmMemoryOperand> for CodeAssembler {
	fn bndcn(&mut self, op0: AsmRegisterBnd, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Bndcn_bnd_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Bndcn_bnd_rm32
		} else {
			return Err(IcedError::new("bndcn: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcu<AsmRegisterBnd, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bndcu(&mut self, op0: AsmRegisterBnd, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcu_bnd_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcu<AsmRegisterBnd, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bndcu(&mut self, op0: AsmRegisterBnd, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndcu_bnd_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndcu<AsmRegisterBnd, AsmMemoryOperand> for CodeAssembler {
	fn bndcu(&mut self, op0: AsmRegisterBnd, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Bndcu_bnd_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Bndcu_bnd_rm32
		} else {
			return Err(IcedError::new("bndcu: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndldx<AsmRegisterBnd, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bndldx(&mut self, op0: AsmRegisterBnd, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndldx_bnd_mib, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndmk<AsmRegisterBnd, AsmMemoryOperand> for CodeAssembler {
	fn bndmk(&mut self, op0: AsmRegisterBnd, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Bndmk_bnd_m64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Bndmk_bnd_m32
		} else {
			return Err(IcedError::new("bndmk: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndmov<AsmRegisterBnd, AsmRegisterBnd> for CodeAssembler {
	#[inline]
	fn bndmov(&mut self, op0: AsmRegisterBnd, op1: AsmRegisterBnd) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Bndmov_bnd_bndm128 } else { Code::Bndmov_bnd_bndm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndmov<AsmMemoryOperand, AsmRegisterBnd> for CodeAssembler {
	#[inline]
	fn bndmov(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterBnd) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Bndmov_bndm128_bnd } else { Code::Bndmov_bndm64_bnd };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndmov<AsmRegisterBnd, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bndmov(&mut self, op0: AsmRegisterBnd, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Bndmov_bnd_bndm128 } else { Code::Bndmov_bnd_bndm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBndstx<AsmMemoryOperand, AsmRegisterBnd> for CodeAssembler {
	#[inline]
	fn bndstx(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterBnd) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bndstx_mib_bnd, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBound<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bound(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bound_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBound<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bound(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bound_r32_m3232, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsf<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsf(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsf_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBsr<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn bsr(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bsr_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmBswap<AsmRegister16> for CodeAssembler {
	#[inline]
	fn bswap(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Bswap_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBswap<AsmRegister32> for CodeAssembler {
	#[inline]
	fn bswap(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Bswap_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBswap<AsmRegister64> for CodeAssembler {
	#[inline]
	fn bswap(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Bswap_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmMemoryOperand, i32> for CodeAssembler {
	fn bt(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Bt_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Bt_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Bt_rm16_imm8
		} else {
			return Err(IcedError::new("bt: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn bt(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bt_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBt<AsmMemoryOperand, u32> for CodeAssembler {
	fn bt(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Bt_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Bt_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Bt_rm16_imm8
		} else {
			return Err(IcedError::new("bt: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmMemoryOperand, i32> for CodeAssembler {
	fn btc(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Btc_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Btc_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Btc_rm16_imm8
		} else {
			return Err(IcedError::new("btc: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn btc(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btc_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtc<AsmMemoryOperand, u32> for CodeAssembler {
	fn btc(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Btc_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Btc_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Btc_rm16_imm8
		} else {
			return Err(IcedError::new("btc: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmMemoryOperand, i32> for CodeAssembler {
	fn btr(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Btr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Btr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Btr_rm16_imm8
		} else {
			return Err(IcedError::new("btr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn btr(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Btr_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBtr<AsmMemoryOperand, u32> for CodeAssembler {
	fn btr(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Btr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Btr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Btr_rm16_imm8
		} else {
			return Err(IcedError::new("btr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmMemoryOperand, i32> for CodeAssembler {
	fn bts(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Bts_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Bts_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Bts_rm16_imm8
		} else {
			return Err(IcedError::new("bts: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm16_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm32_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn bts(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Bts_rm64_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBts<AsmMemoryOperand, u32> for CodeAssembler {
	fn bts(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Bts_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Bts_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Bts_rm16_imm8
		} else {
			return Err(IcedError::new("bts: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmBzhi<AsmRegister32, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bzhi(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bzhi_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBzhi<AsmRegister32, AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn bzhi(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bzhi_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBzhi<AsmRegister64, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bzhi(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bzhi_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmBzhi<AsmRegister64, AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn bzhi(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Bzhi_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<AsmRegister16> for CodeAssembler {
	#[inline]
	fn call(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Call_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<AsmRegister32> for CodeAssembler {
	#[inline]
	fn call(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Call_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<AsmRegister64> for CodeAssembler {
	#[inline]
	fn call(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Call_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<AsmMemoryOperand> for CodeAssembler {
	fn call(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Tbyte {
			Code::Call_m1664
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Call_rm64
		} else if op0.size() == MemoryOperandSize::Fword {
			Code::Call_m1632
		} else if op0.size() == MemoryOperandSize::Dword {
			if self.bitness() >= 32 { Code::Call_rm32 } else { Code::Call_m1616 }
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Call_rm16
		} else {
			return Err(IcedError::new("call: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<CodeLabel> for CodeAssembler {
	fn call(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Call_rel32_64
		} else if self.bitness() >= 32 {
			Code::Call_rel32_32
		} else {
			Code::Call_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCall<u64> for CodeAssembler {
	fn call(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Call_rel32_64
		} else if self.bitness() >= 32 {
			Code::Call_rel32_32
		} else {
			Code::Call_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCbw for CodeAssembler {
	#[inline]
	fn cbw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cbw))
	}
}

#[rustfmt::skip]
impl CodeAsmCcs_encrypt for CodeAssembler {
	fn ccs_encrypt(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Ccs_encrypt_64
		} else if self.bitness() >= 32 {
			Code::Ccs_encrypt_32
		} else {
			Code::Ccs_encrypt_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmCcs_hash for CodeAssembler {
	fn ccs_hash(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Ccs_hash_64
		} else if self.bitness() >= 32 {
			Code::Ccs_hash_32
		} else {
			Code::Ccs_hash_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmCdq for CodeAssembler {
	#[inline]
	fn cdq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cdq))
	}
}

#[rustfmt::skip]
impl CodeAsmCdqe for CodeAssembler {
	#[inline]
	fn cdqe(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cdqe))
	}
}

#[rustfmt::skip]
impl CodeAsmCl1invmb for CodeAssembler {
	#[inline]
	fn cl1invmb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cl1invmb))
	}
}

#[rustfmt::skip]
impl CodeAsmClac for CodeAssembler {
	#[inline]
	fn clac(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clac))
	}
}

#[rustfmt::skip]
impl CodeAsmClc for CodeAssembler {
	#[inline]
	fn clc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clc))
	}
}

#[rustfmt::skip]
impl CodeAsmCld for CodeAssembler {
	#[inline]
	fn cld(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cld))
	}
}

#[rustfmt::skip]
impl CodeAsmCldemote<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cldemote(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Cldemote_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClflush<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn clflush(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Clflush_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClflushopt<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn clflushopt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Clflushopt_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClgi for CodeAssembler {
	#[inline]
	fn clgi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clgi))
	}
}

#[rustfmt::skip]
impl CodeAsmCli for CodeAssembler {
	#[inline]
	fn cli(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cli))
	}
}

#[rustfmt::skip]
impl CodeAsmClrssbsy<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn clrssbsy(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Clrssbsy_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClts for CodeAssembler {
	#[inline]
	fn clts(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clts))
	}
}

#[rustfmt::skip]
impl CodeAsmClui for CodeAssembler {
	#[inline]
	fn clui(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Clui))
	}
}

#[rustfmt::skip]
impl CodeAsmClwb<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn clwb(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Clwb_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmClzero for CodeAssembler {
	fn clzero(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Clzeroq
		} else if self.bitness() >= 32 {
			Code::Clzerod
		} else {
			Code::Clzerow
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmCmc for CodeAssembler {
	#[inline]
	fn cmc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cmc))
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmova<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmova(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovae<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovae(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovb<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovb(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovbe<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovbe(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovc<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovc(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovc<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovc(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovc<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovc(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovc<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovc(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovc<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovc(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovc<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovc(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmove<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmove(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovg<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovg(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovge<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovge(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovl<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovl(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovle<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovle(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovna<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovna(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovna<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovna(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovna<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovna(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovna<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovna(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovna<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovna(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovna<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovna(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovbe_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnae<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnae(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnae<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnae(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnae<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnae(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnae<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnae(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnae<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnae(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnae<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnae(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovb_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnb<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnb(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnb<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnb(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnb<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnb(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnb<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnb(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnb<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnb(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnb<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnb(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnbe<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnbe(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnbe<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnbe(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnbe<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnbe(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnbe<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnbe(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnbe<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnbe(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnbe<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnbe(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmova_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnc<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnc(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnc<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnc(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnc<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnc(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnc<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnc(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnc<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnc(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnc<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnc(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovae_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovne<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovne(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovng<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovng(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovng<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovng(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovng<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovng(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovng<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovng(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovng<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovng(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovng<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovng(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovle_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnge<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnge(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnge<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnge(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnge<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnge(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnge<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnge(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnge<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnge(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnge<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnge(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovl_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnl<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnl(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnl<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnl(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnl<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnl(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnl<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnl(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnl<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnl(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnl<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnl(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovge_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnle<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnle(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnle<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnle(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnle<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnle(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnle<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnle(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnle<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnle(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnle<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnle(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovg_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovno<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovno(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovno_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnp<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnp(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovns<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovns(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovns_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnz<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovnz(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnz<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovnz(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnz<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovnz(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnz<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnz(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnz<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnz(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovnz<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovnz(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovne_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovo<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovo(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovo_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovp<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovp(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpe<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovpe(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpe<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovpe(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpe<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovpe(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpe<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovpe(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpe<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovpe(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpe<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovpe(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovp_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpo<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovpo(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpo<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovpo(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpo<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovpo(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpo<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovpo(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpo<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovpo(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovpo<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovpo(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovnp_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovs<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovs(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmovs_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovz<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmovz(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovz<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmovz(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovz<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmovz(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovz<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovz(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovz<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovz(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmovz<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmovz(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmove_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmp_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Cmp_AL_imm8 } else { Code::Cmp_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister16, i32> for CodeAssembler {
	fn cmp(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Cmp_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Cmp_rm16_imm8
		} else {
			Code::Cmp_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister32, i32> for CodeAssembler {
	fn cmp(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Cmp_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Cmp_rm32_imm8
		} else {
			Code::Cmp_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister64, i32> for CodeAssembler {
	fn cmp(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Cmp_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Cmp_rm64_imm8
		} else {
			Code::Cmp_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmMemoryOperand, i32> for CodeAssembler {
	fn cmp(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Cmp_rm64_imm8 } else { Code::Cmp_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Cmp_rm32_imm8 } else { Code::Cmp_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Cmp_rm16_imm8 } else { Code::Cmp_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Cmp_rm8_imm8
		} else {
			return Err(IcedError::new("cmp: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn cmp(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Cmp_AL_imm8 } else { Code::Cmp_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister16, u32> for CodeAssembler {
	fn cmp(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Cmp_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Cmp_rm16_imm8
		} else {
			Code::Cmp_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmRegister32, u32> for CodeAssembler {
	fn cmp(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Cmp_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Cmp_rm32_imm8
		} else {
			Code::Cmp_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmp<AsmMemoryOperand, u32> for CodeAssembler {
	fn cmp(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Cmp_rm32_imm8 } else { Code::Cmp_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Cmp_rm16_imm8 } else { Code::Cmp_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Cmp_rm8_imm8
		} else {
			return Err(IcedError::new("cmp: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpbexadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpbexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbexadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpbexadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpbexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbexadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpbxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpbxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpbxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpbxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpcxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpcxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpcxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpcxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpeqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpeqpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpeqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpeqps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpeqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpeqsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpeqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpeqss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpeqss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplepd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmplepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplepd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmplepd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpleps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpleps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpleps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpleps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplesd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmplesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplesd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmplesd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpless<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpless<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpless(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplexadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmplexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmplexadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplexadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmplexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmplexadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpltpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpltpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpltps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpltps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpltsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpltsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpltss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpltss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpltss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmplxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmplxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmplxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmplxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmplxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnaexadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnaexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnaexadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnaexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnaxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnaxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbexadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnaxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnaxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpbexadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnbexadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnbexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnbexadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnbexadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnbexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnbexadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnbxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnbxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnbxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnbxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnbxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnbxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpncxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpncxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnbxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpncxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpncxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnbxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpneqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpneqpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpneqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpneqps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpneqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpneqsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpneqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpneqss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpneqss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpngexadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpngexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmplxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpngexadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpngexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmplxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpngxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpngxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmplexadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpngxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpngxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmplexadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlepd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnlepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlepd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnlepd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnleps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnleps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnleps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnleps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlesd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnlesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlesd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnlesd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnless<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnless<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnless(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlexadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnlexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnlexadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlexadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnlexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnlexadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnltpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnltpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnltps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnltps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnltsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnltsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpnltss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnltss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpnltss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnlxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnlxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnlxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnlxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnlxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnoxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnoxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnoxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnoxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnoxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnoxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnpxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnpxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnpxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnpxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnpxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnpxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnsxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnsxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnsxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnsxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnsxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnsxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnzxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpnzxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnzxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpnzxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpnzxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnzxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpordpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpordpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpordps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpordps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpordsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpordsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpordss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpordss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpordss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpoxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpoxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpoxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpoxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpoxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpoxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn cmppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmppd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn cmppd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmppd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn cmppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmppd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn cmppd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmppd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppexadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmppexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmppxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppexadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmppexadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmppxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppoxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmppoxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnpxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppoxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmppoxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpnpxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn cmpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn cmpps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn cmpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn cmpps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmppxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmppxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmppxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmppxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmppxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsb for CodeAssembler {
	#[inline]
	fn cmpsb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_cmpsb(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd for CodeAssembler {
	#[inline]
	fn cmpsd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_cmpsd(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn cmpsd_3(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpsd_xmm_xmmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn cmpsd_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpsd_xmm_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn cmpsd_3(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpsd_xmm_xmmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn cmpsd_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpsd_xmm_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsq for CodeAssembler {
	#[inline]
	fn cmpsq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_cmpsq(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn cmpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpss_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn cmpss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpss_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn cmpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpss_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn cmpss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Cmpss_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsw for CodeAssembler {
	#[inline]
	fn cmpsw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_cmpsw(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpsxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpsxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpsxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpsxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpsxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpunordpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmppd(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpunordpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmppd<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmppd(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpunordps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpps(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpunordps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpps<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpps(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpunordsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpsd_3(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpunordsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpsd3<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpsd_3(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cmpunordss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmRegisterXmm, i32>>::cmpss(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpunordss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpunordss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmCmpss<AsmRegisterXmm, AsmMemoryOperand, i32>>::cmpss(self, op0, op1, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpxchg(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cmpxchg_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg16b<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpxchg16b(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Cmpxchg16b_m128, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpxchg8b<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cmpxchg8b(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Cmpxchg8b_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpzxadd<AsmMemoryOperand, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cmpzxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpzxadd_m32_r32_r32, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCmpzxadd<AsmMemoryOperand, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cmpzxadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Cmpzxadd_m64_r64_r64, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmComisd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn comisd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Comisd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmComisd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn comisd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Comisd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmComiss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn comiss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Comiss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmComiss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn comiss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Comiss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCpu_read for CodeAssembler {
	#[inline]
	fn cpu_read(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cpu_read))
	}
}

#[rustfmt::skip]
impl CodeAsmCpu_write for CodeAssembler {
	#[inline]
	fn cpu_write(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cpu_write))
	}
}

#[rustfmt::skip]
impl CodeAsmCpuid for CodeAssembler {
	#[inline]
	fn cpuid(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cpuid))
	}
}

#[rustfmt::skip]
impl CodeAsmCqo for CodeAssembler {
	#[inline]
	fn cqo(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cqo))
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r32_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r64_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<AsmRegister32, AsmRegister16> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: AsmRegister32, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r32_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn crc32(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Crc32_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	fn crc32(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Dword {
			Code::Crc32_r32_rm32
		} else if op1.size() == MemoryOperandSize::Word {
			Code::Crc32_r32_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Crc32_r32_rm8
		} else {
			return Err(IcedError::new("crc32: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCrc32<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	fn crc32(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Crc32_r64_rm64
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Crc32_r64_rm8
		} else {
			return Err(IcedError::new("crc32: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtdq2pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtdq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtdq2pd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtdq2pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtdq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtdq2pd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtdq2ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtdq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtdq2ps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtdq2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtdq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtdq2ps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2dq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2dq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2pi<AsmRegisterMm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtpd2pi(&mut self, op0: AsmRegisterMm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2pi_mm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2pi<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpd2pi(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2pi_mm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtpd2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2ps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpd2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpd2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpd2ps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpi2pd<AsmRegisterXmm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn cvtpi2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpi2pd_xmm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpi2pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpi2pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpi2pd_xmm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpi2ps<AsmRegisterXmm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn cvtpi2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpi2ps_xmm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtpi2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtpi2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtpi2ps_xmm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtps2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2dq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtps2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2dq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtps2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2pd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtps2pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2pd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2pi<AsmRegisterMm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtps2pi(&mut self, op0: AsmRegisterMm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2pi_mm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtps2pi<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtps2pi(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtps2pi_mm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtsd2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2si_r32_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtsd2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2si_r64_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtsd2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2si_r32_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtsd2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2si_r64_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2ss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtsd2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2ss_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsd2ss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtsd2ss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsd2ss_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2sd<AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cvtsi2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsi2sd_xmm_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2sd<AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cvtsi2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsi2sd_xmm_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2sd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn cvtsi2sd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Cvtsi2sd_xmm_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Cvtsi2sd_xmm_rm32
		} else {
			return Err(IcedError::new("cvtsi2sd: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2ss<AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn cvtsi2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsi2ss_xmm_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2ss<AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn cvtsi2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtsi2ss_xmm_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtsi2ss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn cvtsi2ss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Qword {
			Code::Cvtsi2ss_xmm_rm64
		} else if op1.size() == MemoryOperandSize::Dword {
			Code::Cvtsi2ss_xmm_rm32
		} else {
			return Err(IcedError::new("cvtsi2ss: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2sd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtss2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2sd_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2sd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtss2sd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2sd_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtss2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2si_r32_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvtss2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2si_r64_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtss2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2si_r32_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvtss2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvtss2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvtss2si_r64_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttpd2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttpd2dq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttpd2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttpd2dq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttpd2pi<AsmRegisterMm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttpd2pi(&mut self, op0: AsmRegisterMm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttpd2pi_mm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttpd2pi<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttpd2pi(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttpd2pi_mm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttps2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttps2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttps2dq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttps2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttps2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttps2dq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttps2pi<AsmRegisterMm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttps2pi(&mut self, op0: AsmRegisterMm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttps2pi_mm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttps2pi<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttps2pi(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttps2pi_mm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttsd2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttsd2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttsd2si_r32_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttsd2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttsd2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttsd2si_r64_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttsd2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttsd2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttsd2si_r32_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttsd2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttsd2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttsd2si_r64_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttss2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttss2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttss2si_r32_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttss2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn cvttss2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttss2si_r64_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttss2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttss2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttss2si_r32_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCvttss2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn cvttss2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Cvttss2si_r64_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmCwd for CodeAssembler {
	#[inline]
	fn cwd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cwd))
	}
}

#[rustfmt::skip]
impl CodeAsmCwde for CodeAssembler {
	#[inline]
	fn cwde(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Cwde))
	}
}

#[rustfmt::skip]
impl CodeAsmDaa for CodeAssembler {
	#[inline]
	fn daa(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Daa))
	}
}

#[rustfmt::skip]
impl CodeAsmDas for CodeAssembler {
	#[inline]
	fn das(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Das))
	}
}

#[rustfmt::skip]
impl CodeAsmDec<AsmRegister8> for CodeAssembler {
	#[inline]
	fn dec(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Dec_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDec<AsmRegister16> for CodeAssembler {
	#[inline]
	fn dec(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Dec_rm16 } else { Code::Dec_r16 };
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDec<AsmRegister32> for CodeAssembler {
	#[inline]
	fn dec(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Dec_rm32 } else { Code::Dec_r32 };
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDec<AsmRegister64> for CodeAssembler {
	#[inline]
	fn dec(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Dec_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDec<AsmMemoryOperand> for CodeAssembler {
	fn dec(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Dec_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Dec_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Dec_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Dec_rm8
		} else {
			return Err(IcedError::new("dec: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<AsmRegister8> for CodeAssembler {
	#[inline]
	fn div(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Div_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<AsmRegister16> for CodeAssembler {
	#[inline]
	fn div(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Div_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<AsmRegister32> for CodeAssembler {
	#[inline]
	fn div(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Div_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<AsmRegister64> for CodeAssembler {
	#[inline]
	fn div(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Div_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDiv<AsmMemoryOperand> for CodeAssembler {
	fn div(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Div_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Div_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Div_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Div_rm8
		} else {
			return Err(IcedError::new("div: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn divpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn divpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn divps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn divps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn divsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn divsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn divss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmDivss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn divss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Divss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmDmint for CodeAssembler {
	#[inline]
	fn dmint(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Dmint))
	}
}

#[rustfmt::skip]
impl CodeAsmDppd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn dppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dppd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDppd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn dppd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dppd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDppd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn dppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dppd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDppd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn dppd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dppd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDpps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn dpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dpps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDpps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn dpps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dpps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDpps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn dpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dpps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmDpps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn dpps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Dpps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmEmms for CodeAssembler {
	#[inline]
	fn emms(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Emms))
	}
}

#[rustfmt::skip]
impl CodeAsmEncls for CodeAssembler {
	#[inline]
	fn encls(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Encls))
	}
}

#[rustfmt::skip]
impl CodeAsmEnclu for CodeAssembler {
	#[inline]
	fn enclu(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Enclu))
	}
}

#[rustfmt::skip]
impl CodeAsmEnclv for CodeAssembler {
	#[inline]
	fn enclv(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Enclv))
	}
}

#[rustfmt::skip]
impl CodeAsmEncodekey128<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn encodekey128(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Encodekey128_r32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmEncodekey256<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn encodekey256(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Encodekey256_r32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmEndbr32 for CodeAssembler {
	#[inline]
	fn endbr32(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Endbr32))
	}
}

#[rustfmt::skip]
impl CodeAsmEndbr64 for CodeAssembler {
	#[inline]
	fn endbr64(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Endbr64))
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmd<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmd(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmd_r16_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmd<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmd(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmd_r32_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmd<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmd(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmd_r64_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmds<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmds(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmds_r16_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmds<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmds(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmds_r32_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnqcmds<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn enqcmds(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Enqcmds_r64_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnter<i32, i32> for CodeAssembler {
	fn enter(&mut self, op0: i32, op1: i32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Enterq_imm16_imm8
		} else if self.bitness() >= 32 {
			Code::Enterd_imm16_imm8
		} else {
			Code::Enterw_imm16_imm8
		};
		self.add_instr(Instruction::with2(code, op0, op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmEnter<u32, u32> for CodeAssembler {
	fn enter(&mut self, op0: u32, op1: u32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Enterq_imm16_imm8
		} else if self.bitness() >= 32 {
			Code::Enterd_imm16_imm8
		} else {
			Code::Enterw_imm16_imm8
		};
		self.add_instr(Instruction::with2(code, op0, op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmErets for CodeAssembler {
	#[inline]
	fn erets(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Erets))
	}
}

#[rustfmt::skip]
impl CodeAsmEretu for CodeAssembler {
	#[inline]
	fn eretu(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Eretu))
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<AsmRegister32, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_rm32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<AsmRegister64, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_r64m32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_rm32_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<AsmRegister32, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_rm32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<AsmRegister64, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_r64m32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtractps<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn extractps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extractps_rm32_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtrq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn extrq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Extrq_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtrq3<AsmRegisterXmm, i32, i32> for CodeAssembler {
	#[inline]
	fn extrq_3(&mut self, op0: AsmRegisterXmm, op1: i32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extrq_xmm_imm8_imm8, op0.register(), op1, op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmExtrq3<AsmRegisterXmm, u32, u32> for CodeAssembler {
	#[inline]
	fn extrq_3(&mut self, op0: AsmRegisterXmm, op1: u32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Extrq_xmm_imm8_imm8, op0.register(), op1, op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmF2xm1 for CodeAssembler {
	#[inline]
	fn f2xm1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::F2xm1))
	}
}

#[rustfmt::skip]
impl CodeAsmFabs for CodeAssembler {
	#[inline]
	fn fabs(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fabs))
	}
}

#[rustfmt::skip]
impl CodeAsmFadd<AsmMemoryOperand> for CodeAssembler {
	fn fadd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fadd_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fadd_m32fp
		} else {
			return Err(IcedError::new("fadd: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFadd2<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fadd_2(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fadd_st0_sti } else { Code::Fadd_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFaddp<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn faddp(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Faddp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFbld<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fbld(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fbld_m80bcd, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFbstp<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fbstp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fbstp_m80bcd, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFchs for CodeAssembler {
	#[inline]
	fn fchs(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fchs))
	}
}

#[rustfmt::skip]
impl CodeAsmFclex for CodeAssembler {
	#[inline]
	fn fclex(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fclex))
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovb<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovb(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovb_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovbe<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovbe(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovbe_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmove<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmove(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmove_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovnb<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovnb(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovnb_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovnbe<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovnbe(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovnbe_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovne<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovne(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovne_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovnu<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovnu(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovnu_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcmovu<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcmovu(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcmovu_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcom<AsmMemoryOperand> for CodeAssembler {
	fn fcom(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fcom_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fcom_m32fp
		} else {
			return Err(IcedError::new("fcom: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcom2<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcom_2(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcom_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcomi<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcomi(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcomi_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcomip<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcomip(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcomip_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcomp<AsmMemoryOperand> for CodeAssembler {
	fn fcomp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fcomp_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fcomp_m32fp
		} else {
			return Err(IcedError::new("fcomp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcomp2<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fcomp_2(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fcomp_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFcompp for CodeAssembler {
	#[inline]
	fn fcompp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fcompp))
	}
}

#[rustfmt::skip]
impl CodeAsmFcos for CodeAssembler {
	#[inline]
	fn fcos(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fcos))
	}
}

#[rustfmt::skip]
impl CodeAsmFdecstp for CodeAssembler {
	#[inline]
	fn fdecstp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fdecstp))
	}
}

#[rustfmt::skip]
impl CodeAsmFdisi for CodeAssembler {
	#[inline]
	fn fdisi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fdisi))
	}
}

#[rustfmt::skip]
impl CodeAsmFdiv<AsmMemoryOperand> for CodeAssembler {
	fn fdiv(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fdiv_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fdiv_m32fp
		} else {
			return Err(IcedError::new("fdiv: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdiv2<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fdiv_2(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fdiv_st0_sti } else { Code::Fdiv_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdivp<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fdivp(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fdivp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdivr<AsmMemoryOperand> for CodeAssembler {
	fn fdivr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fdivr_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fdivr_m32fp
		} else {
			return Err(IcedError::new("fdivr: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdivr2<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fdivr_2(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fdivr_st0_sti } else { Code::Fdivr_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFdivrp<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fdivrp(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fdivrp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFemms for CodeAssembler {
	#[inline]
	fn femms(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Femms))
	}
}

#[rustfmt::skip]
impl CodeAsmFeni for CodeAssembler {
	#[inline]
	fn feni(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Feni))
	}
}

#[rustfmt::skip]
impl CodeAsmFfree<AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn ffree(&mut self, op0: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ffree_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFfreep<AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn ffreep(&mut self, op0: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ffreep_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFiadd<AsmMemoryOperand> for CodeAssembler {
	fn fiadd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fiadd_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fiadd_m16int
		} else {
			return Err(IcedError::new("fiadd: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFicom<AsmMemoryOperand> for CodeAssembler {
	fn ficom(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Ficom_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ficom_m16int
		} else {
			return Err(IcedError::new("ficom: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFicomp<AsmMemoryOperand> for CodeAssembler {
	fn ficomp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Ficomp_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ficomp_m16int
		} else {
			return Err(IcedError::new("ficomp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFidiv<AsmMemoryOperand> for CodeAssembler {
	fn fidiv(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fidiv_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fidiv_m16int
		} else {
			return Err(IcedError::new("fidiv: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFidivr<AsmMemoryOperand> for CodeAssembler {
	fn fidivr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fidivr_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fidivr_m16int
		} else {
			return Err(IcedError::new("fidivr: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFild<AsmMemoryOperand> for CodeAssembler {
	fn fild(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fild_m64int
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fild_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fild_m16int
		} else {
			return Err(IcedError::new("fild: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFimul<AsmMemoryOperand> for CodeAssembler {
	fn fimul(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fimul_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fimul_m16int
		} else {
			return Err(IcedError::new("fimul: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFincstp for CodeAssembler {
	#[inline]
	fn fincstp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fincstp))
	}
}

#[rustfmt::skip]
impl CodeAsmFinit for CodeAssembler {
	#[inline]
	fn finit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Finit))
	}
}

#[rustfmt::skip]
impl CodeAsmFist<AsmMemoryOperand> for CodeAssembler {
	fn fist(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fist_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fist_m16int
		} else {
			return Err(IcedError::new("fist: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFistp<AsmMemoryOperand> for CodeAssembler {
	fn fistp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fistp_m64int
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fistp_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fistp_m16int
		} else {
			return Err(IcedError::new("fistp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFisttp<AsmMemoryOperand> for CodeAssembler {
	fn fisttp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fisttp_m64int
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fisttp_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fisttp_m16int
		} else {
			return Err(IcedError::new("fisttp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFisub<AsmMemoryOperand> for CodeAssembler {
	fn fisub(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fisub_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fisub_m16int
		} else {
			return Err(IcedError::new("fisub: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFisubr<AsmMemoryOperand> for CodeAssembler {
	fn fisubr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Fisubr_m32int
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Fisubr_m16int
		} else {
			return Err(IcedError::new("fisubr: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFld<AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fld(&mut self, op0: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fld_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFld<AsmMemoryOperand> for CodeAssembler {
	fn fld(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Tbyte {
			Code::Fld_m80fp
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Fld_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fld_m32fp
		} else {
			return Err(IcedError::new("fld: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFld1 for CodeAssembler {
	#[inline]
	fn fld1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fld1))
	}
}

#[rustfmt::skip]
impl CodeAsmFldcw<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fldcw(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fldcw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFldenv<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fldenv(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fldenv_m28byte } else { Code::Fldenv_m14byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFldl2e for CodeAssembler {
	#[inline]
	fn fldl2e(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldl2e))
	}
}

#[rustfmt::skip]
impl CodeAsmFldl2t for CodeAssembler {
	#[inline]
	fn fldl2t(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldl2t))
	}
}

#[rustfmt::skip]
impl CodeAsmFldlg2 for CodeAssembler {
	#[inline]
	fn fldlg2(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldlg2))
	}
}

#[rustfmt::skip]
impl CodeAsmFldln2 for CodeAssembler {
	#[inline]
	fn fldln2(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldln2))
	}
}

#[rustfmt::skip]
impl CodeAsmFldpi for CodeAssembler {
	#[inline]
	fn fldpi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldpi))
	}
}

#[rustfmt::skip]
impl CodeAsmFldz for CodeAssembler {
	#[inline]
	fn fldz(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fldz))
	}
}

#[rustfmt::skip]
impl CodeAsmFmul<AsmMemoryOperand> for CodeAssembler {
	fn fmul(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fmul_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fmul_m32fp
		} else {
			return Err(IcedError::new("fmul: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFmul2<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fmul_2(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fmul_st0_sti } else { Code::Fmul_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFmulp<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fmulp(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fmulp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnclex for CodeAssembler {
	#[inline]
	fn fnclex(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fnclex))
	}
}

#[rustfmt::skip]
impl CodeAsmFndisi for CodeAssembler {
	#[inline]
	fn fndisi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fndisi))
	}
}

#[rustfmt::skip]
impl CodeAsmFneni for CodeAssembler {
	#[inline]
	fn fneni(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fneni))
	}
}

#[rustfmt::skip]
impl CodeAsmFninit for CodeAssembler {
	#[inline]
	fn fninit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fninit))
	}
}

#[rustfmt::skip]
impl CodeAsmFnop for CodeAssembler {
	#[inline]
	fn fnop(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fnop))
	}
}

#[rustfmt::skip]
impl CodeAsmFnsave<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fnsave(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fnsave_m108byte } else { Code::Fnsave_m94byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnsetpm for CodeAssembler {
	#[inline]
	fn fnsetpm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fnsetpm))
	}
}

#[rustfmt::skip]
impl CodeAsmFnstcw<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fnstcw(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstcw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstdw<AsmRegister16> for CodeAssembler {
	#[inline]
	fn fnstdw(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstdw_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstenv<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fnstenv(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fnstenv_m28byte } else { Code::Fnstenv_m14byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstsg<AsmRegister16> for CodeAssembler {
	#[inline]
	fn fnstsg(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstsg_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstsw<AsmRegister16> for CodeAssembler {
	#[inline]
	fn fnstsw(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstsw_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFnstsw<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fnstsw(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fnstsw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFpatan for CodeAssembler {
	#[inline]
	fn fpatan(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fpatan))
	}
}

#[rustfmt::skip]
impl CodeAsmFprem for CodeAssembler {
	#[inline]
	fn fprem(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fprem))
	}
}

#[rustfmt::skip]
impl CodeAsmFprem1 for CodeAssembler {
	#[inline]
	fn fprem1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fprem1))
	}
}

#[rustfmt::skip]
impl CodeAsmFptan for CodeAssembler {
	#[inline]
	fn fptan(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fptan))
	}
}

#[rustfmt::skip]
impl CodeAsmFrndint for CodeAssembler {
	#[inline]
	fn frndint(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Frndint))
	}
}

#[rustfmt::skip]
impl CodeAsmFrstor<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn frstor(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Frstor_m108byte } else { Code::Frstor_m94byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFrstpm for CodeAssembler {
	#[inline]
	fn frstpm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Frstpm))
	}
}

#[rustfmt::skip]
impl CodeAsmFsave<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fsave(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fsave_m108byte } else { Code::Fsave_m94byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFscale for CodeAssembler {
	#[inline]
	fn fscale(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fscale))
	}
}

#[rustfmt::skip]
impl CodeAsmFsetpm for CodeAssembler {
	#[inline]
	fn fsetpm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fsetpm))
	}
}

#[rustfmt::skip]
impl CodeAsmFsin for CodeAssembler {
	#[inline]
	fn fsin(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fsin))
	}
}

#[rustfmt::skip]
impl CodeAsmFsincos for CodeAssembler {
	#[inline]
	fn fsincos(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fsincos))
	}
}

#[rustfmt::skip]
impl CodeAsmFsqrt for CodeAssembler {
	#[inline]
	fn fsqrt(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fsqrt))
	}
}

#[rustfmt::skip]
impl CodeAsmFst<AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fst(&mut self, op0: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fst_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFst<AsmMemoryOperand> for CodeAssembler {
	fn fst(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fst_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fst_m32fp
		} else {
			return Err(IcedError::new("fst: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstcw<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fstcw(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstcw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstdw<AsmRegister16> for CodeAssembler {
	#[inline]
	fn fstdw(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstdw_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstenv<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fstenv(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Fstenv_m28byte } else { Code::Fstenv_m14byte };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstp<AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fstp(&mut self, op0: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstp_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstp<AsmMemoryOperand> for CodeAssembler {
	fn fstp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Tbyte {
			Code::Fstp_m80fp
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Fstp_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fstp_m32fp
		} else {
			return Err(IcedError::new("fstp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstpnce<AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fstpnce(&mut self, op0: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstpnce_sti, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstsg<AsmRegister16> for CodeAssembler {
	#[inline]
	fn fstsg(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstsg_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstsw<AsmRegister16> for CodeAssembler {
	#[inline]
	fn fstsw(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstsw_AX, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFstsw<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fstsw(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fstsw_m2byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsub<AsmMemoryOperand> for CodeAssembler {
	fn fsub(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fsub_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fsub_m32fp
		} else {
			return Err(IcedError::new("fsub: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsub2<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fsub_2(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fsub_st0_sti } else { Code::Fsub_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsubp<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fsubp(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fsubp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsubr<AsmMemoryOperand> for CodeAssembler {
	fn fsubr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Fsubr_m64fp
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Fsubr_m32fp
		} else {
			return Err(IcedError::new("fsubr: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsubr2<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fsubr_2(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		let code = if op0.register() == Register::ST0 { Code::Fsubr_st0_sti } else { Code::Fsubr_sti_st0 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFsubrp<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fsubrp(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fsubrp_sti_st0, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFtst for CodeAssembler {
	#[inline]
	fn ftst(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Ftst))
	}
}

#[rustfmt::skip]
impl CodeAsmFucom<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fucom(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fucom_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFucomi<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fucomi(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fucomi_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFucomip<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fucomip(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fucomip_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFucomp<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fucomp(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fucomp_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFucompp for CodeAssembler {
	#[inline]
	fn fucompp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fucompp))
	}
}

#[rustfmt::skip]
impl CodeAsmFxam for CodeAssembler {
	#[inline]
	fn fxam(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fxam))
	}
}

#[rustfmt::skip]
impl CodeAsmFxch<AsmRegisterSt, AsmRegisterSt> for CodeAssembler {
	#[inline]
	fn fxch(&mut self, op0: AsmRegisterSt, op1: AsmRegisterSt) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Fxch_st0_sti, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxrstor<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fxrstor(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fxrstor_m512byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxrstor64<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fxrstor64(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fxrstor64_m512byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxsave<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fxsave(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fxsave_m512byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxsave64<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn fxsave64(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Fxsave64_m512byte, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmFxtract for CodeAssembler {
	#[inline]
	fn fxtract(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fxtract))
	}
}

#[rustfmt::skip]
impl CodeAsmFyl2x for CodeAssembler {
	#[inline]
	fn fyl2x(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fyl2x))
	}
}

#[rustfmt::skip]
impl CodeAsmFyl2xp1 for CodeAssembler {
	#[inline]
	fn fyl2xp1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Fyl2xp1))
	}
}

#[rustfmt::skip]
impl CodeAsmGetsec for CodeAssembler {
	#[inline]
	fn getsec(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Getsecd))
	}
}

#[rustfmt::skip]
impl CodeAsmGetsecq for CodeAssembler {
	#[inline]
	fn getsecq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Getsecq))
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineinvqb<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn gf2p8affineinvqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineinvqb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineinvqb<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn gf2p8affineinvqb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineinvqb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineinvqb<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn gf2p8affineinvqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineinvqb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineinvqb<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn gf2p8affineinvqb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineinvqb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineqb<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn gf2p8affineqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineqb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineqb<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn gf2p8affineqb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineqb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineqb<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn gf2p8affineqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineqb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8affineqb<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn gf2p8affineqb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Gf2p8affineqb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8mulb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn gf2p8mulb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Gf2p8mulb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmGf2p8mulb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn gf2p8mulb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Gf2p8mulb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmHaddpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn haddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Haddpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmHaddpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn haddpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Haddpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmHaddps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn haddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Haddps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmHaddps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn haddps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Haddps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmHlt for CodeAssembler {
	#[inline]
	fn hlt(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Hlt))
	}
}

#[rustfmt::skip]
impl CodeAsmHreset<i32> for CodeAssembler {
	#[inline]
	fn hreset(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Hreset_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmHreset<u32> for CodeAssembler {
	#[inline]
	fn hreset(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Hreset_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmHsubpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn hsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Hsubpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmHsubpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn hsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Hsubpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmHsubps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn hsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Hsubps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmHsubps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn hsubps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Hsubps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmIbts<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn ibts(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ibts_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIbts<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn ibts(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ibts_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIbts<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn ibts(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ibts_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIbts<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn ibts(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ibts_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<AsmRegister8> for CodeAssembler {
	#[inline]
	fn idiv(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Idiv_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<AsmRegister16> for CodeAssembler {
	#[inline]
	fn idiv(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Idiv_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<AsmRegister32> for CodeAssembler {
	#[inline]
	fn idiv(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Idiv_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<AsmRegister64> for CodeAssembler {
	#[inline]
	fn idiv(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Idiv_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIdiv<AsmMemoryOperand> for CodeAssembler {
	fn idiv(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Idiv_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Idiv_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Idiv_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Idiv_rm8
		} else {
			return Err(IcedError::new("idiv: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<AsmRegister8> for CodeAssembler {
	#[inline]
	fn imul(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Imul_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<AsmRegister16> for CodeAssembler {
	#[inline]
	fn imul(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Imul_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<AsmRegister32> for CodeAssembler {
	#[inline]
	fn imul(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Imul_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<AsmRegister64> for CodeAssembler {
	#[inline]
	fn imul(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Imul_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul<AsmMemoryOperand> for CodeAssembler {
	fn imul(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Imul_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Imul_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Imul_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Imul_rm8
		} else {
			return Err(IcedError::new("imul: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul2<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn imul_2(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Imul_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister16, AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister16, op1: AsmRegister16, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r16_rm16_imm8 } else { Code::Imul_r16_rm16_imm16 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister32, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r32_rm32_imm8 } else { Code::Imul_r32_rm32_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister64, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r64_rm64_imm8 } else { Code::Imul_r64_rm64_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister16, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r16_rm16_imm8 } else { Code::Imul_r16_rm16_imm16 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister32, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r32_rm32_imm8 } else { Code::Imul_r32_rm32_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister64, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op2 >= i8::MIN as i32 && op2 <= i8::MAX as i32 { Code::Imul_r64_rm64_imm8 } else { Code::Imul_r64_rm64_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister16, AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister16, op1: AsmRegister16, op2: u32) -> Result<(), IcedError> {
		let code = if op2 <= i8::MAX as u32 || (0xFF80 <= op2 && op2 <= 0xFFFF) { Code::Imul_r16_rm16_imm8 } else { Code::Imul_r16_rm16_imm16 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister32, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		let code = if op2 <= i8::MAX as u32 || 0xFFFF_FF80 <= op2 { Code::Imul_r32_rm32_imm8 } else { Code::Imul_r32_rm32_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister16, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op2 <= i8::MAX as u32 || (0xFF80 <= op2 && op2 <= 0xFFFF) { Code::Imul_r16_rm16_imm8 } else { Code::Imul_r16_rm16_imm16 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmImul3<AsmRegister32, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn imul_3(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op2 <= i8::MAX as u32 || 0xFFFF_FF80 <= op2 { Code::Imul_r32_rm32_imm8 } else { Code::Imul_r32_rm32_imm32 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<AsmRegister8, AsmRegister16> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: AsmRegister8, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AL_DX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AX_DX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<AsmRegister32, AsmRegister16> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: AsmRegister32, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_EAX_DX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AL_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AX_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_EAX_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AL_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_AX_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmIn<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn in_(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::In_EAX_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<AsmRegister8> for CodeAssembler {
	#[inline]
	fn inc(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Inc_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<AsmRegister16> for CodeAssembler {
	#[inline]
	fn inc(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Inc_rm16 } else { Code::Inc_r16 };
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<AsmRegister32> for CodeAssembler {
	#[inline]
	fn inc(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 { Code::Inc_rm32 } else { Code::Inc_r32 };
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<AsmRegister64> for CodeAssembler {
	#[inline]
	fn inc(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Inc_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInc<AsmMemoryOperand> for CodeAssembler {
	fn inc(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Inc_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Inc_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Inc_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Inc_rm8
		} else {
			return Err(IcedError::new("inc: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmIncsspd<AsmRegister32> for CodeAssembler {
	#[inline]
	fn incsspd(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Incsspd_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmIncsspq<AsmRegister64> for CodeAssembler {
	#[inline]
	fn incsspq(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Incsspq_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsb for CodeAssembler {
	#[inline]
	fn insb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_insb(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsd for CodeAssembler {
	#[inline]
	fn insd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_insd(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn insertps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Insertps_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn insertps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Insertps_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn insertps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Insertps_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn insertps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Insertps_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn insertq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Insertq_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertq4<AsmRegisterXmm, AsmRegisterXmm, i32, i32> for CodeAssembler {
	#[inline]
	fn insertq_4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::Insertq_xmm_xmm_imm8_imm8, op0.register(), op1.register(), op2, op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsertq4<AsmRegisterXmm, AsmRegisterXmm, u32, u32> for CodeAssembler {
	#[inline]
	fn insertq_4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::Insertq_xmm_xmm_imm8_imm8, op0.register(), op1.register(), op2, op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInsw for CodeAssembler {
	#[inline]
	fn insw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_insw(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInt<i32> for CodeAssembler {
	#[inline]
	fn int(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Int_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInt<u32> for CodeAssembler {
	#[inline]
	fn int(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Int_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmInt1 for CodeAssembler {
	#[inline]
	fn int1(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Int1))
	}
}

#[rustfmt::skip]
impl CodeAsmInt3 for CodeAssembler {
	#[inline]
	fn int3(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Int3))
	}
}

#[rustfmt::skip]
impl CodeAsmInto for CodeAssembler {
	#[inline]
	fn into(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Into))
	}
}

#[rustfmt::skip]
impl CodeAsmInvd for CodeAssembler {
	#[inline]
	fn invd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Invd))
	}
}

#[rustfmt::skip]
impl CodeAsmInvept<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invept(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invept_r32_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvept<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invept(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invept_r64_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvlpg<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invlpg(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Invlpg_m, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvlpga for CodeAssembler {
	fn invlpga(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Invlpgaq
		} else if self.bitness() >= 32 {
			Code::Invlpgad
		} else {
			Code::Invlpgaw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmInvlpgb for CodeAssembler {
	fn invlpgb(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Invlpgbq
		} else if self.bitness() >= 32 {
			Code::Invlpgbd
		} else {
			Code::Invlpgbw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmInvpcid<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invpcid(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invpcid_r32_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvpcid<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invpcid(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invpcid_r64_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvvpid<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invvpid(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invvpid_r32_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmInvvpid<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn invvpid(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Invvpid_r64_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmIret for CodeAssembler {
	#[inline]
	fn iret(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Iretw))
	}
}

#[rustfmt::skip]
impl CodeAsmIretd for CodeAssembler {
	#[inline]
	fn iretd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Iretd))
	}
}

#[rustfmt::skip]
impl CodeAsmIretq for CodeAssembler {
	#[inline]
	fn iretq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Iretq))
	}
}

#[rustfmt::skip]
impl CodeAsmJa<CodeLabel> for CodeAssembler {
	fn ja(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Ja_rel8_64
			} else if self.bitness() >= 32 {
				Code::Ja_rel8_32
			} else {
				Code::Ja_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Ja_rel32_64
		} else if self.bitness() >= 32 {
			Code::Ja_rel32_32
		} else {
			Code::Ja_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJa<u64> for CodeAssembler {
	fn ja(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Ja_rel8_64
			} else if self.bitness() >= 32 {
				Code::Ja_rel8_32
			} else {
				Code::Ja_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Ja_rel32_64
		} else if self.bitness() >= 32 {
			Code::Ja_rel32_32
		} else {
			Code::Ja_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJae<CodeLabel> for CodeAssembler {
	fn jae(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jae_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jae_rel8_32
			} else {
				Code::Jae_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jae_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jae_rel32_32
		} else {
			Code::Jae_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJae<u64> for CodeAssembler {
	fn jae(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jae_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jae_rel8_32
			} else {
				Code::Jae_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jae_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jae_rel32_32
		} else {
			Code::Jae_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJb<CodeLabel> for CodeAssembler {
	fn jb(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jb_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jb_rel8_32
			} else {
				Code::Jb_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jb_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jb_rel32_32
		} else {
			Code::Jb_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJb<u64> for CodeAssembler {
	fn jb(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jb_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jb_rel8_32
			} else {
				Code::Jb_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jb_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jb_rel32_32
		} else {
			Code::Jb_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJbe<CodeLabel> for CodeAssembler {
	fn jbe(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jbe_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jbe_rel8_32
			} else {
				Code::Jbe_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jbe_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jbe_rel32_32
		} else {
			Code::Jbe_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJbe<u64> for CodeAssembler {
	fn jbe(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jbe_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jbe_rel8_32
			} else {
				Code::Jbe_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jbe_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jbe_rel32_32
		} else {
			Code::Jbe_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJc<CodeLabel> for CodeAssembler {
	fn jc(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jb_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jb_rel8_32
			} else {
				Code::Jb_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jb_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jb_rel32_32
		} else {
			Code::Jb_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJc<u64> for CodeAssembler {
	fn jc(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jb_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jb_rel8_32
			} else {
				Code::Jb_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jb_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jb_rel32_32
		} else {
			Code::Jb_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJcxz<CodeLabel> for CodeAssembler {
	#[inline]
	fn jcxz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jcxz_rel8_16, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJcxz<u64> for CodeAssembler {
	#[inline]
	fn jcxz(&mut self, op0: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jcxz_rel8_16, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJe<CodeLabel> for CodeAssembler {
	fn je(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Je_rel8_64
			} else if self.bitness() >= 32 {
				Code::Je_rel8_32
			} else {
				Code::Je_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Je_rel32_64
		} else if self.bitness() >= 32 {
			Code::Je_rel32_32
		} else {
			Code::Je_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJe<u64> for CodeAssembler {
	fn je(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Je_rel8_64
			} else if self.bitness() >= 32 {
				Code::Je_rel8_32
			} else {
				Code::Je_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Je_rel32_64
		} else if self.bitness() >= 32 {
			Code::Je_rel32_32
		} else {
			Code::Je_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJecxz<CodeLabel> for CodeAssembler {
	#[inline]
	fn jecxz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jecxz_rel8_32, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJecxz<u64> for CodeAssembler {
	#[inline]
	fn jecxz(&mut self, op0: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jecxz_rel8_32, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJg<CodeLabel> for CodeAssembler {
	fn jg(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jg_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jg_rel8_32
			} else {
				Code::Jg_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jg_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jg_rel32_32
		} else {
			Code::Jg_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJg<u64> for CodeAssembler {
	fn jg(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jg_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jg_rel8_32
			} else {
				Code::Jg_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jg_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jg_rel32_32
		} else {
			Code::Jg_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJge<CodeLabel> for CodeAssembler {
	fn jge(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jge_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jge_rel8_32
			} else {
				Code::Jge_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jge_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jge_rel32_32
		} else {
			Code::Jge_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJge<u64> for CodeAssembler {
	fn jge(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jge_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jge_rel8_32
			} else {
				Code::Jge_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jge_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jge_rel32_32
		} else {
			Code::Jge_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJl<CodeLabel> for CodeAssembler {
	fn jl(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jl_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jl_rel8_32
			} else {
				Code::Jl_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jl_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jl_rel32_32
		} else {
			Code::Jl_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJl<u64> for CodeAssembler {
	fn jl(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jl_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jl_rel8_32
			} else {
				Code::Jl_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jl_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jl_rel32_32
		} else {
			Code::Jl_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJle<CodeLabel> for CodeAssembler {
	fn jle(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jle_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jle_rel8_32
			} else {
				Code::Jle_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jle_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jle_rel32_32
		} else {
			Code::Jle_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJle<u64> for CodeAssembler {
	fn jle(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jle_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jle_rel8_32
			} else {
				Code::Jle_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jle_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jle_rel32_32
		} else {
			Code::Jle_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<AsmRegister16> for CodeAssembler {
	#[inline]
	fn jmp(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmp_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<AsmRegister32> for CodeAssembler {
	#[inline]
	fn jmp(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmp_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<AsmRegister64> for CodeAssembler {
	#[inline]
	fn jmp(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmp_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<AsmMemoryOperand> for CodeAssembler {
	fn jmp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Tbyte {
			Code::Jmp_m1664
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Jmp_rm64
		} else if op0.size() == MemoryOperandSize::Fword {
			Code::Jmp_m1632
		} else if op0.size() == MemoryOperandSize::Dword {
			if self.bitness() >= 32 { Code::Jmp_rm32 } else { Code::Jmp_m1616 }
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Jmp_rm16
		} else {
			return Err(IcedError::new("jmp: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<CodeLabel> for CodeAssembler {
	fn jmp(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jmp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jmp_rel8_32
			} else {
				Code::Jmp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jmp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jmp_rel32_32
		} else {
			Code::Jmp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmp<u64> for CodeAssembler {
	fn jmp(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jmp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jmp_rel8_32
			} else {
				Code::Jmp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jmp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jmp_rel32_32
		} else {
			Code::Jmp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<AsmRegister16> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmpe_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<AsmRegister32> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Jmpe_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Jmpe_rm32 } else { Code::Jmpe_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<CodeLabel> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Jmpe_disp32 } else { Code::Jmpe_disp16 };
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJmpe<u64> for CodeAssembler {
	#[inline]
	fn jmpe(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Jmpe_disp32 } else { Code::Jmpe_disp16 };
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJna<CodeLabel> for CodeAssembler {
	fn jna(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jbe_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jbe_rel8_32
			} else {
				Code::Jbe_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jbe_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jbe_rel32_32
		} else {
			Code::Jbe_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJna<u64> for CodeAssembler {
	fn jna(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jbe_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jbe_rel8_32
			} else {
				Code::Jbe_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jbe_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jbe_rel32_32
		} else {
			Code::Jbe_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnae<CodeLabel> for CodeAssembler {
	fn jnae(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jb_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jb_rel8_32
			} else {
				Code::Jb_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jb_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jb_rel32_32
		} else {
			Code::Jb_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnae<u64> for CodeAssembler {
	fn jnae(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jb_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jb_rel8_32
			} else {
				Code::Jb_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jb_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jb_rel32_32
		} else {
			Code::Jb_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnb<CodeLabel> for CodeAssembler {
	fn jnb(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jae_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jae_rel8_32
			} else {
				Code::Jae_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jae_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jae_rel32_32
		} else {
			Code::Jae_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnb<u64> for CodeAssembler {
	fn jnb(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jae_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jae_rel8_32
			} else {
				Code::Jae_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jae_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jae_rel32_32
		} else {
			Code::Jae_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnbe<CodeLabel> for CodeAssembler {
	fn jnbe(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Ja_rel8_64
			} else if self.bitness() >= 32 {
				Code::Ja_rel8_32
			} else {
				Code::Ja_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Ja_rel32_64
		} else if self.bitness() >= 32 {
			Code::Ja_rel32_32
		} else {
			Code::Ja_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnbe<u64> for CodeAssembler {
	fn jnbe(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Ja_rel8_64
			} else if self.bitness() >= 32 {
				Code::Ja_rel8_32
			} else {
				Code::Ja_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Ja_rel32_64
		} else if self.bitness() >= 32 {
			Code::Ja_rel32_32
		} else {
			Code::Ja_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnc<CodeLabel> for CodeAssembler {
	fn jnc(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jae_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jae_rel8_32
			} else {
				Code::Jae_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jae_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jae_rel32_32
		} else {
			Code::Jae_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnc<u64> for CodeAssembler {
	fn jnc(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jae_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jae_rel8_32
			} else {
				Code::Jae_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jae_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jae_rel32_32
		} else {
			Code::Jae_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJne<CodeLabel> for CodeAssembler {
	fn jne(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jne_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jne_rel8_32
			} else {
				Code::Jne_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jne_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jne_rel32_32
		} else {
			Code::Jne_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJne<u64> for CodeAssembler {
	fn jne(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jne_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jne_rel8_32
			} else {
				Code::Jne_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jne_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jne_rel32_32
		} else {
			Code::Jne_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJng<CodeLabel> for CodeAssembler {
	fn jng(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jle_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jle_rel8_32
			} else {
				Code::Jle_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jle_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jle_rel32_32
		} else {
			Code::Jle_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJng<u64> for CodeAssembler {
	fn jng(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jle_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jle_rel8_32
			} else {
				Code::Jle_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jle_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jle_rel32_32
		} else {
			Code::Jle_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnge<CodeLabel> for CodeAssembler {
	fn jnge(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jl_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jl_rel8_32
			} else {
				Code::Jl_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jl_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jl_rel32_32
		} else {
			Code::Jl_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnge<u64> for CodeAssembler {
	fn jnge(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jl_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jl_rel8_32
			} else {
				Code::Jl_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jl_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jl_rel32_32
		} else {
			Code::Jl_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnl<CodeLabel> for CodeAssembler {
	fn jnl(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jge_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jge_rel8_32
			} else {
				Code::Jge_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jge_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jge_rel32_32
		} else {
			Code::Jge_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnl<u64> for CodeAssembler {
	fn jnl(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jge_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jge_rel8_32
			} else {
				Code::Jge_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jge_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jge_rel32_32
		} else {
			Code::Jge_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnle<CodeLabel> for CodeAssembler {
	fn jnle(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jg_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jg_rel8_32
			} else {
				Code::Jg_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jg_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jg_rel32_32
		} else {
			Code::Jg_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnle<u64> for CodeAssembler {
	fn jnle(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jg_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jg_rel8_32
			} else {
				Code::Jg_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jg_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jg_rel32_32
		} else {
			Code::Jg_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJno<CodeLabel> for CodeAssembler {
	fn jno(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jno_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jno_rel8_32
			} else {
				Code::Jno_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jno_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jno_rel32_32
		} else {
			Code::Jno_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJno<u64> for CodeAssembler {
	fn jno(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jno_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jno_rel8_32
			} else {
				Code::Jno_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jno_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jno_rel32_32
		} else {
			Code::Jno_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnp<CodeLabel> for CodeAssembler {
	fn jnp(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jnp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jnp_rel8_32
			} else {
				Code::Jnp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jnp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jnp_rel32_32
		} else {
			Code::Jnp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnp<u64> for CodeAssembler {
	fn jnp(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jnp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jnp_rel8_32
			} else {
				Code::Jnp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jnp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jnp_rel32_32
		} else {
			Code::Jnp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJns<CodeLabel> for CodeAssembler {
	fn jns(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jns_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jns_rel8_32
			} else {
				Code::Jns_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jns_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jns_rel32_32
		} else {
			Code::Jns_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJns<u64> for CodeAssembler {
	fn jns(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jns_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jns_rel8_32
			} else {
				Code::Jns_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jns_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jns_rel32_32
		} else {
			Code::Jns_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnz<CodeLabel> for CodeAssembler {
	fn jnz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jne_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jne_rel8_32
			} else {
				Code::Jne_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jne_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jne_rel32_32
		} else {
			Code::Jne_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJnz<u64> for CodeAssembler {
	fn jnz(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jne_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jne_rel8_32
			} else {
				Code::Jne_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jne_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jne_rel32_32
		} else {
			Code::Jne_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJo<CodeLabel> for CodeAssembler {
	fn jo(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jo_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jo_rel8_32
			} else {
				Code::Jo_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jo_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jo_rel32_32
		} else {
			Code::Jo_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJo<u64> for CodeAssembler {
	fn jo(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jo_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jo_rel8_32
			} else {
				Code::Jo_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jo_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jo_rel32_32
		} else {
			Code::Jo_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJp<CodeLabel> for CodeAssembler {
	fn jp(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jp_rel8_32
			} else {
				Code::Jp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jp_rel32_32
		} else {
			Code::Jp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJp<u64> for CodeAssembler {
	fn jp(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jp_rel8_32
			} else {
				Code::Jp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jp_rel32_32
		} else {
			Code::Jp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJpe<CodeLabel> for CodeAssembler {
	fn jpe(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jp_rel8_32
			} else {
				Code::Jp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jp_rel32_32
		} else {
			Code::Jp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJpe<u64> for CodeAssembler {
	fn jpe(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jp_rel8_32
			} else {
				Code::Jp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jp_rel32_32
		} else {
			Code::Jp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJpo<CodeLabel> for CodeAssembler {
	fn jpo(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jnp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jnp_rel8_32
			} else {
				Code::Jnp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jnp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jnp_rel32_32
		} else {
			Code::Jnp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJpo<u64> for CodeAssembler {
	fn jpo(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Jnp_rel8_64
			} else if self.bitness() >= 32 {
				Code::Jnp_rel8_32
			} else {
				Code::Jnp_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Jnp_rel32_64
		} else if self.bitness() >= 32 {
			Code::Jnp_rel32_32
		} else {
			Code::Jnp_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJrcxz<CodeLabel> for CodeAssembler {
	#[inline]
	fn jrcxz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jrcxz_rel8_64, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJrcxz<u64> for CodeAssembler {
	#[inline]
	fn jrcxz(&mut self, op0: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_branch(Code::Jrcxz_rel8_64, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJs<CodeLabel> for CodeAssembler {
	fn js(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Js_rel8_64
			} else if self.bitness() >= 32 {
				Code::Js_rel8_32
			} else {
				Code::Js_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Js_rel32_64
		} else if self.bitness() >= 32 {
			Code::Js_rel32_32
		} else {
			Code::Js_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJs<u64> for CodeAssembler {
	fn js(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Js_rel8_64
			} else if self.bitness() >= 32 {
				Code::Js_rel8_32
			} else {
				Code::Js_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Js_rel32_64
		} else if self.bitness() >= 32 {
			Code::Js_rel32_32
		} else {
			Code::Js_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmJz<CodeLabel> for CodeAssembler {
	fn jz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Je_rel8_64
			} else if self.bitness() >= 32 {
				Code::Je_rel8_32
			} else {
				Code::Je_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Je_rel32_64
		} else if self.bitness() >= 32 {
			Code::Je_rel32_32
		} else {
			Code::Je_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmJz<u64> for CodeAssembler {
	fn jz(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.prefer_short_branch() {
			if self.bitness() == 64 {
				Code::Je_rel8_64
			} else if self.bitness() >= 32 {
				Code::Je_rel8_32
			} else {
				Code::Je_rel8_16
			}
		} else if self.bitness() == 64 {
			Code::Je_rel32_64
		} else if self.bitness() >= 32 {
			Code::Je_rel32_32
		} else {
			Code::Je_rel16
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKaddb<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kaddb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kaddb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKaddd<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kaddd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kaddd_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKaddq<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kaddq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kaddq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKaddw<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kaddw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kaddw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandb<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandd<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandd_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandnb<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandnb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandnb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandnd<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandnd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandnd_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandnq<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandnq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandnq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandnw<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandnw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandnw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandq<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKandw<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kandw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kandw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<AsmRegisterK, AsmRegister32> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: AsmRegisterK, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_kr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<AsmRegister32, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: AsmRegister32, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_r32_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_kr_km8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<AsmMemoryOperand, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_m8_kr, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovb<AsmRegisterK, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn kmovb(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovb_kr_km8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<AsmRegisterK, AsmRegister32> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: AsmRegisterK, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_kr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<AsmRegister32, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: AsmRegister32, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_r32_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_kr_km32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<AsmMemoryOperand, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_m32_kr, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovd<AsmRegisterK, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn kmovd(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovd_kr_km32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<AsmRegisterK, AsmRegister64> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: AsmRegisterK, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_kr_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<AsmRegister64, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: AsmRegister64, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_r64_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_kr_km64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<AsmMemoryOperand, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_m64_kr, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovq<AsmRegisterK, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn kmovq(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovq_kr_km64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<AsmRegisterK, AsmRegister32> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: AsmRegisterK, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_kr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<AsmRegister32, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: AsmRegister32, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_r32_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_kr_km16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<AsmMemoryOperand, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_m16_kr, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKmovw<AsmRegisterK, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn kmovw(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kmovw_kr_km16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmKnotb<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn knotb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Knotb_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKnotd<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn knotd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Knotd_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKnotq<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn knotq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Knotq_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKnotw<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn knotw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Knotw_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKorb<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn korb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Korb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKord<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kord(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kord_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKorq<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn korq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Korq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKortestb<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kortestb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kortestb_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKortestd<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kortestd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kortestd_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKortestq<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kortestq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kortestq_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKortestw<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kortestw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Kortestw_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKorw<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn korw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Korw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlb<AsmRegisterK, AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftlb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlb_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlb<AsmRegisterK, AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftlb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlb_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftld<AsmRegisterK, AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftld(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftld_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftld<AsmRegisterK, AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftld(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftld_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlq<AsmRegisterK, AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftlq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlq_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlq<AsmRegisterK, AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftlq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlq_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlw<AsmRegisterK, AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftlw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlw_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftlw<AsmRegisterK, AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftlw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftlw_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrb<AsmRegisterK, AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftrb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrb_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrb<AsmRegisterK, AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftrb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrb_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrd<AsmRegisterK, AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftrd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrd_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrd<AsmRegisterK, AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftrd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrd_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrq<AsmRegisterK, AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftrq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrq_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrq<AsmRegisterK, AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftrq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrq_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrw<AsmRegisterK, AsmRegisterK, i32> for CodeAssembler {
	#[inline]
	fn kshiftrw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrw_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKshiftrw<AsmRegisterK, AsmRegisterK, u32> for CodeAssembler {
	#[inline]
	fn kshiftrw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kshiftrw_kr_kr_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmKtestb<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn ktestb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Ktestb_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKtestd<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn ktestd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Ktestd_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKtestq<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn ktestq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Ktestq_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKtestw<AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn ktestw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Ktestw_kr_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKunpckbw<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kunpckbw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kunpckbw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKunpckdq<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kunpckdq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kunpckdq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKunpckwd<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kunpckwd(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kunpckwd_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxnorb<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxnorb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxnorb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxnord<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxnord(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxnord_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxnorq<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxnorq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxnorq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxnorw<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxnorw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxnorw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxorb<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxorb(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxorb_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxord<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxord(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxord_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxorq<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxorq(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxorq_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmKxorw<AsmRegisterK, AsmRegisterK, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn kxorw(&mut self, op0: AsmRegisterK, op1: AsmRegisterK, op2: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Kxorw_kr_kr_kr, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLahf for CodeAssembler {
	#[inline]
	fn lahf(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Lahf))
	}
}

#[rustfmt::skip]
impl CodeAsmLar<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLar<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r32_r32m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLar<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r64_r64m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLar<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLar<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lar(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lar_r32_r32m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLddqu<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lddqu(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lddqu_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLdmxcsr<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ldmxcsr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ldmxcsr_m32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLds<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lds(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lds_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLds<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lds(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lds_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLdtilecfg<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ldtilecfg(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Ldtilecfg_m512, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLea<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lea(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lea_r16_m, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLea<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lea(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lea_r32_m, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLea<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lea(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lea_r64_m, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLeave for CodeAssembler {
	fn leave(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Leaveq
		} else if self.bitness() >= 32 {
			Code::Leaved
		} else {
			Code::Leavew
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmLes<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn les(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Les_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLes<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn les(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Les_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLfence for CodeAssembler {
	#[inline]
	fn lfence(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Lfence))
	}
}

#[rustfmt::skip]
impl CodeAsmLfs<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lfs(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lfs_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLfs<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lfs(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lfs_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLfs<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lfs(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lfs_r64_m1664, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLgdt<AsmMemoryOperand> for CodeAssembler {
	fn lgdt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Lgdt_m1664
		} else if self.bitness() >= 32 {
			Code::Lgdt_m1632
		} else {
			Code::Lgdt_m1632_16
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLgs<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lgs(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lgs_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLgs<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lgs(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lgs_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLgs<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lgs(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lgs_r64_m1664, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLidt<AsmMemoryOperand> for CodeAssembler {
	fn lidt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Lidt_m1664
		} else if self.bitness() >= 32 {
			Code::Lidt_m1632
		} else {
			Code::Lidt_m1632_16
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLkgs<AsmRegister16> for CodeAssembler {
	#[inline]
	fn lkgs(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lkgs_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLkgs<AsmRegister32> for CodeAssembler {
	#[inline]
	fn lkgs(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lkgs_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLkgs<AsmRegister64> for CodeAssembler {
	#[inline]
	fn lkgs(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lkgs_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLkgs<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lkgs(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Lkgs_r32m16 } else { Code::Lkgs_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLldt<AsmRegister16> for CodeAssembler {
	#[inline]
	fn lldt(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lldt_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLldt<AsmRegister32> for CodeAssembler {
	#[inline]
	fn lldt(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lldt_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLldt<AsmRegister64> for CodeAssembler {
	#[inline]
	fn lldt(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lldt_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLldt<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lldt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Lldt_r32m16 } else { Code::Lldt_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLlwpcb<AsmRegister32> for CodeAssembler {
	#[inline]
	fn llwpcb(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::XOP_Llwpcb_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLlwpcb<AsmRegister64> for CodeAssembler {
	#[inline]
	fn llwpcb(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::XOP_Llwpcb_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLmsw<AsmRegister16> for CodeAssembler {
	#[inline]
	fn lmsw(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lmsw_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLmsw<AsmRegister32> for CodeAssembler {
	#[inline]
	fn lmsw(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lmsw_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLmsw<AsmRegister64> for CodeAssembler {
	#[inline]
	fn lmsw(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Lmsw_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLmsw<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lmsw(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Lmsw_r32m16 } else { Code::Lmsw_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoadall for CodeAssembler {
	#[inline]
	fn loadall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Loadall386))
	}
}

#[rustfmt::skip]
impl CodeAsmLoadiwkey<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn loadiwkey(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Loadiwkey_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLodsb for CodeAssembler {
	#[inline]
	fn lodsb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_lodsb(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLodsd for CodeAssembler {
	#[inline]
	fn lodsd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_lodsd(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLodsq for CodeAssembler {
	#[inline]
	fn lodsq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_lodsq(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLodsw for CodeAssembler {
	#[inline]
	fn lodsw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_lodsw(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoop<CodeLabel> for CodeAssembler {
	fn loop_(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loop_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loop_rel8_32_ECX
		} else {
			Code::Loop_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoop<u64> for CodeAssembler {
	fn loop_(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loop_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loop_rel8_32_ECX
		} else {
			Code::Loop_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoope<CodeLabel> for CodeAssembler {
	fn loope(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loope_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loope_rel8_32_ECX
		} else {
			Code::Loope_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoope<u64> for CodeAssembler {
	fn loope(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loope_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loope_rel8_32_ECX
		} else {
			Code::Loope_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoopne<CodeLabel> for CodeAssembler {
	fn loopne(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loopne_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loopne_rel8_32_ECX
		} else {
			Code::Loopne_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoopne<u64> for CodeAssembler {
	fn loopne(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loopne_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loopne_rel8_32_ECX
		} else {
			Code::Loopne_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoopnz<CodeLabel> for CodeAssembler {
	fn loopnz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loopne_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loopne_rel8_32_ECX
		} else {
			Code::Loopne_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoopnz<u64> for CodeAssembler {
	fn loopnz(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loopne_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loopne_rel8_32_ECX
		} else {
			Code::Loopne_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoopz<CodeLabel> for CodeAssembler {
	fn loopz(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loope_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loope_rel8_32_ECX
		} else {
			Code::Loope_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLoopz<u64> for CodeAssembler {
	fn loopz(&mut self, op0: u64) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Loope_rel8_64_RCX
		} else if self.bitness() >= 32 {
			Code::Loope_rel8_32_ECX
		} else {
			Code::Loope_rel8_16_CX
		};
		self.add_instr(Instruction::with_branch(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r32_r32m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r64_r64m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLsl<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lsl(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lsl_r32_r32m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLss<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lss(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lss_r16_m1616, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLss<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lss(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lss_r32_m1632, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLss<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lss(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lss_r64_m1664, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLtr<AsmRegister16> for CodeAssembler {
	#[inline]
	fn ltr(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ltr_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLtr<AsmRegister32> for CodeAssembler {
	#[inline]
	fn ltr(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ltr_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLtr<AsmRegister64> for CodeAssembler {
	#[inline]
	fn ltr(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ltr_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLtr<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ltr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Ltr_r32m16 } else { Code::Ltr_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<AsmRegister32, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<AsmRegister64, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: AsmRegister64, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r64_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<AsmRegister32, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<AsmRegister64, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r64_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<AsmRegister32, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<AsmRegister64, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: AsmRegister64, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r64_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<AsmRegister32, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpins<AsmRegister64, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn lwpins(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpins_r64_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<AsmRegister32, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<AsmRegister64, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: AsmRegister64, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r64_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<AsmRegister32, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<AsmRegister64, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r64_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<AsmRegister32, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r32_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<AsmRegister64, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: AsmRegister64, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r64_rm32_imm32, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<AsmRegister32, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r32_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLwpval<AsmRegister64, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn lwpval(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Lwpval_r64_rm32_imm32, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmLzcnt<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn lzcnt(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Lzcnt_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaskmovdqu<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maskmovdqu(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_maskmovdqu(self.bitness(), op0.register(), op1.register(), Register::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaskmovq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn maskmovq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_maskmovq(self.bitness(), op0.register(), op1.register(), Register::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maxpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn maxpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maxps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn maxps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maxsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn maxsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn maxss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMaxss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn maxss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Maxss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMcommit for CodeAssembler {
	#[inline]
	fn mcommit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Mcommit))
	}
}

#[rustfmt::skip]
impl CodeAsmMfence for CodeAssembler {
	#[inline]
	fn mfence(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Mfence))
	}
}

#[rustfmt::skip]
impl CodeAsmMinpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn minpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn minpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn minps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn minps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn minsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn minsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn minss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMinss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn minss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Minss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMonitor for CodeAssembler {
	fn monitor(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Monitorq
		} else if self.bitness() >= 32 {
			Code::Monitord
		} else {
			Code::Monitorw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmMonitorx for CodeAssembler {
	fn monitorx(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Monitorxq
		} else if self.bitness() >= 32 {
			Code::Monitorxd
		} else {
			Code::Monitorxw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmMontmul for CodeAssembler {
	fn montmul(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Montmul_64
		} else if self.bitness() >= 32 {
			Code::Montmul_32
		} else {
			Code::Montmul_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	fn mov(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		let code = if op1.register() == Register::AL && self.bitness() == 64 && op0.is_displacement_only() {
			Code::Mov_moffs8_AL
		} else if op1.register() == Register::AL && self.bitness() < 64 && op0.is_displacement_only() {
			Code::Mov_moffs8_AL
		} else {
			Code::Mov_rm8_r8
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegisterSegment, AsmRegister16> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegisterSegment, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_Sreg_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	fn mov(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		let code = if op1.register() == Register::AX && self.bitness() == 64 && op0.is_displacement_only() {
			Code::Mov_moffs16_AX
		} else if op1.register() == Register::AX && self.bitness() < 64 && op0.is_displacement_only() {
			Code::Mov_moffs16_AX
		} else {
			Code::Mov_rm16_r16
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegisterSegment, AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegisterSegment, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_Sreg_r32m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegisterCr, AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegisterCr, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_cr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegisterDr, AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegisterDr, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_dr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegisterTr, AsmRegister32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegisterTr, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_tr_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	fn mov(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		let code = if op1.register() == Register::EAX && self.bitness() == 64 && op0.is_displacement_only() {
			Code::Mov_moffs32_EAX
		} else if op1.register() == Register::EAX && self.bitness() < 64 && op0.is_displacement_only() {
			Code::Mov_moffs32_EAX
		} else {
			Code::Mov_rm32_r32
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegisterSegment, AsmRegister64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegisterSegment, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_Sreg_r64m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegisterCr, AsmRegister64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegisterCr, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_cr_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegisterDr, AsmRegister64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegisterDr, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_dr_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	fn mov(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		let code = if op1.register() == Register::RAX && self.bitness() == 64 && op0.is_displacement_only() {
			Code::Mov_moffs64_RAX
		} else if op1.register() == Register::RAX && self.bitness() < 64 && op0.is_displacement_only() {
			Code::Mov_moffs64_RAX
		} else {
			Code::Mov_rm64_r64
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister16, AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister16, op1: AsmRegisterSegment) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_rm16_Sreg, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister32, AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister32, op1: AsmRegisterSegment) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32m16_Sreg, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister64, AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister64, op1: AsmRegisterSegment) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64m16_Sreg, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmMemoryOperand, AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterSegment) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Mov_r32m16_Sreg } else { Code::Mov_rm16_Sreg };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister32, AsmRegisterCr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister32, op1: AsmRegisterCr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_cr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister64, AsmRegisterCr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister64, op1: AsmRegisterCr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64_cr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister32, AsmRegisterDr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister32, op1: AsmRegisterDr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_dr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister64, AsmRegisterDr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister64, op1: AsmRegisterDr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64_dr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister32, AsmRegisterTr> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister32, op1: AsmRegisterTr) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_tr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	fn mov(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL && self.bitness() == 64 && op1.is_displacement_only() {
			Code::Mov_AL_moffs8
		} else if op0.register() == Register::AL && self.bitness() < 64 && op1.is_displacement_only() {
			Code::Mov_AL_moffs8
		} else {
			Code::Mov_r8_rm8
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	fn mov(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX && self.bitness() == 64 && op1.is_displacement_only() {
			Code::Mov_AX_moffs16
		} else if op0.register() == Register::AX && self.bitness() < 64 && op1.is_displacement_only() {
			Code::Mov_AX_moffs16
		} else {
			Code::Mov_r16_rm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	fn mov(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX && self.bitness() == 64 && op1.is_displacement_only() {
			Code::Mov_EAX_moffs32
		} else if op0.register() == Register::EAX && self.bitness() < 64 && op1.is_displacement_only() {
			Code::Mov_EAX_moffs32
		} else {
			Code::Mov_r32_rm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	fn mov(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX && self.bitness() == 64 && op1.is_displacement_only() {
			Code::Mov_RAX_moffs64
		} else if op0.register() == Register::RAX && self.bitness() < 64 && op1.is_displacement_only() {
			Code::Mov_RAX_moffs64
		} else {
			Code::Mov_r64_rm64
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegisterSegment, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegisterSegment, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Mov_Sreg_r32m16 } else { Code::Mov_Sreg_rm16 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r8_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r16_imm16, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_imm32, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister64, i64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister64, op1: i64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64_imm64, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmMemoryOperand, i32> for CodeAssembler {
	fn mov(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Mov_rm64_imm32
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Mov_rm32_imm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Mov_rm16_imm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Mov_rm8_imm8
		} else {
			return Err(IcedError::new("mov: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r8_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r16_imm16, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r32_imm32, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmRegister64, u64> for CodeAssembler {
	#[inline]
	fn mov(&mut self, op0: AsmRegister64, op1: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mov_r64_imm64, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMov<AsmMemoryOperand, u32> for CodeAssembler {
	fn mov(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Mov_rm32_imm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Mov_rm16_imm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Mov_rm8_imm8
		} else {
			return Err(IcedError::new("mov: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovapd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movapd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movapd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovapd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movapd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movapd_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovapd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movapd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movapd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovaps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movaps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movaps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovaps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movaps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movaps_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovaps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movaps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movaps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_m16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_r16_m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_r32_m32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovbe<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movbe(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movbe_r64_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<AsmRegisterMm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: AsmRegisterMm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_mm_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_xmm_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<AsmRegister32, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: AsmRegister32, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_rm32_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<AsmMemoryOperand, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_rm32_mm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_rm32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_rm32_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_mm_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movd_xmm_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovddup<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movddup(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movddup_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovddup<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movddup(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movddup_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdir64b<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdir64b(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdir64b_r16_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdir64b<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdir64b(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdir64b_r32_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdir64b<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdir64b(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdir64b_r64_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdiri<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn movdiri(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdiri_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdiri<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn movdiri(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdiri_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdq2q<AsmRegisterMm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdq2q(&mut self, op0: AsmRegisterMm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdq2q_mm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqa<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdqa(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqa_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqa<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdqa(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqa_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqa<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdqa(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqa_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqu<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdqu(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqu_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqu<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movdqu(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqu_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovdqu<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movdqu(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movdqu_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhlps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movhlps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhlps_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhpd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movhpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhpd_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movhpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhpd_xmm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movhps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhps_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovhps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movhps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movhps_xmm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlhps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movlhps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlhps_xmm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlpd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movlpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlpd_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movlpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlpd_xmm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movlps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlps_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovlps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movlps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movlps_xmm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovmskpd<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movmskpd(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movmskpd_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovmskpd<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movmskpd(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movmskpd_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovmskps<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movmskps(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movmskps_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovmskps<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movmskps(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movmskps_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntdq<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntdq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntdq_m128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntdqa<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movntdqa(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntdqa_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovnti<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn movnti(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movnti_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovnti<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn movnti(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movnti_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntpd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntpd_m128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntps_m128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntq<AsmMemoryOperand, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movntq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntq_m64_mm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntsd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntsd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntsd_m64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovntss<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movntss(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movntss_m32_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmRegisterMm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmRegisterMm, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_mm_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_xmm_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmRegister64, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmRegister64, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_rm64_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmMemoryOperand, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_mmm64_mm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_rm64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_xmmm64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovq2dq<AsmRegisterXmm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn movq2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movq2dq_xmm_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsb for CodeAssembler {
	#[inline]
	fn movsb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_movsb(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsd for CodeAssembler {
	#[inline]
	fn movsd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_movsd(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsd2<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movsd_2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsd2<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movsd_2(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsd_xmmm64_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsd2<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsd_2(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovshdup<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movshdup(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movshdup_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovshdup<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movshdup(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movshdup_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsldup<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movsldup(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsldup_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsldup<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsldup(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsldup_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsq for CodeAssembler {
	#[inline]
	fn movsq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_movsq(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovss<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movss(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movss_xmmm32_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsw for CodeAssembler {
	#[inline]
	fn movsw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_movsw(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r16_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r32_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r64_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<AsmRegister32, AsmRegister16> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: AsmRegister32, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r32_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<AsmRegister64, AsmRegister16> for CodeAssembler {
	#[inline]
	fn movsx(&mut self, op0: AsmRegister64, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsx_r64_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	fn movsx(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movsx_r16_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movsx_r16_rm8
		} else {
			return Err(IcedError::new("movsx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	fn movsx(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movsx_r32_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movsx_r32_rm8
		} else {
			return Err(IcedError::new("movsx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsx<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	fn movsx(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movsx_r64_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movsx_r64_rm8
		} else {
			return Err(IcedError::new("movsx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<AsmRegister64, AsmRegister32> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: AsmRegister64, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r64_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovsxd<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movsxd(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movsxd_r64_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovupd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movupd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movupd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovupd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movupd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movupd_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovupd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movupd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movupd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovups<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movups(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movups_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovups<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn movups(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movups_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovups<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn movups(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movups_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r16_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r32_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r64_rm8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<AsmRegister32, AsmRegister16> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: AsmRegister32, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r32_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<AsmRegister64, AsmRegister16> for CodeAssembler {
	#[inline]
	fn movzx(&mut self, op0: AsmRegister64, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Movzx_r64_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	fn movzx(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movzx_r16_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movzx_r16_rm8
		} else {
			return Err(IcedError::new("movzx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	fn movzx(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movzx_r32_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movzx_r32_rm8
		} else {
			return Err(IcedError::new("movzx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMovzx<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	fn movzx(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.size() == MemoryOperandSize::Word {
			Code::Movzx_r64_rm16
		} else if op1.size() == MemoryOperandSize::Byte {
			Code::Movzx_r64_rm8
		} else {
			return Err(IcedError::new("movzx: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMpsadbw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn mpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Mpsadbw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMpsadbw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn mpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Mpsadbw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMpsadbw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn mpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Mpsadbw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMpsadbw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn mpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Mpsadbw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<AsmRegister8> for CodeAssembler {
	#[inline]
	fn mul(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Mul_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<AsmRegister16> for CodeAssembler {
	#[inline]
	fn mul(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Mul_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<AsmRegister32> for CodeAssembler {
	#[inline]
	fn mul(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Mul_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<AsmRegister64> for CodeAssembler {
	#[inline]
	fn mul(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Mul_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMul<AsmMemoryOperand> for CodeAssembler {
	fn mul(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Mul_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Mul_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Mul_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Mul_rm8
		} else {
			return Err(IcedError::new("mul: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn mulpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn mulps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn mulsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn mulss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Mulss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulx<AsmRegister32, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn mulx(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Mulx_r32_r32_rm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulx<AsmRegister64, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn mulx(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Mulx_r64_r64_rm64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulx<AsmRegister32, AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulx(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Mulx_r32_r32_rm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMulx<AsmRegister64, AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn mulx(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Mulx_r64_r64_rm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmMwait for CodeAssembler {
	#[inline]
	fn mwait(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Mwait))
	}
}

#[rustfmt::skip]
impl CodeAsmMwaitx for CodeAssembler {
	#[inline]
	fn mwaitx(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Mwaitx))
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<AsmRegister8> for CodeAssembler {
	#[inline]
	fn neg(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Neg_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<AsmRegister16> for CodeAssembler {
	#[inline]
	fn neg(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Neg_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<AsmRegister32> for CodeAssembler {
	#[inline]
	fn neg(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Neg_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<AsmRegister64> for CodeAssembler {
	#[inline]
	fn neg(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Neg_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNeg<AsmMemoryOperand> for CodeAssembler {
	fn neg(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Neg_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Neg_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Neg_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Neg_rm8
		} else {
			return Err(IcedError::new("neg: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmNop for CodeAssembler {
	#[inline]
	fn nop(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Nopd } else { Code::Nopw };
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmNop1<AsmRegister16> for CodeAssembler {
	#[inline]
	fn nop_1(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Nop_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNop1<AsmRegister32> for CodeAssembler {
	#[inline]
	fn nop_1(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Nop_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNop1<AsmRegister64> for CodeAssembler {
	#[inline]
	fn nop_1(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Nop_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNop1<AsmMemoryOperand> for CodeAssembler {
	fn nop_1(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Nop_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Nop_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Nop_rm16
		} else {
			return Err(IcedError::new("nop: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<AsmRegister8> for CodeAssembler {
	#[inline]
	fn not(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Not_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<AsmRegister16> for CodeAssembler {
	#[inline]
	fn not(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Not_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<AsmRegister32> for CodeAssembler {
	#[inline]
	fn not(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Not_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<AsmRegister64> for CodeAssembler {
	#[inline]
	fn not(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Not_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmNot<AsmMemoryOperand> for CodeAssembler {
	fn not(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Not_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Not_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Not_rm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Not_rm8
		} else {
			return Err(IcedError::new("not: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Or_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Or_AL_imm8 } else { Code::Or_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister16, i32> for CodeAssembler {
	fn or(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Or_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Or_rm16_imm8
		} else {
			Code::Or_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister32, i32> for CodeAssembler {
	fn or(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Or_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Or_rm32_imm8
		} else {
			Code::Or_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister64, i32> for CodeAssembler {
	fn or(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Or_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Or_rm64_imm8
		} else {
			Code::Or_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmMemoryOperand, i32> for CodeAssembler {
	fn or(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Or_rm64_imm8 } else { Code::Or_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Or_rm32_imm8 } else { Code::Or_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Or_rm16_imm8 } else { Code::Or_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Or_rm8_imm8
		} else {
			return Err(IcedError::new("or: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn or(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Or_AL_imm8 } else { Code::Or_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister16, u32> for CodeAssembler {
	fn or(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Or_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Or_rm16_imm8
		} else {
			Code::Or_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmRegister32, u32> for CodeAssembler {
	fn or(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Or_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Or_rm32_imm8
		} else {
			Code::Or_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOr<AsmMemoryOperand, u32> for CodeAssembler {
	fn or(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Or_rm32_imm8 } else { Code::Or_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Or_rm16_imm8 } else { Code::Or_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Or_rm8_imm8
		} else {
			return Err(IcedError::new("or: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOrpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn orpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Orpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOrpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn orpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Orpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOrps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn orps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Orps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOrps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn orps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Orps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_DX_AL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<i32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: i32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_AL, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<u32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: u32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_AL, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_DX_AX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<i32, AsmRegister16> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: i32, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_AX, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<u32, AsmRegister16> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: u32, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_AX, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<AsmRegister16, AsmRegister32> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: AsmRegister16, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_DX_EAX, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<i32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: i32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_EAX, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOut<u32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn out(&mut self, op0: u32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Out_imm8_EAX, op0, op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmOutsb for CodeAssembler {
	#[inline]
	fn outsb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_outsb(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOutsd for CodeAssembler {
	#[inline]
	fn outsd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_outsd(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmOutsw for CodeAssembler {
	#[inline]
	fn outsw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_outsw(self.bitness(), Register::None, RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pabsb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pabsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pabsd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pabsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pabsw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pabsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPabsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pabsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pabsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackssdw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn packssdw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packssdw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackssdw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn packssdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packssdw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackssdw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packssdw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packssdw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackssdw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packssdw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packssdw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPacksswb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn packsswb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packsswb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPacksswb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn packsswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packsswb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPacksswb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packsswb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packsswb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPacksswb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packsswb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packsswb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackusdw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn packusdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packusdw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackusdw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packusdw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packusdw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackuswb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn packuswb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packuswb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackuswb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn packuswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packuswb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackuswb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packuswb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packuswb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPackuswb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn packuswb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Packuswb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddq<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddq(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddsb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsiw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddsiw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsiw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsiw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsiw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsiw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddsw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddusb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddusb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddusb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddusb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddusw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddusw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddusw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddusw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddusw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddusw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paddw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn paddw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaddw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paddw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paddw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<AsmRegisterMm, AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_mm_mmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<AsmRegisterMm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_mm_mmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<AsmRegisterMm, AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_mm_mmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<AsmRegisterMm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_mm_mmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPalignr<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn palignr(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Palignr_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPand<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pand(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pand_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPand<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pand(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pand_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPand<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pand(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pand_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPand<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pand(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pand_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPandn<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pandn(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pandn_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPandn<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pandn(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pandn_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPandn<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pandn(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pandn_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPandn<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pandn(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pandn_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPause for CodeAssembler {
	#[inline]
	fn pause(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pause))
	}
}

#[rustfmt::skip]
impl CodeAsmPaveb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn paveb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paveb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPaveb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn paveb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Paveb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pavgb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pavgb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgusb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pavgusb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pavgusb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgusb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgusb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pavgusb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pavgw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pavgw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPavgw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pavgw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pavgw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendvb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pblendvb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pblendvb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendvb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pblendvb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pblendvb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pblendw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pblendw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pblendw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pblendw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pblendw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pblendw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPblendw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pblendw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pblendw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPbndkb for CodeAssembler {
	#[inline]
	fn pbndkb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pbndkb))
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulhqhqdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pclmulhqhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<AsmRegisterXmm, AsmRegisterXmm, i32>>::pclmulqdq(self, op0, op1, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulhqhqdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pclmulhqhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<AsmRegisterXmm, AsmMemoryOperand, i32>>::pclmulqdq(self, op0, op1, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulhqlqdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pclmulhqlqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<AsmRegisterXmm, AsmRegisterXmm, i32>>::pclmulqdq(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulhqlqdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pclmulhqlqdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<AsmRegisterXmm, AsmMemoryOperand, i32>>::pclmulqdq(self, op0, op1, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmullqhqdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pclmullqhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<AsmRegisterXmm, AsmRegisterXmm, i32>>::pclmulqdq(self, op0, op1, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmullqhqdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pclmullqhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<AsmRegisterXmm, AsmMemoryOperand, i32>>::pclmulqdq(self, op0, op1, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmullqlqdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pclmullqlqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<AsmRegisterXmm, AsmRegisterXmm, i32>>::pclmulqdq(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmullqlqdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pclmullqlqdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmPclmulqdq<AsmRegisterXmm, AsmMemoryOperand, i32>>::pclmulqdq(self, op0, op1, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulqdq<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pclmulqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pclmulqdq_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulqdq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pclmulqdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pclmulqdq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulqdq<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pclmulqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pclmulqdq_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPclmulqdq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pclmulqdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pclmulqdq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpeqb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpeqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpeqd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpeqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpeqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpeqw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpeqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpeqw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpeqw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpeqw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpestri(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpestri(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpestri(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpestri(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri64<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpestri64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri64<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpestri64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri64<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpestri64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestri64<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpestri64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpestrm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpestrm(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpestrm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpestrm(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm64<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpestrm64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm64<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpestrm64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm64<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpestrm64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpestrm64<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpestrm64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpgtb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpgtb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpgtd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpgtd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpgtq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pcmpgtw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pcmpgtw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpgtw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pcmpgtw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pcmpgtw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistri<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpistri(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistri<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpistri(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistri<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpistri(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistri<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpistri(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistrm<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pcmpistrm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistrm<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pcmpistrm(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistrm<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pcmpistrm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcmpistrm<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pcmpistrm(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPcommit for CodeAssembler {
	#[inline]
	fn pcommit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pcommit))
	}
}

#[rustfmt::skip]
impl CodeAsmPconfig for CodeAssembler {
	#[inline]
	fn pconfig(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pconfig))
	}
}

#[rustfmt::skip]
impl CodeAsmPdep<AsmRegister32, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn pdep(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pdep_r32_r32_rm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPdep<AsmRegister64, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn pdep(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pdep_r64_r64_rm64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPdep<AsmRegister32, AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pdep(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pdep_r32_r32_rm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPdep<AsmRegister64, AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pdep(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pdep_r64_r64_rm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPdistib<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pdistib(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pdistib_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPext<AsmRegister32, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn pext(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pext_r32_r32_rm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPext<AsmRegister64, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn pext(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pext_r64_r64_rm64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPext<AsmRegister32, AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pext(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pext_r32_r32_rm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPext<AsmRegister64, AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pext(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Pext_r64_r64_rm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<AsmRegister32, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r32m8_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<AsmRegister64, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r64m8_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r32m8_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<AsmRegister32, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r32m8_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<AsmRegister64, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r64m8_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrb<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrb_r32m8_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrd<AsmRegister32, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrd(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrd_rm32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrd<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrd_rm32_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrd<AsmRegister32, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrd(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrd_rm32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrd<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrd_rm32_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrq<AsmRegister64, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrq(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrq_rm64_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrq<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrq_rm64_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrq<AsmRegister64, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrq(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrq_rm64_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrq<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrq_rm64_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmRegister32, AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmRegister32, op1: AsmRegisterMm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32_mm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmRegister64, AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmRegister64, op1: AsmRegisterMm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r64_mm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmRegister32, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmRegister64, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r64_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32m16_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmRegister32, AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmRegister32, op1: AsmRegisterMm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32_mm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmRegister64, AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmRegister64, op1: AsmRegisterMm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r64_mm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmRegister32, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmRegister64, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r64_xmm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPextrw<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pextrw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pextrw_r32m16_xmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPf2id<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pf2id(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pf2id_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPf2id<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pf2id(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pf2id_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPf2iw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pf2iw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pf2iw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPf2iw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pf2iw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pf2iw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfacc<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfacc(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfacc_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfacc<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfacc(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfacc_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfadd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfadd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfadd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfadd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfadd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfadd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpeq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfcmpeq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpeq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpeq<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfcmpeq(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpeq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpge<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfcmpge(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpge_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpge<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfcmpge(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpge_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpgt<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfcmpgt(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpgt_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfcmpgt<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfcmpgt(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfcmpgt_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmax<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfmax(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmax_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmax<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfmax(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmax_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmin<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfmin(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmin_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmin<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfmin(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmin_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmul<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfmul(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmul_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfmul<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfmul(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfmul_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfnacc<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfnacc(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfnacc_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfnacc<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfnacc(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfnacc_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfpnacc<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfpnacc(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfpnacc_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfpnacc<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfpnacc(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfpnacc_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcp<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrcp(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcp_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcp<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrcp(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcp_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpit1<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrcpit1(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpit1_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpit1<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrcpit1(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpit1_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpit2<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrcpit2(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpit2_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpit2<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrcpit2(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpit2_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpv<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrcpv(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpv_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrcpv<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrcpv(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrcpv_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqit1<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrsqit1(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqit1_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqit1<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrsqit1(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqit1_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqrt<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrsqrt(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqrt_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqrt<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrsqrt(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqrt_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqrtv<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfrsqrtv(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqrtv_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfrsqrtv<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfrsqrtv(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfrsqrtv_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfsub<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfsub(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfsub_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfsub<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfsub(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfsub_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfsubr<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pfsubr(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfsubr_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPfsubr<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pfsubr(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pfsubr_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phaddd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phaddd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddsw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phaddsw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phaddsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddsw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddsw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phaddw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phaddw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhaddw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phaddw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phaddw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhminposuw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phminposuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phminposuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhminposuw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phminposuw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phminposuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phsubd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phsubd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubsw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phsubsw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phsubsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubsw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubsw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn phsubw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn phsubw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPhsubw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn phsubw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Phsubw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPi2fd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pi2fd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pi2fd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPi2fd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pi2fd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pi2fd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPi2fw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pi2fw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pi2fw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPi2fw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pi2fw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pi2fw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<AsmRegisterXmm, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r32m8_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<AsmRegisterXmm, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r64m8_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r32m8_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<AsmRegisterXmm, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r32m8_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<AsmRegisterXmm, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r64m8_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrb<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrb_xmm_r32m8_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrd<AsmRegisterXmm, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn pinsrd(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrd_xmm_rm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrd_xmm_rm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrd<AsmRegisterXmm, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn pinsrd(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrd_xmm_rm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrd_xmm_rm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrq<AsmRegisterXmm, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn pinsrq(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrq_xmm_rm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrq_xmm_rm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrq<AsmRegisterXmm, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn pinsrq(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrq_xmm_rm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrq_xmm_rm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterMm, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterMm, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r32m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterXmm, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r32m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterMm, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterMm, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r64m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterXmm, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r64m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterMm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r32m16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r32m16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterMm, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterMm, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r32m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterXmm, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r32m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterMm, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterMm, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r64m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterXmm, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r64m16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterMm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_mm_r32m16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPinsrw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pinsrw_xmm_r32m16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmachriw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmachriw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmachriw_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddubsw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmaddubsw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddubsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddubsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaddubsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddubsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddubsw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaddubsw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddubsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddubsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaddubsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddubsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddwd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmaddwd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddwd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaddwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddwd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaddwd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddwd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaddwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaddwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaddwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmagw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmagw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmagw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmagw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmagw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmagw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxsb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmaxsw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxsw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxub<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmaxub(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxub_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxub<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxub_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxub<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxub(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxub_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxub<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxub(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxub_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxud<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxud_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxud<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxud(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxud_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxuw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmaxuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmaxuw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmaxuw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmaxuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminsb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pminsw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminsw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminub<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pminub(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminub_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminub<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminub_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminub<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminub(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminub_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminub<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminub(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminub_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminud<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminud_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminud<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminud(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminud_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminuw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pminuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPminuw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pminuw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pminuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovmskb<AsmRegister32, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmovmskb(&mut self, op0: AsmRegister32, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovmskb_r32_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovmskb<AsmRegister64, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmovmskb(&mut self, op0: AsmRegister64, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovmskb_r64_mm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovmskb<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovmskb(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovmskb_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovmskb<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovmskb(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovmskb_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxbd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbd_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxbd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbd_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxbq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbq_xmm_xmmm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxbq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbq_xmm_xmmm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbw_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxbw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxbw_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxdq_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxdq_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxwd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxwd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxwq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovsxwq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxwq_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovsxwq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovsxwq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovsxwq_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxbd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbd_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxbd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbd_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxbq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbq_xmm_xmmm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxbq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbq_xmm_xmmm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbw_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxbw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxbw_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxdq_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxdq_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxwd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxwd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxwq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmovzxwq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxwq_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmovzxwq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmovzxwq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmovzxwq_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuldq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmuldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuldq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuldq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmuldq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuldq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhriw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhriw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhriw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhriw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhriw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhriw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrsw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhrsw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmulhrsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrsw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhrsw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhrsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhrw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pmulhrw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhrw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pmulhrw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrw_cyrix<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhrw_cyrix(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhrw_cyrix<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhrw_cyrix(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhrw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhuw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhuw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhuw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhuw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmulhuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhuw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhuw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhuw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhuw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhuw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmulhw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmulhw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulhw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulhw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulhw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulld<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmulld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulld_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmulld<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmulld(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmulld_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmullw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmullw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmullw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmullw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmullw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmullw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmullw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmullw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmullw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmullw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmullw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmullw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuludq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pmuludq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuludq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuludq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pmuludq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuludq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuludq<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmuludq(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuludq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmuludq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmuludq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmuludq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmvgezb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmvgezb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmvgezb_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmvlzb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmvlzb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmvlzb_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmvnzb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmvnzb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmvnzb_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPmvzb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pmvzb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pmvzb_mm_m64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<AsmRegister16> for CodeAssembler {
	#[inline]
	fn pop(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Pop_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<AsmRegister32> for CodeAssembler {
	#[inline]
	fn pop(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Pop_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<AsmRegister64> for CodeAssembler {
	#[inline]
	fn pop(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Pop_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<AsmRegisterSegment> for CodeAssembler {
	fn pop(&mut self, op0: AsmRegisterSegment) -> Result<(), IcedError> {
		let code = if op0.register() == Register::FS {
			if self.bitness() == 64 {
				Code::Popq_FS
			} else if self.bitness() >= 32 {
				Code::Popd_FS
			} else {
				Code::Popw_FS
			}
		} else if op0.register() == Register::GS {
			if self.bitness() == 64 {
				Code::Popq_GS
			} else if self.bitness() >= 32 {
				Code::Popd_GS
			} else {
				Code::Popw_GS
			}
		} else if op0.register() == Register::ES {
			if self.bitness() >= 32 { Code::Popd_ES } else { Code::Popw_ES }
		} else if op0.register() == Register::SS {
			if self.bitness() >= 32 { Code::Popd_SS } else { Code::Popw_SS }
		} else if op0.register() == Register::DS {
			if self.bitness() >= 32 { Code::Popd_DS } else { Code::Popw_DS }
		} else {
			return Err(IcedError::new("pop: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPop<AsmMemoryOperand> for CodeAssembler {
	fn pop(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Pop_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Pop_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Pop_rm16
		} else {
			return Err(IcedError::new("pop: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopa for CodeAssembler {
	#[inline]
	fn popa(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popaw))
	}
}

#[rustfmt::skip]
impl CodeAsmPopad for CodeAssembler {
	#[inline]
	fn popad(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popad))
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopcnt<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn popcnt(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Popcnt_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPopf for CodeAssembler {
	#[inline]
	fn popf(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popfw))
	}
}

#[rustfmt::skip]
impl CodeAsmPopfd for CodeAssembler {
	#[inline]
	fn popfd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popfd))
	}
}

#[rustfmt::skip]
impl CodeAsmPopfq for CodeAssembler {
	#[inline]
	fn popfq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Popfq))
	}
}

#[rustfmt::skip]
impl CodeAsmPor<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn por(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Por_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPor<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn por(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Por_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPor<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn por(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Por_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPor<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn por(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Por_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetch<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetch(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetch_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetchit0<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetchit0(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetchit0_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetchit1<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetchit1(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetchit1_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetchnta<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetchnta(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetchnta_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetcht0<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetcht0(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetcht0_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetcht1<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetcht1(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetcht1_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetcht2<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetcht2(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetcht2_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetchw<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetchw(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetchw_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPrefetchwt1<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn prefetchwt1(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Prefetchwt1_m8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsadbw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psadbw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psadbw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsadbw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psadbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsadbw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psadbw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psadbw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsadbw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psadbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psadbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pshufb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pshufb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pshufb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pshufb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pshufb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pshufb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pshufb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pshufb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pshufd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pshufd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pshufd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pshufd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufhw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pshufhw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufhw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufhw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pshufhw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufhw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufhw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pshufhw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufhw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufhw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pshufhw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufhw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshuflw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pshuflw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshuflw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshuflw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pshuflw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshuflw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshuflw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pshuflw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshuflw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshuflw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pshuflw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshuflw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufw<AsmRegisterMm, AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn pshufw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufw_mm_mmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufw<AsmRegisterMm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn pshufw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufw_mm_mmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufw<AsmRegisterMm, AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn pshufw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufw_mm_mmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPshufw<AsmRegisterMm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn pshufw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Pshufw_mm_mmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psignb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psignb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psignd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psignd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psignw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psignw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsignw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psignw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psignw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslld<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pslld(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslld_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslldq<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn pslldq(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslldq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPslldq<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn pslldq(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pslldq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllq<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psllq(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsllw<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psllw(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psllw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsmash for CodeAssembler {
	#[inline]
	fn psmash(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Psmash))
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrad<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrad(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrad_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsraw<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psraw(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psraw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrld<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrld(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrld_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrldq<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrldq(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrldq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrldq<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrldq(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrldq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlq<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrlq(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlq_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<AsmRegisterMm, i32> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: AsmRegisterMm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: AsmRegisterXmm, op1: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<AsmRegisterMm, u32> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: AsmRegisterMm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_mm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsrlw<AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn psrlw(&mut self, op0: AsmRegisterXmm, op1: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psrlw_xmm_imm8, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubq<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubq(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubsb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsiw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubsiw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsiw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsiw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsiw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsiw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubsw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubsw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusb<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubusb(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusb_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubusb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusb_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusb<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubusb(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusb_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubusb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusb_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubusw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubusw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubusw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubusw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubusw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubusw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn psubw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn psubw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPsubw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn psubw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Psubw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPswapd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pswapd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pswapd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPswapd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pswapd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::D3NOW_Pswapd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtest<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn ptest(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ptest_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtest<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ptest(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ptest_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtwrite<AsmRegister32> for CodeAssembler {
	#[inline]
	fn ptwrite(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ptwrite_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtwrite<AsmRegister64> for CodeAssembler {
	#[inline]
	fn ptwrite(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Ptwrite_rm64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPtwrite<AsmMemoryOperand> for CodeAssembler {
	fn ptwrite(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Ptwrite_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Ptwrite_rm32
		} else {
			return Err(IcedError::new("ptwrite: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhbw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpckhbw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhbw_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhbw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckhbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhbw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhbw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhbw_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhbw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhdq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpckhdq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhdq_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckhdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhdq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhdq<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhdq(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhdq_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhdq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhqdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhqdq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhqdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhqdq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhwd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpckhwd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhwd_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckhwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhwd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhwd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhwd_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckhwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckhwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckhwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklbw<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpcklbw(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklbw_mm_mmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklbw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpcklbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklbw<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklbw(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklbw_mm_mmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklbw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckldq<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpckldq(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckldq_mm_mmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckldq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpckldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckldq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckldq<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckldq(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckldq_mm_mmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpckldq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpckldq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpckldq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklqdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpcklqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklqdq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklqdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklqdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklqdq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklwd<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn punpcklwd(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklwd_mm_mmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn punpcklwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklwd<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklwd(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklwd_mm_mmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPunpcklwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn punpcklwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Punpcklwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<AsmRegister16> for CodeAssembler {
	#[inline]
	fn push(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Push_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<AsmRegister32> for CodeAssembler {
	#[inline]
	fn push(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Push_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<AsmRegister64> for CodeAssembler {
	#[inline]
	fn push(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Push_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<AsmRegisterSegment> for CodeAssembler {
	fn push(&mut self, op0: AsmRegisterSegment) -> Result<(), IcedError> {
		let code = if op0.register() == Register::FS {
			if self.bitness() == 64 {
				Code::Pushq_FS
			} else if self.bitness() >= 32 {
				Code::Pushd_FS
			} else {
				Code::Pushw_FS
			}
		} else if op0.register() == Register::GS {
			if self.bitness() == 64 {
				Code::Pushq_GS
			} else if self.bitness() >= 32 {
				Code::Pushd_GS
			} else {
				Code::Pushw_GS
			}
		} else if op0.register() == Register::ES {
			if self.bitness() >= 32 { Code::Pushd_ES } else { Code::Pushw_ES }
		} else if op0.register() == Register::CS {
			if self.bitness() >= 32 { Code::Pushd_CS } else { Code::Pushw_CS }
		} else if op0.register() == Register::SS {
			if self.bitness() >= 32 { Code::Pushd_SS } else { Code::Pushw_SS }
		} else if op0.register() == Register::DS {
			if self.bitness() >= 32 { Code::Pushd_DS } else { Code::Pushw_DS }
		} else {
			return Err(IcedError::new("push: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<AsmMemoryOperand> for CodeAssembler {
	fn push(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Push_rm64
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Push_rm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Push_rm16
		} else {
			return Err(IcedError::new("push: invalid operands"));
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<i32> for CodeAssembler {
	fn push(&mut self, op0: i32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			if op0 >= i8::MIN as i32 && op0 <= i8::MAX as i32 { Code::Pushq_imm8 } else { Code::Pushq_imm32 }
		} else if self.bitness() >= 32 {
			if op0 >= i8::MIN as i32 && op0 <= i8::MAX as i32 { Code::Pushd_imm8 } else { Code::Pushd_imm32 }
		} else if op0 >= i8::MIN as i32 && op0 <= i8::MAX as i32 {
			Code::Pushw_imm8
		} else {
			Code::Push_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPush<u32> for CodeAssembler {
	fn push(&mut self, op0: u32) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 {
			if op0 <= i8::MAX as u32 || 0xFFFF_FF80 <= op0 { Code::Pushd_imm8 } else { Code::Pushd_imm32 }
		} else if op0 <= i8::MAX as u32 || (0xFF80 <= op0 && op0 <= 0xFFFF) {
			Code::Pushw_imm8
		} else {
			Code::Push_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmPusha for CodeAssembler {
	#[inline]
	fn pusha(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushaw))
	}
}

#[rustfmt::skip]
impl CodeAsmPushad for CodeAssembler {
	#[inline]
	fn pushad(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushad))
	}
}

#[rustfmt::skip]
impl CodeAsmPushf for CodeAssembler {
	#[inline]
	fn pushf(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushfw))
	}
}

#[rustfmt::skip]
impl CodeAsmPushfd for CodeAssembler {
	#[inline]
	fn pushfd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushfd))
	}
}

#[rustfmt::skip]
impl CodeAsmPushfq for CodeAssembler {
	#[inline]
	fn pushfq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Pushfq))
	}
}

#[rustfmt::skip]
impl CodeAsmPvalidate for CodeAssembler {
	fn pvalidate(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Pvalidateq
		} else if self.bitness() >= 32 {
			Code::Pvalidated
		} else {
			Code::Pvalidatew
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmPxor<AsmRegisterMm, AsmRegisterMm> for CodeAssembler {
	#[inline]
	fn pxor(&mut self, op0: AsmRegisterMm, op1: AsmRegisterMm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pxor_mm_mmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPxor<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn pxor(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pxor_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmPxor<AsmRegisterMm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pxor(&mut self, op0: AsmRegisterMm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pxor_mm_mmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmPxor<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn pxor(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Pxor_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcl_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcl_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcl_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcl_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	fn rcl(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Rcl_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcl_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcl_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcl_rm8_CL
		} else {
			return Err(IcedError::new("rcl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm8_1 } else { Code::Rcl_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm16_1 } else { Code::Rcl_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm32_1 } else { Code::Rcl_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm64_1 } else { Code::Rcl_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmMemoryOperand, i32> for CodeAssembler {
	fn rcl(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rcl_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rcl_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rcl_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rcl_rm8_1
			} else {
				return Err(IcedError::new("rcl: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rcl_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcl_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcl_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcl_rm8_imm8
		} else {
			return Err(IcedError::new("rcl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm8_1 } else { Code::Rcl_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm16_1 } else { Code::Rcl_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm32_1 } else { Code::Rcl_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn rcl(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcl_rm64_1 } else { Code::Rcl_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcl<AsmMemoryOperand, u32> for CodeAssembler {
	fn rcl(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rcl_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rcl_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rcl_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rcl_rm8_1
			} else {
				return Err(IcedError::new("rcl: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rcl_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcl_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcl_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcl_rm8_imm8
		} else {
			return Err(IcedError::new("rcl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcpps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn rcpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcpps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcpps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rcpps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcpps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcpss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn rcpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcpss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcpss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rcpss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcpss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcr_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcr_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcr_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rcr_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	fn rcr(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Rcr_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcr_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcr_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcr_rm8_CL
		} else {
			return Err(IcedError::new("rcr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm8_1 } else { Code::Rcr_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm16_1 } else { Code::Rcr_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm32_1 } else { Code::Rcr_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm64_1 } else { Code::Rcr_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmMemoryOperand, i32> for CodeAssembler {
	fn rcr(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rcr_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rcr_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rcr_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rcr_rm8_1
			} else {
				return Err(IcedError::new("rcr: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rcr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcr_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcr_rm8_imm8
		} else {
			return Err(IcedError::new("rcr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm8_1 } else { Code::Rcr_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm16_1 } else { Code::Rcr_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm32_1 } else { Code::Rcr_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn rcr(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rcr_rm64_1 } else { Code::Rcr_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRcr<AsmMemoryOperand, u32> for CodeAssembler {
	fn rcr(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rcr_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rcr_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rcr_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rcr_rm8_1
			} else {
				return Err(IcedError::new("rcr: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rcr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rcr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rcr_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rcr_rm8_imm8
		} else {
			return Err(IcedError::new("rcr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdfsbase<AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdfsbase(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdfsbase_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdfsbase<AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdfsbase(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdfsbase_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdgsbase<AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdgsbase(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdgsbase_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdgsbase<AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdgsbase(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdgsbase_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdm for CodeAssembler {
	#[inline]
	fn rdm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdm))
	}
}

#[rustfmt::skip]
impl CodeAsmRdmsr for CodeAssembler {
	#[inline]
	fn rdmsr(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdmsr))
	}
}

#[rustfmt::skip]
impl CodeAsmRdmsrlist for CodeAssembler {
	#[inline]
	fn rdmsrlist(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdmsrlist))
	}
}

#[rustfmt::skip]
impl CodeAsmRdpid<AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdpid(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdpid_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdpid<AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdpid(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdpid_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdpkru for CodeAssembler {
	#[inline]
	fn rdpkru(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdpkru))
	}
}

#[rustfmt::skip]
impl CodeAsmRdpmc for CodeAssembler {
	#[inline]
	fn rdpmc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdpmc))
	}
}

#[rustfmt::skip]
impl CodeAsmRdpru for CodeAssembler {
	#[inline]
	fn rdpru(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdpru))
	}
}

#[rustfmt::skip]
impl CodeAsmRdrand<AsmRegister16> for CodeAssembler {
	#[inline]
	fn rdrand(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdrand_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdrand<AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdrand(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdrand_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdrand<AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdrand(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdrand_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdseed<AsmRegister16> for CodeAssembler {
	#[inline]
	fn rdseed(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdseed_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdseed<AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdseed(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdseed_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdseed<AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdseed(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdseed_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdshr<AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdshr(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdshr_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdshr<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rdshr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdshr_rm32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdsspd<AsmRegister32> for CodeAssembler {
	#[inline]
	fn rdsspd(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdsspd_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdsspq<AsmRegister64> for CodeAssembler {
	#[inline]
	fn rdsspq(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rdsspq_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRdtsc for CodeAssembler {
	#[inline]
	fn rdtsc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdtsc))
	}
}

#[rustfmt::skip]
impl CodeAsmRdtscp for CodeAssembler {
	#[inline]
	fn rdtscp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdtscp))
	}
}

#[rustfmt::skip]
impl CodeAsmRdudbg for CodeAssembler {
	#[inline]
	fn rdudbg(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rdudbg))
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F0D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F0D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F0D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F0D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F0D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f0d<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f0d(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F0D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F18, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F18, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F18, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F18, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F18, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f18<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f18(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F18, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F19, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F19, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F19, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F19, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F19, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f19<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f19(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F19, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1A, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1A, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1A, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1A, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1A, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1a<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1a(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1A, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1B, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1B, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1B, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1B, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1B, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1b<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1b(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1B, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1C, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1C, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1C, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1C, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1C, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1c<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1c(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1C, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1D, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1d<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1d(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1D, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1E, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1E, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1E, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1E, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1E, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1e<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1e(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1E, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1F, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm16_r16_0F1F, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1F, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm32_r32_0F1F, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1F, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmReservednop_0f1f<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn reservednop_0f1f(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Reservednop_rm64_r64_0F1F, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRet for CodeAssembler {
	fn ret(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retnq
		} else if self.bitness() >= 32 {
			Code::Retnd
		} else {
			Code::Retnw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmRet1<i32> for CodeAssembler {
	fn ret_1(&mut self, op0: i32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retnq_imm16
		} else if self.bitness() >= 32 {
			Code::Retnd_imm16
		} else {
			Code::Retnw_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRet1<u32> for CodeAssembler {
	fn ret_1(&mut self, op0: u32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retnq_imm16
		} else if self.bitness() >= 32 {
			Code::Retnd_imm16
		} else {
			Code::Retnw_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRetf for CodeAssembler {
	fn retf(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retfq
		} else if self.bitness() >= 32 {
			Code::Retfd
		} else {
			Code::Retfw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmRetf1<i32> for CodeAssembler {
	fn retf_1(&mut self, op0: i32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retfq_imm16
		} else if self.bitness() >= 32 {
			Code::Retfd_imm16
		} else {
			Code::Retfw_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRetf1<u32> for CodeAssembler {
	fn retf_1(&mut self, op0: u32) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Retfq_imm16
		} else if self.bitness() >= 32 {
			Code::Retfd_imm16
		} else {
			Code::Retfw_imm16
		};
		self.add_instr(Instruction::with1(code, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRmpadjust for CodeAssembler {
	#[inline]
	fn rmpadjust(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rmpadjust))
	}
}

#[rustfmt::skip]
impl CodeAsmRmpquery for CodeAssembler {
	#[inline]
	fn rmpquery(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rmpquery))
	}
}

#[rustfmt::skip]
impl CodeAsmRmpupdate for CodeAssembler {
	#[inline]
	fn rmpupdate(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rmpupdate))
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rol_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rol_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rol_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rol_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	fn rol(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Rol_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rol_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rol_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rol_rm8_CL
		} else {
			return Err(IcedError::new("rol: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm8_1 } else { Code::Rol_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm16_1 } else { Code::Rol_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm32_1 } else { Code::Rol_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm64_1 } else { Code::Rol_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmMemoryOperand, i32> for CodeAssembler {
	fn rol(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rol_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rol_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rol_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rol_rm8_1
			} else {
				return Err(IcedError::new("rol: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rol_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rol_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rol_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rol_rm8_imm8
		} else {
			return Err(IcedError::new("rol: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm8_1 } else { Code::Rol_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm16_1 } else { Code::Rol_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm32_1 } else { Code::Rol_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn rol(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Rol_rm64_1 } else { Code::Rol_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRol<AsmMemoryOperand, u32> for CodeAssembler {
	fn rol(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Rol_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Rol_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Rol_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Rol_rm8_1
			} else {
				return Err(IcedError::new("rol: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Rol_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Rol_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Rol_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Rol_rm8_imm8
		} else {
			return Err(IcedError::new("rol: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ror_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ror_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ror_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ror_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	fn ror(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Ror_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Ror_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ror_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Ror_rm8_CL
		} else {
			return Err(IcedError::new("ror: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm8_1 } else { Code::Ror_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm16_1 } else { Code::Ror_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm32_1 } else { Code::Ror_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm64_1 } else { Code::Ror_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmMemoryOperand, i32> for CodeAssembler {
	fn ror(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Ror_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Ror_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Ror_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Ror_rm8_1
			} else {
				return Err(IcedError::new("ror: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Ror_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Ror_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ror_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Ror_rm8_imm8
		} else {
			return Err(IcedError::new("ror: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm8_1 } else { Code::Ror_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm16_1 } else { Code::Ror_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm32_1 } else { Code::Ror_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn ror(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Ror_rm64_1 } else { Code::Ror_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRor<AsmMemoryOperand, u32> for CodeAssembler {
	fn ror(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Ror_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Ror_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Ror_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Ror_rm8_1
			} else {
				return Err(IcedError::new("ror: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Ror_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Ror_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Ror_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Ror_rm8_imm8
		} else {
			return Err(IcedError::new("ror: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<AsmRegister32, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r32_rm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<AsmRegister64, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r64_rm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<AsmRegister32, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r32_rm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<AsmRegister64, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r64_rm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<AsmRegister32, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r32_rm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<AsmRegister64, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r64_rm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<AsmRegister32, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r32_rm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRorx<AsmRegister64, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn rorx(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Rorx_r64_rm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundpd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn roundpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundpd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn roundpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundpd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn roundpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundpd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn roundpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn roundps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn roundps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn roundps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn roundps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundsd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn roundsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundsd_xmm_xmmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundsd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn roundsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundsd_xmm_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundsd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn roundsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundsd_xmm_xmmm64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundsd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn roundsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundsd_xmm_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundss<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn roundss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundss_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundss<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn roundss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundss_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundss<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn roundss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundss_xmm_xmmm32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRoundss<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn roundss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Roundss_xmm_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsdc<AsmRegisterSegment, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsdc(&mut self, op0: AsmRegisterSegment, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsdc_Sreg_m80, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsldt<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsldt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rsldt_m80, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsm for CodeAssembler {
	#[inline]
	fn rsm(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Rsm))
	}
}

#[rustfmt::skip]
impl CodeAsmRsqrtps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn rsqrtps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsqrtps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsqrtps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsqrtps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsqrtps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsqrtss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn rsqrtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsqrtss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsqrtss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsqrtss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Rsqrtss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRstorssp<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rstorssp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rstorssp_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmRsts<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn rsts(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Rsts_m80, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSahf for CodeAssembler {
	#[inline]
	fn sahf(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sahf))
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sal_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sal_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sal_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sal_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	fn sal(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Sal_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sal_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sal_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sal_rm8_CL
		} else {
			return Err(IcedError::new("sal: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm8_1 } else { Code::Sal_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm16_1 } else { Code::Sal_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm32_1 } else { Code::Sal_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm64_1 } else { Code::Sal_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmMemoryOperand, i32> for CodeAssembler {
	fn sal(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Sal_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Sal_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Sal_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Sal_rm8_1
			} else {
				return Err(IcedError::new("sal: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Sal_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sal_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sal_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sal_rm8_imm8
		} else {
			return Err(IcedError::new("sal: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm8_1 } else { Code::Sal_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm16_1 } else { Code::Sal_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm32_1 } else { Code::Sal_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn sal(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sal_rm64_1 } else { Code::Sal_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSal<AsmMemoryOperand, u32> for CodeAssembler {
	fn sal(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Sal_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Sal_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Sal_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Sal_rm8_1
			} else {
				return Err(IcedError::new("sal: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Sal_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sal_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sal_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sal_rm8_imm8
		} else {
			return Err(IcedError::new("sal: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSalc for CodeAssembler {
	#[inline]
	fn salc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Salc))
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sar_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sar_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sar_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sar_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	fn sar(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Sar_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sar_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sar_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sar_rm8_CL
		} else {
			return Err(IcedError::new("sar: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm8_1 } else { Code::Sar_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm16_1 } else { Code::Sar_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm32_1 } else { Code::Sar_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm64_1 } else { Code::Sar_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmMemoryOperand, i32> for CodeAssembler {
	fn sar(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Sar_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Sar_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Sar_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Sar_rm8_1
			} else {
				return Err(IcedError::new("sar: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Sar_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sar_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sar_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sar_rm8_imm8
		} else {
			return Err(IcedError::new("sar: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm8_1 } else { Code::Sar_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm16_1 } else { Code::Sar_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm32_1 } else { Code::Sar_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn sar(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Sar_rm64_1 } else { Code::Sar_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSar<AsmMemoryOperand, u32> for CodeAssembler {
	fn sar(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Sar_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Sar_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Sar_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Sar_rm8_1
			} else {
				return Err(IcedError::new("sar: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Sar_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Sar_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Sar_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sar_rm8_imm8
		} else {
			return Err(IcedError::new("sar: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSarx<AsmRegister32, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn sarx(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Sarx_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSarx<AsmRegister32, AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn sarx(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Sarx_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSarx<AsmRegister64, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn sarx(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Sarx_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSarx<AsmRegister64, AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn sarx(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Sarx_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSaveprevssp for CodeAssembler {
	#[inline]
	fn saveprevssp(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Saveprevssp))
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sbb_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Sbb_AL_imm8 } else { Code::Sbb_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister16, i32> for CodeAssembler {
	fn sbb(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Sbb_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sbb_rm16_imm8
		} else {
			Code::Sbb_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister32, i32> for CodeAssembler {
	fn sbb(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Sbb_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sbb_rm32_imm8
		} else {
			Code::Sbb_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister64, i32> for CodeAssembler {
	fn sbb(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Sbb_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sbb_rm64_imm8
		} else {
			Code::Sbb_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmMemoryOperand, i32> for CodeAssembler {
	fn sbb(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sbb_rm64_imm8 } else { Code::Sbb_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sbb_rm32_imm8 } else { Code::Sbb_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sbb_rm16_imm8 } else { Code::Sbb_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sbb_rm8_imm8
		} else {
			return Err(IcedError::new("sbb: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn sbb(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Sbb_AL_imm8 } else { Code::Sbb_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister16, u32> for CodeAssembler {
	fn sbb(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Sbb_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Sbb_rm16_imm8
		} else {
			Code::Sbb_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmRegister32, u32> for CodeAssembler {
	fn sbb(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Sbb_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Sbb_rm32_imm8
		} else {
			Code::Sbb_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSbb<AsmMemoryOperand, u32> for CodeAssembler {
	fn sbb(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Sbb_rm32_imm8 } else { Code::Sbb_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Sbb_rm16_imm8 } else { Code::Sbb_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sbb_rm8_imm8
		} else {
			return Err(IcedError::new("sbb: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmScasb for CodeAssembler {
	#[inline]
	fn scasb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_scasb(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmScasd for CodeAssembler {
	#[inline]
	fn scasd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_scasd(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmScasq for CodeAssembler {
	#[inline]
	fn scasq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_scasq(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmScasw for CodeAssembler {
	#[inline]
	fn scasw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_scasw(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSeamcall for CodeAssembler {
	#[inline]
	fn seamcall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Seamcall))
	}
}

#[rustfmt::skip]
impl CodeAsmSeamops for CodeAssembler {
	#[inline]
	fn seamops(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Seamops))
	}
}

#[rustfmt::skip]
impl CodeAsmSeamret for CodeAssembler {
	#[inline]
	fn seamret(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Seamret))
	}
}

#[rustfmt::skip]
impl CodeAsmSenduipi<AsmRegister64> for CodeAssembler {
	#[inline]
	fn senduipi(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Senduipi_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSerialize for CodeAssembler {
	#[inline]
	fn serialize(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Serialize))
	}
}

#[rustfmt::skip]
impl CodeAsmSeta<AsmRegister8> for CodeAssembler {
	#[inline]
	fn seta(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seta_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSeta<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn seta(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seta_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetae<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setae(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setae_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetae<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setae(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setae_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetb<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setb(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setb_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetb<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setb(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setb_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetbe<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setbe(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setbe_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetbe<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setbe(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setbe_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetc<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setc(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setb_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetc<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setc(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setb_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSete<AsmRegister8> for CodeAssembler {
	#[inline]
	fn sete(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sete_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSete<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sete(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sete_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetg<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setg(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setg_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetg<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setg(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setg_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetge<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setge(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setge_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetge<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setge(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setge_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetl<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setl(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setl_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetl<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setl(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setl_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetle<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setle(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setle_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetle<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setle(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setle_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetna<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setna(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setbe_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetna<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setna(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setbe_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnae<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnae(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setb_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnae<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnae(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setb_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnb<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnb(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setae_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnb<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnb(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setae_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnbe<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnbe(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seta_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnbe<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnbe(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seta_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnc<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnc(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setae_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnc<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnc(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setae_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetne<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setne(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setne_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetne<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setne(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setne_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetng<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setng(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setle_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetng<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setng(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setle_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnge<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnge(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setl_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnge<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnge(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setl_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnl<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnl(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setge_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnl<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnl(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setge_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnle<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnle(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setg_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnle<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnle(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setg_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetno<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setno(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setno_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetno<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setno(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setno_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnp<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnp(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setnp_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnp<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setnp_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetns<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setns(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setns_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetns<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setns(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setns_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnz<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setnz(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setne_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetnz<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setnz(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setne_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSeto<AsmRegister8> for CodeAssembler {
	#[inline]
	fn seto(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seto_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSeto<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn seto(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Seto_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetp<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setp(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setp_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetp<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setp(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setp_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetpe<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setpe(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setp_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetpe<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setpe(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setp_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetpo<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setpo(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setnp_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetpo<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setpo(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Setnp_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSets<AsmRegister8> for CodeAssembler {
	#[inline]
	fn sets(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sets_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSets<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sets(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sets_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetssbsy for CodeAssembler {
	#[inline]
	fn setssbsy(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Setssbsy))
	}
}

#[rustfmt::skip]
impl CodeAsmSetz<AsmRegister8> for CodeAssembler {
	#[inline]
	fn setz(&mut self, op0: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sete_rm8, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSetz<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn setz(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sete_rm8, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSfence for CodeAssembler {
	#[inline]
	fn sfence(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sfence))
	}
}

#[rustfmt::skip]
impl CodeAsmSgdt<AsmMemoryOperand> for CodeAssembler {
	fn sgdt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Sgdt_m1664
		} else if self.bitness() >= 32 {
			Code::Sgdt_m1632
		} else {
			Code::Sgdt_m1632_16
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1msg1<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha1msg1(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1msg1_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1msg1<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha1msg1(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1msg1_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1msg2<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha1msg2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1msg2_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1msg2<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha1msg2(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1msg2_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1nexte<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha1nexte(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1nexte_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1nexte<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha1nexte(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha1nexte_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1rnds4<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn sha1rnds4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Sha1rnds4_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1rnds4<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn sha1rnds4(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Sha1rnds4_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1rnds4<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn sha1rnds4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Sha1rnds4_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha1rnds4<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn sha1rnds4(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Sha1rnds4_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256msg1<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha256msg1(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256msg1_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256msg1<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha256msg1(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256msg1_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256msg2<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha256msg2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256msg2_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256msg2<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha256msg2(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256msg2_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256rnds2<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sha256rnds2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256rnds2_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSha256rnds2<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sha256rnds2(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sha256rnds2_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shl_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shl_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shl_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shl_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	fn shl(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Shl_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shl_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shl_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shl_rm8_CL
		} else {
			return Err(IcedError::new("shl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm8_1 } else { Code::Shl_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm16_1 } else { Code::Shl_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm32_1 } else { Code::Shl_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm64_1 } else { Code::Shl_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmMemoryOperand, i32> for CodeAssembler {
	fn shl(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Shl_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Shl_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Shl_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Shl_rm8_1
			} else {
				return Err(IcedError::new("shl: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Shl_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shl_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shl_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shl_rm8_imm8
		} else {
			return Err(IcedError::new("shl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm8_1 } else { Code::Shl_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm16_1 } else { Code::Shl_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm32_1 } else { Code::Shl_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shl(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shl_rm64_1 } else { Code::Shl_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShl<AsmMemoryOperand, u32> for CodeAssembler {
	fn shl(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Shl_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Shl_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Shl_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Shl_rm8_1
			} else {
				return Err(IcedError::new("shl: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Shl_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shl_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shl_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shl_rm8_imm8
		} else {
			return Err(IcedError::new("shl: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmRegister16, AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmRegister16, op1: AsmRegister16, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmMemoryOperand, AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmRegister32, AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmMemoryOperand, AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmRegister64, AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmMemoryOperand, AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmRegister16, AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmRegister16, op1: AsmRegister16, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmMemoryOperand, AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmRegister32, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmMemoryOperand, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmRegister64, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmMemoryOperand, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmRegister16, AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmRegister16, op1: AsmRegister16, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmMemoryOperand, AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm16_r16_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmRegister32, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmMemoryOperand, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm32_r32_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmRegister64, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShld<AsmMemoryOperand, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shld(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shld_rm64_r64_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShlx<AsmRegister32, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn shlx(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shlx_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShlx<AsmRegister32, AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn shlx(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shlx_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShlx<AsmRegister64, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn shlx(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shlx_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShlx<AsmRegister64, AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn shlx(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shlx_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shr_rm8_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister16, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shr_rm16_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister32, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shr_rm32_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister64, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Shr_rm64_CL, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	fn shr(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Shr_rm64_CL
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shr_rm32_CL
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shr_rm16_CL
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shr_rm8_CL
		} else {
			return Err(IcedError::new("shr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm8_1 } else { Code::Shr_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm16_1 } else { Code::Shr_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm32_1 } else { Code::Shr_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm64_1 } else { Code::Shr_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmMemoryOperand, i32> for CodeAssembler {
	fn shr(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Shr_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Shr_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Shr_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Shr_rm8_1
			} else {
				return Err(IcedError::new("shr: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Shr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shr_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shr_rm8_imm8
		} else {
			return Err(IcedError::new("shr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm8_1 } else { Code::Shr_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm16_1 } else { Code::Shr_rm16_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm32_1 } else { Code::Shr_rm32_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shr(&mut self, op0: AsmRegister64, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 { Code::Shr_rm64_1 } else { Code::Shr_rm64_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShr<AsmMemoryOperand, u32> for CodeAssembler {
	fn shr(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op1 == 1 {
			if op0.size() == MemoryOperandSize::Qword {
				Code::Shr_rm64_1
			} else if op0.size() == MemoryOperandSize::Dword {
				Code::Shr_rm32_1
			} else if op0.size() == MemoryOperandSize::Word {
				Code::Shr_rm16_1
			} else if op0.size() == MemoryOperandSize::Byte {
				Code::Shr_rm8_1
			} else {
				return Err(IcedError::new("shr: invalid operands"));
			}
		} else if op0.size() == MemoryOperandSize::Qword {
			Code::Shr_rm64_imm8
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Shr_rm32_imm8
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Shr_rm16_imm8
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Shr_rm8_imm8
		} else {
			return Err(IcedError::new("shr: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmRegister16, AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmRegister16, op1: AsmRegister16, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmMemoryOperand, AsmRegister16, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmRegister32, AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmMemoryOperand, AsmRegister32, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmRegister64, AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_CL, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmMemoryOperand, AsmRegister64, AsmRegister8> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_CL, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmRegister16, AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmRegister16, op1: AsmRegister16, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmMemoryOperand, AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmRegister32, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmMemoryOperand, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmRegister64, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmMemoryOperand, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmRegister16, AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmRegister16, op1: AsmRegister16, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmMemoryOperand, AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm16_r16_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmRegister32, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmMemoryOperand, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm32_r32_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmRegister64, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrd<AsmMemoryOperand, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn shrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shrd_rm64_r64_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrx<AsmRegister32, AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn shrx(&mut self, op0: AsmRegister32, op1: AsmRegister32, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shrx_r32_rm32_r32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrx<AsmRegister32, AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn shrx(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shrx_r32_rm32_r32, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrx<AsmRegister64, AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn shrx(&mut self, op0: AsmRegister64, op1: AsmRegister64, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shrx_r64_rm64_r64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShrx<AsmRegister64, AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn shrx(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Shrx_r64_rm64_r64, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufpd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn shufpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufpd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn shufpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufpd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn shufpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufpd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn shufpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn shufps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn shufps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn shufps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmShufps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn shufps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::Shufps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSidt<AsmMemoryOperand> for CodeAssembler {
	fn sidt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Sidt_m1664
		} else if self.bitness() >= 32 {
			Code::Sidt_m1632
		} else {
			Code::Sidt_m1632_16
		};
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSkinit for CodeAssembler {
	#[inline]
	fn skinit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Skinit))
	}
}

#[rustfmt::skip]
impl CodeAsmSldt<AsmRegister16> for CodeAssembler {
	#[inline]
	fn sldt(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sldt_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSldt<AsmRegister32> for CodeAssembler {
	#[inline]
	fn sldt(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sldt_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSldt<AsmRegister64> for CodeAssembler {
	#[inline]
	fn sldt(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Sldt_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSldt<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sldt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Sldt_r32m16 } else { Code::Sldt_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSlwpcb<AsmRegister32> for CodeAssembler {
	#[inline]
	fn slwpcb(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::XOP_Slwpcb_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSlwpcb<AsmRegister64> for CodeAssembler {
	#[inline]
	fn slwpcb(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::XOP_Slwpcb_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSmint for CodeAssembler {
	#[inline]
	fn smint(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Smint))
	}
}

#[rustfmt::skip]
impl CodeAsmSmint_0f7e for CodeAssembler {
	#[inline]
	fn smint_0f7e(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Smint_0F7E))
	}
}

#[rustfmt::skip]
impl CodeAsmSmsw<AsmRegister16> for CodeAssembler {
	#[inline]
	fn smsw(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Smsw_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSmsw<AsmRegister32> for CodeAssembler {
	#[inline]
	fn smsw(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Smsw_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSmsw<AsmRegister64> for CodeAssembler {
	#[inline]
	fn smsw(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Smsw_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSmsw<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn smsw(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Smsw_r32m16 } else { Code::Smsw_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sqrtpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sqrtpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sqrtps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sqrtps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sqrtsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sqrtsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn sqrtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSqrtss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sqrtss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sqrtss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmStac for CodeAssembler {
	#[inline]
	fn stac(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Stac))
	}
}

#[rustfmt::skip]
impl CodeAsmStc for CodeAssembler {
	#[inline]
	fn stc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Stc))
	}
}

#[rustfmt::skip]
impl CodeAsmStd for CodeAssembler {
	#[inline]
	fn std(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Std))
	}
}

#[rustfmt::skip]
impl CodeAsmStgi for CodeAssembler {
	#[inline]
	fn stgi(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Stgi))
	}
}

#[rustfmt::skip]
impl CodeAsmSti for CodeAssembler {
	#[inline]
	fn sti(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sti))
	}
}

#[rustfmt::skip]
impl CodeAsmStmxcsr<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn stmxcsr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Stmxcsr_m32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmStosb for CodeAssembler {
	#[inline]
	fn stosb(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_stosb(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmStosd for CodeAssembler {
	#[inline]
	fn stosd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_stosd(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmStosq for CodeAssembler {
	#[inline]
	fn stosq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_stosq(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmStosw for CodeAssembler {
	#[inline]
	fn stosw(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_stosw(self.bitness(), RepPrefixKind::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmStr<AsmRegister16> for CodeAssembler {
	#[inline]
	fn str(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Str_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmStr<AsmRegister32> for CodeAssembler {
	#[inline]
	fn str(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Str_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmStr<AsmRegister64> for CodeAssembler {
	#[inline]
	fn str(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Str_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmStr<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn str(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Str_r32m16 } else { Code::Str_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSttilecfg<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sttilecfg(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Sttilecfg_m512, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmStui for CodeAssembler {
	#[inline]
	fn stui(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Stui))
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Sub_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Sub_AL_imm8 } else { Code::Sub_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister16, i32> for CodeAssembler {
	fn sub(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Sub_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sub_rm16_imm8
		} else {
			Code::Sub_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister32, i32> for CodeAssembler {
	fn sub(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Sub_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sub_rm32_imm8
		} else {
			Code::Sub_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister64, i32> for CodeAssembler {
	fn sub(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Sub_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Sub_rm64_imm8
		} else {
			Code::Sub_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmMemoryOperand, i32> for CodeAssembler {
	fn sub(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sub_rm64_imm8 } else { Code::Sub_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sub_rm32_imm8 } else { Code::Sub_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Sub_rm16_imm8 } else { Code::Sub_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sub_rm8_imm8
		} else {
			return Err(IcedError::new("sub: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn sub(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Sub_AL_imm8 } else { Code::Sub_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister16, u32> for CodeAssembler {
	fn sub(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Sub_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Sub_rm16_imm8
		} else {
			Code::Sub_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmRegister32, u32> for CodeAssembler {
	fn sub(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Sub_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Sub_rm32_imm8
		} else {
			Code::Sub_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSub<AsmMemoryOperand, u32> for CodeAssembler {
	fn sub(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Sub_rm32_imm8 } else { Code::Sub_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Sub_rm16_imm8 } else { Code::Sub_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Sub_rm8_imm8
		} else {
			return Err(IcedError::new("sub: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn subpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn subpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn subps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn subps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn subsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn subsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn subss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSubss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn subss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Subss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSvdc<AsmMemoryOperand, AsmRegisterSegment> for CodeAssembler {
	#[inline]
	fn svdc(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterSegment) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Svdc_m80_Sreg, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmSvldt<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn svldt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Svldt_m80, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSvts<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn svts(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Svts_m80, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmSwapgs for CodeAssembler {
	#[inline]
	fn swapgs(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Swapgs))
	}
}

#[rustfmt::skip]
impl CodeAsmSyscall for CodeAssembler {
	#[inline]
	fn syscall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Syscall))
	}
}

#[rustfmt::skip]
impl CodeAsmSysenter for CodeAssembler {
	#[inline]
	fn sysenter(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysenter))
	}
}

#[rustfmt::skip]
impl CodeAsmSysexit for CodeAssembler {
	#[inline]
	fn sysexit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysexitd))
	}
}

#[rustfmt::skip]
impl CodeAsmSysexitq for CodeAssembler {
	#[inline]
	fn sysexitq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysexitq))
	}
}

#[rustfmt::skip]
impl CodeAsmSysret for CodeAssembler {
	#[inline]
	fn sysret(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysretd))
	}
}

#[rustfmt::skip]
impl CodeAsmSysretq for CodeAssembler {
	#[inline]
	fn sysretq(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Sysretq))
	}
}

#[rustfmt::skip]
impl CodeAsmT1mskc<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn t1mskc(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_T1mskc_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmT1mskc<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn t1mskc(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_T1mskc_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmT1mskc<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn t1mskc(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_T1mskc_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmT1mskc<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn t1mskc(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_T1mskc_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTcmmimfp16ps<AsmRegisterTmm, AsmRegisterTmm, AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tcmmimfp16ps(&mut self, op0: AsmRegisterTmm, op1: AsmRegisterTmm, op2: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tcmmimfp16ps_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTcmmrlfp16ps<AsmRegisterTmm, AsmRegisterTmm, AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tcmmrlfp16ps(&mut self, op0: AsmRegisterTmm, op1: AsmRegisterTmm, op2: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tcmmrlfp16ps_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdcall for CodeAssembler {
	#[inline]
	fn tdcall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Tdcall))
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbf16ps<AsmRegisterTmm, AsmRegisterTmm, AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbf16ps(&mut self, op0: AsmRegisterTmm, op1: AsmRegisterTmm, op2: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbf16ps_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbssd<AsmRegisterTmm, AsmRegisterTmm, AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbssd(&mut self, op0: AsmRegisterTmm, op1: AsmRegisterTmm, op2: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbssd_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbsud<AsmRegisterTmm, AsmRegisterTmm, AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbsud(&mut self, op0: AsmRegisterTmm, op1: AsmRegisterTmm, op2: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbsud_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbusd<AsmRegisterTmm, AsmRegisterTmm, AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbusd(&mut self, op0: AsmRegisterTmm, op1: AsmRegisterTmm, op2: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbusd_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdpbuud<AsmRegisterTmm, AsmRegisterTmm, AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpbuud(&mut self, op0: AsmRegisterTmm, op1: AsmRegisterTmm, op2: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpbuud_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTdpfp16ps<AsmRegisterTmm, AsmRegisterTmm, AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tdpfp16ps(&mut self, op0: AsmRegisterTmm, op1: AsmRegisterTmm, op2: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Tdpfp16ps_tmm_tmm_tmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Test_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Test_AL_imm8 } else { Code::Test_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister16, i32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX { Code::Test_AX_imm16 } else { Code::Test_rm16_imm16 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX { Code::Test_EAX_imm32 } else { Code::Test_rm32_imm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX { Code::Test_RAX_imm32 } else { Code::Test_rm64_imm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmMemoryOperand, i32> for CodeAssembler {
	fn test(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			Code::Test_rm64_imm32
		} else if op0.size() == MemoryOperandSize::Dword {
			Code::Test_rm32_imm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Test_rm16_imm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Test_rm8_imm8
		} else {
			return Err(IcedError::new("test: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Test_AL_imm8 } else { Code::Test_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister16, u32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX { Code::Test_AX_imm16 } else { Code::Test_rm16_imm16 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn test(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX { Code::Test_EAX_imm32 } else { Code::Test_rm32_imm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTest<AsmMemoryOperand, u32> for CodeAssembler {
	fn test(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			Code::Test_rm32_imm32
		} else if op0.size() == MemoryOperandSize::Word {
			Code::Test_rm16_imm16
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Test_rm8_imm8
		} else {
			return Err(IcedError::new("test: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmTestui for CodeAssembler {
	#[inline]
	fn testui(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Testui))
	}
}

#[rustfmt::skip]
impl CodeAsmTileloadd<AsmRegisterTmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tileloadd(&mut self, op0: AsmRegisterTmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Tileloadd_tmm_sibmem, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTileloaddt1<AsmRegisterTmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tileloaddt1(&mut self, op0: AsmRegisterTmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Tileloaddt1_tmm_sibmem, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTilerelease for CodeAssembler {
	#[inline]
	fn tilerelease(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::VEX_Tilerelease))
	}
}

#[rustfmt::skip]
impl CodeAsmTilestored<AsmMemoryOperand, AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tilestored(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Tilestored_sibmem_tmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTilezero<AsmRegisterTmm> for CodeAssembler {
	#[inline]
	fn tilezero(&mut self, op0: AsmRegisterTmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Tilezero_tmm, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTlbsync for CodeAssembler {
	#[inline]
	fn tlbsync(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Tlbsync))
	}
}

#[rustfmt::skip]
impl CodeAsmTpause<AsmRegister32> for CodeAssembler {
	#[inline]
	fn tpause(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Tpause_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTpause<AsmRegister64> for CodeAssembler {
	#[inline]
	fn tpause(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Tpause_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzcnt<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzcnt(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Tzcnt_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzmsk<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn tzmsk(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Tzmsk_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzmsk<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn tzmsk(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Tzmsk_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzmsk<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzmsk(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Tzmsk_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmTzmsk<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn tzmsk(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Tzmsk_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUcomisd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn ucomisd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ucomisd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUcomisd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ucomisd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ucomisd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUcomiss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn ucomiss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ucomiss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUcomiss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ucomiss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ucomiss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd0 for CodeAssembler {
	#[inline]
	fn ud0(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Ud0))
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd02<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud0_2(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud0_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd1<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn ud1(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Ud1_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUd2 for CodeAssembler {
	#[inline]
	fn ud2(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Ud2))
	}
}

#[rustfmt::skip]
impl CodeAsmUiret for CodeAssembler {
	#[inline]
	fn uiret(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Uiret))
	}
}

#[rustfmt::skip]
impl CodeAsmUmonitor<AsmRegister16> for CodeAssembler {
	#[inline]
	fn umonitor(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umonitor_r16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmonitor<AsmRegister32> for CodeAssembler {
	#[inline]
	fn umonitor(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umonitor_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmonitor<AsmRegister64> for CodeAssembler {
	#[inline]
	fn umonitor(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umonitor_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmov<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn umov(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Umov_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmwait<AsmRegister32> for CodeAssembler {
	#[inline]
	fn umwait(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umwait_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUmwait<AsmRegister64> for CodeAssembler {
	#[inline]
	fn umwait(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Umwait_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpckhpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn unpckhpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpckhpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpckhpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn unpckhpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpckhpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpckhps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn unpckhps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpckhps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpckhps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn unpckhps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpckhps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpcklpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn unpcklpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpcklpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpcklpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn unpcklpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpcklpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpcklps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn unpcklps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpcklps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmUnpcklps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn unpcklps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Unpcklps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmV4fmaddps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn v4fmaddps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_V4fmaddps_zmm_k1z_zmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmV4fmaddss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn v4fmaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_V4fmaddss_xmm_k1z_xmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmV4fnmaddps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn v4fnmaddps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_V4fnmaddps_zmm_k1z_zmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmV4fnmaddss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn v4fnmaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_V4fnmaddss_xmm_k1z_xmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaddpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaddpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaddpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vaddpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vaddpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vaddpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vaddpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaddps_xmm_xmm_xmmm128 } else { Code::EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaddps_ymm_ymm_ymmm256 } else { Code::EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaddps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vaddps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vaddps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vaddps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vaddps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaddsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vaddsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaddsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vaddsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vaddsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaddss_xmm_xmm_xmmm32 } else { Code::EVEX_Vaddss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaddss_xmm_xmm_xmmm32 } else { Code::EVEX_Vaddss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaddsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaddsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaddsubps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaddsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaddsubps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesdec_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesdec_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesdec_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesdec_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesdec_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesdec_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesdec_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesdec_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesdec_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdec<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdec(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesdec_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesdeclast_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesdeclast_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesdeclast_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesdeclast_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesdeclast_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesdeclast_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesdeclast_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesdeclast_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesdeclast_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesdeclast<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesdeclast(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesdeclast_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesenc_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesenc_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesenc_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesenc_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesenc_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesenc_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesenc_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesenc_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesenc_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenc<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenc(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesenc_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesenclast_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesenclast_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesenclast_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesenclast_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesenclast_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesenclast_xmm_xmm_xmmm128 } else { Code::EVEX_Vaesenclast_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vaesenclast_ymm_ymm_ymmm256 } else { Code::EVEX_Vaesenclast_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesenclast<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesenclast(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vaesenclast_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesimc<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vaesimc(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vaesimc_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaesimc<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vaesimc(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vaesimc_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaeskeygenassist<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vaeskeygenassist(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaeskeygenassist<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vaeskeygenassist(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaeskeygenassist<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vaeskeygenassist(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVaeskeygenassist<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vaeskeygenassist(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vaeskeygenassist_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmValignq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn valignq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Valignq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vandnpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vandnpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vandnpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vandnpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vandnpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandnpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vandnpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vandnpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vandnpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vandnpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vandnpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vandnpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vandnpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandnpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vandnps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vandnps_xmm_xmm_xmmm128 } else { Code::EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vandnps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vandnps_ymm_ymm_ymmm256 } else { Code::EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vandnps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandnps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vandnps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vandnps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vandnps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vandnps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vandnps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vandnps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandnps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vandnps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandnps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vandpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vandpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vandpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vandpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vandpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vandpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vandpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vandpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vandpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vandpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vandpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vandpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vandps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vandps_xmm_xmm_xmmm128 } else { Code::EVEX_Vandps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vandps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vandps_ymm_ymm_ymmm256 } else { Code::EVEX_Vandps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vandps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vandps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vandps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vandps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vandps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vandps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vandps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vandps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVandps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vandps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vandps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVbcstnebf162ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbcstnebf162ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vbcstnebf162ps_xmm_m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVbcstnebf162ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbcstnebf162ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vbcstnebf162ps_ymm_m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVbcstnesh2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbcstnesh2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vbcstnesh2ps_xmm_m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVbcstnesh2ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbcstnesh2ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vbcstnesh2ps_ymm_m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendmps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vblendmps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vblendmps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vblendpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendpd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vblendps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendvpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendvpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendvpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendvpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendvps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vblendvps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendvps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVblendvps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vblendvps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vblendvps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf128<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf128(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vbroadcastf128_ymm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x2<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x2_ymm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x2<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x2_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x2<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x2(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x2_ymm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x2<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x2(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x2_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x4<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x4(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x4_ymm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x4<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x4(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x4_zmm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf32x8<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf32x8(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf32x8_zmm_k1z_m256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf64x2<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf64x2(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf64x2_ymm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf64x2<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf64x2(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf64x2_zmm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastf64x4<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastf64x4(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastf64x4_zmm_k1z_m256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti128<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti128(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vbroadcasti128_ymm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_xmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_ymm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_xmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_ymm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x2<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x2(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x2_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x4<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x4(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x4_ymm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x4<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x4(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x4_zmm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti32x8<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti32x8(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti32x8_zmm_k1z_m256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti64x2<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti64x2(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti64x2_ymm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti64x2<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti64x2(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti64x2_zmm_k1z_m128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcasti64x4<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcasti64x4(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcasti64x4_zmm_k1z_m256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastsd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastsd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vbroadcastsd_ymm_xmm } else { Code::EVEX_Vbroadcastsd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastsd<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastsd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastsd_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastsd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastsd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vbroadcastsd_ymm_m64 } else { Code::EVEX_Vbroadcastsd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastsd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastsd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastsd_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vbroadcastss_xmm_xmm } else { Code::EVEX_Vbroadcastss_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vbroadcastss_ymm_xmm } else { Code::EVEX_Vbroadcastss_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastss_zmm_k1z_xmmm32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vbroadcastss_xmm_m32 } else { Code::EVEX_Vbroadcastss_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vbroadcastss_ymm_m32 } else { Code::EVEX_Vbroadcastss_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVbroadcastss<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vbroadcastss(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vbroadcastss_zmm_k1z_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ospd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ossh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ossh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_osss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_osss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_osss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 8)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_uspd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_ussh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_ussh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeq_usss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeq_usss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeq_usss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 24)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpeqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpeqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpeqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ospd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_ossh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_ossh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalse_osss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalse_osss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 27)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsepd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalseps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalseps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsesh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsess<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsess(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsess<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpfalsess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsess<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsess(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpfalsess<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpfalsess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 11)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpge_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpge_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpge_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 29)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgepd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgeps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgesh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgess<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgess(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgess<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgess<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgess(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgess<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 13)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgt_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgt_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 30)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpgtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpgtss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpgtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 14)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmple_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmple_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmple_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 18)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplepd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpleps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplesh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpless<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpless(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpless<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpless<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpless(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpless<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmplt_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmplt_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmplt_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpltss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpltss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpltss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_oqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_oqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 12)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ospd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ospd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ossh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ossh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_osss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_osss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_osss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 28)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_uspd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_ussh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_ussh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneq_usss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneq_usss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneq_usss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 20)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpneqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpneqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpneqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnge_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnge_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 25)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngepd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngeps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngeps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngesh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngess<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngess(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngess<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngess<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngess(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngess<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 9)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngt_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngt_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 26)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpngtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpngtss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpngtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 10)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnle_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnle_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 22)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlepd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnleps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnleps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlesh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnless<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnless(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnless<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnless<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnless(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnless<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnlt_uqss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnlt_uqss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 21)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpnltss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpnltss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpnltss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_spd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_ssd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_ssd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_ssd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_ssd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_ssh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_ssh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_ssh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpord_sss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpord_sss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpord_sss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 23)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpordss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpordss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpordss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmppd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmppd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmppd_kr_k1_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_xmm_xmmm128b16_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_ymm_ymmm256b16_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpph_kr_k1_zmm_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpps_kr_k1_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsd_kr_k1_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpsh_kr_k1_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vcmpss_kr_k1_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vcmpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vcmpss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_uspd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_uspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_ussh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_ussh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrue_usss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrue_usss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrue_usss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 31)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruepd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruepd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptrueps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptrueps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruesd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruesh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruesh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruess<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruess(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruess<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmptruess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruess<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruess(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmptruess<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmptruess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 15)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_spd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_spd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_ssh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_ssh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunord_sss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunord_sss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunord_sss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 19)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmppd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmppd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpph<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpph(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpps<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vcmpps(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordsd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpsh(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordsh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpsh<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpsh(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcmpunordss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vcmpss(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcmpunordss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcmpunordss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVcmpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vcmpss(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVcomisd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcomisd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcomisd_xmm_xmmm64 } else { Code::EVEX_Vcomisd_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomisd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcomisd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcomisd_xmm_xmmm64 } else { Code::EVEX_Vcomisd_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomish<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcomish(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcomish_xmm_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomish<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcomish(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcomish_xmm_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomiss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcomiss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcomiss_xmm_xmmm32 } else { Code::EVEX_Vcomiss_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcomiss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcomiss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcomiss_xmm_xmmm32 } else { Code::EVEX_Vcomiss_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompresspd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcompresspd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompresspd_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcompressps<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcompressps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcompressps_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtdq2pd_xmm_xmmm64 } else { Code::EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtdq2pd_ymm_xmmm128 } else { Code::EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvtdq2pd_xmm_xmmm64
		} else {
			Code::EVEX_Vcvtdq2pd_xmm_k1z_xmmm64b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2pd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvtdq2pd_ymm_xmmm128
		} else {
			Code::EVEX_Vcvtdq2pd_ymm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_ymm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtdq2ph_xmm_k1z_xmmm128b32
		} else {
			return Err(IcedError::new("vcvtdq2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ph<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2ph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_ymm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2phx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2phx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2phy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2phy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ph_xmm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtdq2ps_xmm_xmmm128 } else { Code::EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtdq2ps_ymm_ymmm256 } else { Code::EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtdq2ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ps_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvtdq2ps_xmm_xmmm128
		} else {
			Code::EVEX_Vcvtdq2ps_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtdq2ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvtdq2ps_ymm_ymmm256
		} else {
			Code::EVEX_Vcvtdq2ps_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtdq2ps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtdq2ps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtdq2ps_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtne2ps2bf16<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtne2ps2bf16(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtne2ps2bf16_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneebf162ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneebf162ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vcvtneebf162ps_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneebf162ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneebf162ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vcvtneebf162ps_ymm_m256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneeph2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneeph2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vcvtneeph2ps_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneeph2ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneeph2ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vcvtneeph2ps_ymm_m256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneobf162ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneobf162ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vcvtneobf162ps_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneobf162ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneobf162ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vcvtneobf162ps_ymm_m256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneoph2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneoph2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vcvtneoph2ps_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneoph2ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneoph2ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vcvtneoph2ps_ymm_m256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtneps2bf16_xmm_xmmm128 } else { Code::EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtneps2bf16_xmm_ymmm256 } else { Code::EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_ymm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtneps2bf16(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Yword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtneps2bf16_xmm_ymmm256 } else { Code::EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32 }
		} else if op1.size() == MemoryOperandSize::Xword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtneps2bf16_xmm_xmmm128 } else { Code::EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32 }
		} else {
			return Err(IcedError::new("vcvtneps2bf16: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_ymm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16x<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16x(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtneps2bf16y<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtneps2bf16y(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtneps2bf16_xmm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtpd2dq_xmm_xmmm128 } else { Code::EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtpd2dq_xmm_ymmm256 } else { Code::EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2dq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2dq_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtpd2dq_xmm_ymmm256 } else { Code::EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64 }
		} else if op1.size() == MemoryOperandSize::Xword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtpd2dq_xmm_xmmm128 } else { Code::EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64 }
		} else {
			return Err(IcedError::new("vcvtpd2dq: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2dq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2dq_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dqx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2dqx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2dq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2dqy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2dqy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2dq_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ph<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ph<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtpd2ph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtpd2ph_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtpd2ph_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtpd2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2phx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2phx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2phy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2phy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2phz<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2phz(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtpd2ps_xmm_xmmm128 } else { Code::EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtpd2ps_xmm_ymmm256 } else { Code::EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtpd2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtpd2ps_xmm_ymmm256 } else { Code::EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64 }
		} else if op1.size() == MemoryOperandSize::Xword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtpd2ps_xmm_xmmm128 } else { Code::EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64 }
		} else {
			return Err(IcedError::new("vcvtpd2ps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2psx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2psx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ps_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2psy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2psy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2ps_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2qq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2qq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2qq_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2udq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2udq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2udq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtpd2udq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtpd2udq: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2udq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udqx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2udqx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2udqy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2udqy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2udq_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtpd2uqq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtpd2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtpd2uqq_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_zmm_k1z_ymmm256b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2dq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2dq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2dq_zmm_k1z_ymmm256b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_zmm_k1z_xmmm128b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2pd_zmm_k1z_xmmm128b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtph2ps_xmm_xmmm64 } else { Code::EVEX_Vcvtph2ps_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtph2ps_ymm_xmmm128 } else { Code::EVEX_Vcvtph2ps_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2ps_zmm_k1z_ymmm256_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtph2ps_xmm_xmmm64 } else { Code::EVEX_Vcvtph2ps_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtph2ps_ymm_xmmm128 } else { Code::EVEX_Vcvtph2ps_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2ps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2ps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2ps_zmm_k1z_ymmm256_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_zmm_k1z_ymmm256b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2psx<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2psx(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2psx_zmm_k1z_ymmm256b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_zmm_k1z_xmmm128b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2qq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2qq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2qq_zmm_k1z_xmmm128b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_zmm_k1z_ymmm256b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2udq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2udq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2udq_zmm_k1z_ymmm256b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_zmm_k1z_xmmm128b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uqq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uqq_zmm_k1z_xmmm128b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2uw<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2uw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2uw_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtph2w<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtph2w(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtph2w_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2dq_xmm_xmmm128 } else { Code::EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2dq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2dq_ymm_ymmm256 } else { Code::EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtps2dq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2dq_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvtps2dq_xmm_xmmm128
		} else {
			Code::EVEX_Vcvtps2dq_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2dq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvtps2dq_ymm_ymmm256
		} else {
			Code::EVEX_Vcvtps2dq_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2dq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2dq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2dq_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2pd_xmm_xmmm64 } else { Code::EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2pd_ymm_xmmm128 } else { Code::EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2pd_zmm_k1z_ymmm256b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvtps2pd_xmm_xmmm64
		} else {
			Code::EVEX_Vcvtps2pd_xmm_k1z_xmmm64b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2pd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvtps2pd_ymm_xmmm128
		} else {
			Code::EVEX_Vcvtps2pd_ymm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2pd_zmm_k1z_ymmm256b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2ph_xmmm64_xmm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2ph_xmmm64_xmm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmRegisterXmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2ph_xmmm128_ymm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmMemoryOperand, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2ph_xmmm128_ymm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmRegisterYmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmMemoryOperand, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2ph_xmmm64_xmm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2ph_xmmm64_xmm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm64_k1z_xmm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmRegisterXmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2ph_xmmm128_ymm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmMemoryOperand, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtps2ph_xmmm128_ymm_imm8 } else { Code::EVEX_Vcvtps2ph_xmmm128_k1z_ymm_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmRegisterYmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2ph<AsmMemoryOperand, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vcvtps2ph(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtps2ph_ymmm256_k1z_zmm_imm8_sae, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2phx(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2phx(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtps2phx(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_ymm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtps2phx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtps2phx_xmm_k1z_xmmm128b32
		} else {
			return Err(IcedError::new("vcvtps2phx: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phx<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2phx(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_ymm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phxx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2phxx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2phxy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2phxy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2phx_xmm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_zmm_k1z_ymmm256b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2qq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2qq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2qq_zmm_k1z_ymmm256b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2udq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2udq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2udq_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_zmm_k1z_ymmm256b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtps2uqq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtps2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtps2uqq_zmm_k1z_ymmm256b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2pd_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ph<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ph<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtqq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtqq2ph_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtqq2ph_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtqq2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2phx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2phx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2phy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2phy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2phz<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2phz(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtqq2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtqq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtqq2ps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2psx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2psx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtqq2psy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtqq2psy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtqq2ps_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsd2sh_xmm_k1z_xmm_xmmm64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsd2sh_xmm_k1z_xmm_xmmm64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsd2si_r32_xmmm64 } else { Code::EVEX_Vcvtsd2si_r32_xmmm64_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsd2si_r64_xmmm64 } else { Code::EVEX_Vcvtsd2si_r64_xmmm64_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsd2si_r32_xmmm64 } else { Code::EVEX_Vcvtsd2si_r32_xmmm64_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsd2si_r64_xmmm64 } else { Code::EVEX_Vcvtsd2si_r64_xmmm64_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsd2ss_xmm_xmm_xmmm64 } else { Code::EVEX_Vcvtsd2ss_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsd2ss_xmm_xmm_xmmm64 } else { Code::EVEX_Vcvtsd2ss_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2usi<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2usi(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsd2usi_r32_xmmm64_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2usi<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsd2usi(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsd2usi_r64_xmmm64_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2usi<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2usi(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsd2usi_r32_xmmm64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsd2usi<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsd2usi(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsd2usi_r64_xmmm64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsh2sd_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsh2sd_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2si_r32_xmmm16_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2si_r64_xmmm16_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2si_r32_xmmm16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2si_r64_xmmm16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsh2ss_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsh2ss_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2usi<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2usi(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2usi_r32_xmmm16_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2usi<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtsh2usi(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2usi_r64_xmmm16_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2usi<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2usi(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2usi_r32_xmmm16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsh2usi<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtsh2usi(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtsh2usi_r64_xmmm16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtsi2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsi2sd_xmm_xmm_rm32 } else { Code::EVEX_Vcvtsi2sd_xmm_xmm_rm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtsi2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsi2sd_xmm_xmm_rm64 } else { Code::EVEX_Vcvtsi2sd_xmm_xmm_rm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtsi2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtsi2sd_xmm_xmm_rm64 } else { Code::EVEX_Vcvtsi2sd_xmm_xmm_rm64_er }
		} else if op2.size() == MemoryOperandSize::Dword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtsi2sd_xmm_xmm_rm32 } else { Code::EVEX_Vcvtsi2sd_xmm_xmm_rm32_er }
		} else {
			return Err(IcedError::new("vcvtsi2sd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtsi2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsi2sh_xmm_xmm_rm32_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtsi2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtsi2sh_xmm_xmm_rm64_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtsi2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			Code::EVEX_Vcvtsi2sh_xmm_xmm_rm64_er
		} else if op2.size() == MemoryOperandSize::Dword {
			Code::EVEX_Vcvtsi2sh_xmm_xmm_rm32_er
		} else {
			return Err(IcedError::new("vcvtsi2sh: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtsi2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsi2ss_xmm_xmm_rm32 } else { Code::EVEX_Vcvtsi2ss_xmm_xmm_rm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtsi2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtsi2ss_xmm_xmm_rm64 } else { Code::EVEX_Vcvtsi2ss_xmm_xmm_rm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtsi2ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtsi2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtsi2ss_xmm_xmm_rm64 } else { Code::EVEX_Vcvtsi2ss_xmm_xmm_rm64_er }
		} else if op2.size() == MemoryOperandSize::Dword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvtsi2ss_xmm_xmm_rm32 } else { Code::EVEX_Vcvtsi2ss_xmm_xmm_rm32_er }
		} else {
			return Err(IcedError::new("vcvtsi2ss: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtss2sd_xmm_xmm_xmmm32 } else { Code::EVEX_Vcvtss2sd_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtss2sd_xmm_xmm_xmmm32 } else { Code::EVEX_Vcvtss2sd_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtss2sh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtss2sh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtss2si_r32_xmmm32 } else { Code::EVEX_Vcvtss2si_r32_xmmm32_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtss2si_r64_xmmm32 } else { Code::EVEX_Vcvtss2si_r64_xmmm32_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtss2si_r32_xmmm32 } else { Code::EVEX_Vcvtss2si_r32_xmmm32_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvtss2si_r64_xmmm32 } else { Code::EVEX_Vcvtss2si_r64_xmmm32_er };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2usi<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2usi(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtss2usi_r32_xmmm32_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2usi<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtss2usi(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtss2usi_r64_xmmm32_er, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2usi<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2usi(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtss2usi_r32_xmmm32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtss2usi<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtss2usi(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtss2usi_r64_xmmm32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttpd2dq_xmm_xmmm128 } else { Code::EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttpd2dq_xmm_ymmm256 } else { Code::EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2dq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2dq_ymm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvttpd2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvttpd2dq_xmm_ymmm256 } else { Code::EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64 }
		} else if op1.size() == MemoryOperandSize::Xword {
			if self.instruction_prefer_vex() { Code::VEX_Vcvttpd2dq_xmm_xmmm128 } else { Code::EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64 }
		} else {
			return Err(IcedError::new("vcvttpd2dq: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2dq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2dq_ymm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dqx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2dqx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2dq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2dqy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2dqy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2dq_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2qq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2qq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2qq_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2udq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2udq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2udq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_ymm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvttpd2udq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvttpd2udq: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2udq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_ymm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udqx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2udqx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2udqy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2udqy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2udq_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttpd2uqq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttpd2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttpd2uqq_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_zmm_k1z_ymmm256b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2dq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2dq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2dq_zmm_k1z_ymmm256b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_zmm_k1z_xmmm128b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2qq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2qq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2qq_zmm_k1z_xmmm128b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_xmm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_ymm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_zmm_k1z_ymmm256b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_xmm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_ymm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2udq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2udq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2udq_zmm_k1z_ymmm256b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_xmm_k1z_xmmm32b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_ymm_k1z_xmmm64b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_zmm_k1z_xmmm128b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_xmm_k1z_xmmm32b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_ymm_k1z_xmmm64b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uqq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uqq_zmm_k1z_xmmm128b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_zmm_k1z_zmmm512b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2uw<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2uw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2uw_zmm_k1z_zmmm512b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_zmm_k1z_zmmm512b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttph2w<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttph2w(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttph2w_zmm_k1z_zmmm512b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2dq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttps2dq_xmm_xmmm128 } else { Code::EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttps2dq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttps2dq_ymm_ymmm256 } else { Code::EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttps2dq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2dq_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvttps2dq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvttps2dq_xmm_xmmm128
		} else {
			Code::EVEX_Vcvttps2dq_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvttps2dq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vcvttps2dq_ymm_ymmm256
		} else {
			Code::EVEX_Vcvttps2dq_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2dq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2dq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2dq_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_zmm_k1z_ymmm256b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2qq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2qq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2qq_zmm_k1z_ymmm256b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2udq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2udq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2udq_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_zmm_k1z_ymmm256b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttps2uqq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttps2uqq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttps2uqq_zmm_k1z_ymmm256b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsd2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttsd2si_r32_xmmm64 } else { Code::EVEX_Vcvttsd2si_r32_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsd2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttsd2si_r64_xmmm64 } else { Code::EVEX_Vcvttsd2si_r64_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsd2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttsd2si_r32_xmmm64 } else { Code::EVEX_Vcvttsd2si_r32_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsd2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttsd2si_r64_xmmm64 } else { Code::EVEX_Vcvttsd2si_r64_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2usi<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsd2usi(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsd2usi_r32_xmmm64_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2usi<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsd2usi(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsd2usi_r64_xmmm64_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2usi<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsd2usi(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsd2usi_r32_xmmm64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsd2usi<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsd2usi(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsd2usi_r64_xmmm64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsh2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2si_r32_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsh2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2si_r64_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsh2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2si_r32_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsh2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2si_r64_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2usi<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsh2usi(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2usi_r32_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2usi<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttsh2usi(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2usi_r64_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2usi<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsh2usi(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2usi_r32_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttsh2usi<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttsh2usi(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttsh2usi_r64_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2si<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttss2si(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttss2si_r32_xmmm32 } else { Code::EVEX_Vcvttss2si_r32_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2si<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttss2si(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttss2si_r64_xmmm32 } else { Code::EVEX_Vcvttss2si_r64_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2si<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttss2si(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttss2si_r32_xmmm32 } else { Code::EVEX_Vcvttss2si_r32_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2si<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttss2si(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vcvttss2si_r64_xmmm32 } else { Code::EVEX_Vcvttss2si_r64_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2usi<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttss2usi(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttss2usi_r32_xmmm32_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2usi<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvttss2usi(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttss2usi_r64_xmmm32_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2usi<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttss2usi(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttss2usi_r32_xmmm32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvttss2usi<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvttss2usi(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvttss2usi_r64_xmmm32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_xmm_k1z_xmmm64b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_ymm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_xmm_k1z_xmmm64b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_ymm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_ymm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtudq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtudq2ph_xmm_k1z_xmmm128b32
		} else {
			return Err(IcedError::new("vcvtudq2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ph<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2ph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_ymm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2phx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2phx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2phy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2phy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ph_xmm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtudq2ps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtudq2ps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtudq2ps_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2pd_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ph<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ph<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtuqq2ph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtuqq2ph_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtuqq2ph_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtuqq2ph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2phx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2phx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2phy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2phy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2phz<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2phz(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ph_xmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtuqq2ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64
		} else {
			return Err(IcedError::new("vcvtuqq2ps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_ymm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2psx<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2psx(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuqq2psy<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuqq2psy(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuqq2ps_xmm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtusi2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2sd_xmm_xmm_rm32_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtusi2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2sd_xmm_xmm_rm64_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtusi2sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			Code::EVEX_Vcvtusi2sd_xmm_xmm_rm64_er
		} else if op2.size() == MemoryOperandSize::Dword {
			Code::EVEX_Vcvtusi2sd_xmm_xmm_rm32_er
		} else {
			return Err(IcedError::new("vcvtusi2sd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtusi2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2sh_xmm_xmm_rm32_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtusi2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2sh_xmm_xmm_rm64_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtusi2sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			Code::EVEX_Vcvtusi2sh_xmm_xmm_rm64_er
		} else if op2.size() == MemoryOperandSize::Dword {
			Code::EVEX_Vcvtusi2sh_xmm_xmm_rm32_er
		} else {
			return Err(IcedError::new("vcvtusi2sh: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vcvtusi2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2ss_xmm_xmm_rm32_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vcvtusi2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vcvtusi2ss_xmm_xmm_rm64_er, op0.register(), op1.register(), op2.register())?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtusi2ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vcvtusi2ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.size() == MemoryOperandSize::Qword {
			Code::EVEX_Vcvtusi2ss_xmm_xmm_rm64_er
		} else if op2.size() == MemoryOperandSize::Dword {
			Code::EVEX_Vcvtusi2ss_xmm_xmm_rm32_er
		} else {
			return Err(IcedError::new("vcvtusi2ss: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtuw2ph<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtuw2ph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtuw2ph_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVcvtw2ph<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vcvtw2ph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vcvtw2ph_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdbpsadbw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdbpsadbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vdbpsadbw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vdivpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vdivpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vdivpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vdivpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vdivpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vdivpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vdivpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vdivpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vdivpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vdivpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vdivps_xmm_xmm_xmmm128 } else { Code::EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vdivps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vdivps_ymm_ymm_ymmm256 } else { Code::EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vdivps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vdivps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vdivps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vdivps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vdivps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vdivps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vdivps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vdivsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vdivsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vdivsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vdivsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdivsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdivss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vdivss_xmm_xmm_xmmm32 } else { Code::EVEX_Vdivss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdivss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdivss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vdivss_xmm_xmm_xmmm32 } else { Code::EVEX_Vdivss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdpbf16ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vdpbf16ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vdpbf16ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVdppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vdppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdppd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vdppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdppd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdppd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVdpps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vdpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vdpps_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerr<AsmRegister16> for CodeAssembler {
	#[inline]
	fn verr(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verr_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerr<AsmRegister32> for CodeAssembler {
	#[inline]
	fn verr(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verr_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerr<AsmRegister64> for CodeAssembler {
	#[inline]
	fn verr(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verr_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerr<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn verr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Verr_r32m16 } else { Code::Verr_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerw<AsmRegister16> for CodeAssembler {
	#[inline]
	fn verw(&mut self, op0: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verw_rm16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerw<AsmRegister32> for CodeAssembler {
	#[inline]
	fn verw(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verw_r32m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerw<AsmRegister64> for CodeAssembler {
	#[inline]
	fn verw(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Verw_r64m16, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVerw<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn verw(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.bitness() >= 32 { Code::Verw_r32m16 } else { Code::Verw_rm16 };
		self.add_instr(Instruction::with1(code, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVexp2pd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vexp2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexp2pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVexp2pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexp2pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexp2pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVexp2ps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vexp2ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexp2ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVexp2ps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexp2ps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexp2ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandpd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandpd_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVexpandps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vexpandps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vexpandps_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf128<AsmRegisterXmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf128(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextractf128_xmmm128_ymm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf128<AsmMemoryOperand, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf128(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextractf128_xmmm128_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf128<AsmRegisterXmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf128(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextractf128_xmmm128_ymm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf128<AsmMemoryOperand, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf128(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextractf128_xmmm128_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<AsmRegisterXmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<AsmMemoryOperand, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<AsmRegisterXmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<AsmMemoryOperand, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<AsmRegisterXmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<AsmMemoryOperand, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<AsmRegisterXmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x4<AsmMemoryOperand, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x4_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x8<AsmRegisterYmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x8(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x8<AsmMemoryOperand, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf32x8(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x8<AsmRegisterYmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x8(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf32x8<AsmMemoryOperand, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf32x8(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf32x8_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<AsmRegisterXmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<AsmMemoryOperand, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<AsmRegisterXmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<AsmMemoryOperand, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<AsmRegisterXmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<AsmMemoryOperand, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<AsmRegisterXmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x2<AsmMemoryOperand, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x2(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x2_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x4<AsmRegisterYmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x4<AsmMemoryOperand, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextractf64x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x4<AsmRegisterYmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractf64x4<AsmMemoryOperand, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextractf64x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextractf64x4_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti128<AsmRegisterXmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti128(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextracti128_xmmm128_ymm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti128<AsmMemoryOperand, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti128(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextracti128_xmmm128_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti128<AsmRegisterXmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti128(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextracti128_xmmm128_ymm_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti128<AsmMemoryOperand, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti128(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vextracti128_xmmm128_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<AsmRegisterXmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<AsmMemoryOperand, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<AsmRegisterXmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<AsmMemoryOperand, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<AsmRegisterXmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<AsmMemoryOperand, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<AsmRegisterXmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x4<AsmMemoryOperand, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x4_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x8<AsmRegisterYmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x8(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x8<AsmMemoryOperand, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti32x8(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x8<AsmRegisterYmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x8(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti32x8<AsmMemoryOperand, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti32x8(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti32x8_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<AsmRegisterXmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<AsmMemoryOperand, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<AsmRegisterXmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<AsmMemoryOperand, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<AsmRegisterXmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<AsmMemoryOperand, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_ymm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<AsmRegisterXmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x2<AsmMemoryOperand, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x2(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x2_xmmm128_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x4<AsmRegisterYmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x4<AsmMemoryOperand, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vextracti64x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x4<AsmRegisterYmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextracti64x4<AsmMemoryOperand, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vextracti64x4(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vextracti64x4_ymmm256_k1z_zmm_imm8, op0.to_memory_operand(self.bitness()), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<AsmRegister32, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vextractps_rm32_xmm_imm8 } else { Code::EVEX_Vextractps_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<AsmRegister64, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vextractps_r64m32_xmm_imm8 } else { Code::EVEX_Vextractps_r64m32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vextractps_rm32_xmm_imm8 } else { Code::EVEX_Vextractps_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<AsmRegister32, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vextractps_rm32_xmm_imm8 } else { Code::EVEX_Vextractps_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<AsmRegister64, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vextractps_r64m32_xmm_imm8 } else { Code::EVEX_Vextractps_r64m32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVextractps<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vextractps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vextractps_rm32_xmm_imm8 } else { Code::EVEX_Vextractps_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmaddcph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfcmaddcsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmaddcsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmaddcsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmaddcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmulcph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfcmulcsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfcmulcsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfcmulcsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfcmulcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmpd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfixupimmss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfixupimmss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfixupimmss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vfixupimmss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd132ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd132ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd132ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd213ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd213ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd213ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmadd231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmadd231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmadd231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmadd231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmadd231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmadd231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmadd231ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmadd231ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmadd231ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmadd231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmadd231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddcph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddcsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddcsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddcsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsd_xmm_xmm_xmm_xmmm64, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddss_xmm_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub132ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub213ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmaddsub231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmaddsub231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmaddsub231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmaddsub231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmaddsub231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsub231ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsub231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmaddsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmaddsubps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmaddsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmaddsubps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub132ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub132ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub132ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub213ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub213ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub213ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsub231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsub231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsub231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsub231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfmsub231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsub231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsub231ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsub231ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsub231ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsub231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfmsub231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd132ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd213ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfmsubadd231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfmsubadd231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfmsubadd231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfmsubadd231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfmsubadd231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubadd231ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubadd231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmsubadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubaddps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubaddps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubsd_xmm_xmm_xmm_xmmm64, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmsubss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmsubss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmsubss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfmsubss_xmm_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmulcph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcph_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfmulcsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfmulcsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfmulcsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfmulcsh_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd132ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd132ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd132ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd213ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd213ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd213ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmadd231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmadd231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmadd231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmadd231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmadd231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmadd231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmadd231ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmadd231ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmadd231ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmadd231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmadd231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddsd_xmm_xmm_xmm_xmmm64, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmaddss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmaddss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmaddss_xmm_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub132pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub132pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub132pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub132pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub132pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub132pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub132pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub132pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub132ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub132ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub132ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub132ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub132ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub132ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub132ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub132ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub132sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub132sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub132sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub132ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub132ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub132ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub132ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub132ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub213pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub213pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub213pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub213pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub213pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub213pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub213pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub213pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub213ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub213ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub213ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub213ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub213ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub213ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub213ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub213ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub213sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub213sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub213sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub213ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub213ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub213ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub213ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub213ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub231pd_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub231pd_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub231pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub231pd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub231pd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub231pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub231pd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub231pd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231pd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub231ps_xmm_xmm_xmmm128 } else { Code::EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub231ps_ymm_ymm_ymmm256 } else { Code::EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub231ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub231ps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vfnmsub231ps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vfnmsub231ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vfnmsub231ps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vfnmsub231ps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231ps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub231sd_xmm_xmm_xmmm64 } else { Code::EVEX_Vfnmsub231sd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231sh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231sh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231sh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfnmsub231sh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsub231ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsub231ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsub231ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vfnmsub231ss_xmm_xmm_xmmm32 } else { Code::EVEX_Vfnmsub231ss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubpd_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubps_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubsd_xmm_xmm_xmmm64_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubsd_xmm_xmm_xmm_xmmm64, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfnmsubss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubss_xmm_xmm_xmmm32_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfnmsubss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfnmsubss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vfnmsubss_xmm_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<AsmRegisterK, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<AsmRegisterK, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<AsmRegisterK, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	fn vfpclasspd(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8
		} else {
			return Err(IcedError::new("vfpclasspd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<AsmRegisterK, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<AsmRegisterK, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<AsmRegisterK, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspd<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	fn vfpclasspd(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8
		} else {
			return Err(IcedError::new("vfpclasspd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdx<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspdx(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdx<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspdx(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdy<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspdy(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdy<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspdy(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdz<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspdz(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspdz<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspdz(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasspd_kr_k1_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<AsmRegisterK, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<AsmRegisterK, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<AsmRegisterK, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	fn vfpclassph(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8
		} else {
			return Err(IcedError::new("vfpclassph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<AsmRegisterK, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<AsmRegisterK, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<AsmRegisterK, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassph(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassph<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	fn vfpclassph(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8
		} else {
			return Err(IcedError::new("vfpclassph: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphx<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclassphx(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphx<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclassphx(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphy<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclassphy(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphy<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclassphy(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphz<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclassphz(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassphz<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclassphz(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassph_kr_k1_zmmm512b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<AsmRegisterK, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<AsmRegisterK, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<AsmRegisterK, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	fn vfpclassps(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8
		} else {
			return Err(IcedError::new("vfpclassps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<AsmRegisterK, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<AsmRegisterK, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<AsmRegisterK, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassps(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassps<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	fn vfpclassps(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8
		} else if op1.size() == MemoryOperandSize::Zword {
			Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8
		} else if op1.size() == MemoryOperandSize::Yword {
			Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8
		} else if op1.size() == MemoryOperandSize::Xword {
			Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8
		} else {
			return Err(IcedError::new("vfpclassps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsx<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspsx(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsx<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspsx(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsy<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspsy(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsy<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspsy(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsz<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasspsz(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasspsz<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasspsz(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassps_kr_k1_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssd<AsmRegisterK, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasssd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssd_kr_k1_xmmm64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssd<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasssd(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssd_kr_k1_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssd<AsmRegisterK, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasssd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssd_kr_k1_xmmm64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssd<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasssd(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssd_kr_k1_xmmm64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssh<AsmRegisterK, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclasssh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssh_kr_k1_xmmm16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssh<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclasssh(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssh_kr_k1_xmmm16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssh<AsmRegisterK, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclasssh(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssh_kr_k1_xmmm16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclasssh<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclasssh(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclasssh_kr_k1_xmmm16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassss<AsmRegisterK, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vfpclassss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassss_kr_k1_xmmm32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassss<AsmRegisterK, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vfpclassss(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassss_kr_k1_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassss<AsmRegisterK, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vfpclassss(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassss_kr_k1_xmmm32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfpclassss<AsmRegisterK, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vfpclassss(&mut self, op0: AsmRegisterK, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vfpclassss_kr_k1_xmmm32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfrczpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczpd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfrczpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczpd_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczpd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczpd_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfrczps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vfrczps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczps_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczps_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfrczsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczsd_xmm_xmmm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczsd_xmm_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vfrczss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczss_xmm_xmmm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVfrczss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vfrczss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vfrczss_xmm_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdpd_xmm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdpd_ymm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdpd_zmm_k1_vm32y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd3<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgatherdpd_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherdpd_xmm_vm32x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdpd3<AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgatherdpd_3(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherdpd_ymm_vm32x_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdps_xmm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdps_ymm_k1_vm32y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherdps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherdps_zmm_k1_vm32z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps3<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgatherdps_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherdps_xmm_vm32x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherdps3<AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgatherdps_3(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherdps_ymm_vm32y_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf0dpd<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf0dpd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf0dpd_vm32y_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf0dps<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf0dps(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf0dps_vm32z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf0qpd<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf0qpd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf0qpd_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf0qps<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf0qps(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf0qps_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf1dpd<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf1dpd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf1dpd_vm32y_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf1dps<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf1dps(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf1dps_vm32z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf1qpd<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf1qpd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf1qpd_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherpf1qps<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherpf1qps(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vgatherpf1qps_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherqpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherqpd_xmm_k1_vm64x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherqpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherqpd_ymm_k1_vm64y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherqpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherqpd_zmm_k1_vm64z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd3<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgatherqpd_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherqpd_xmm_vm64x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqpd3<AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgatherqpd_3(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vgatherqpd_ymm_vm64y_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vgatherqps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.index().is_xmm() {
			Code::EVEX_Vgatherqps_xmm_k1_vm64x
		} else if op1.index().is_ymm() {
			Code::EVEX_Vgatherqps_xmm_k1_vm64y
		} else {
			return Err(IcedError::new("vgatherqps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgatherqps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgatherqps_ymm_k1_vm64z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgatherqps3<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	fn vgatherqps_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if op1.index().is_xmm() {
			Code::VEX_Vgatherqps_xmm_vm64x_xmm
		} else if op1.index().is_ymm() {
			Code::VEX_Vgatherqps_xmm_vm64y_xmm
		} else {
			return Err(IcedError::new("vgatherqps: invalid operands"));
		};
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexppd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexppd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexppd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_zmm_k1z_zmmm512b16_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpph<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpph_zmm_k1z_zmmm512b16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vgetexpps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpsd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpsd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgetexpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetexpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgetexpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetexpss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantpd<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantpd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantph<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantps<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgetmantps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantsh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgetmantss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgetmantss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgetmantss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgetmantss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgetmantss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgetmantss_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vgf2p8affineinvqb_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vgf2p8affineinvqb_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vgf2p8affineinvqb_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vgf2p8affineinvqb_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineinvqb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineinvqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineinvqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vgf2p8affineqb_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vgf2p8affineqb_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vgf2p8affineqb_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vgf2p8affineqb_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8affineqb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vgf2p8affineqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vgf2p8affineqb_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8mulb_xmm_xmm_xmmm128 } else { Code::EVEX_Vgf2p8mulb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8mulb_ymm_ymm_ymmm256 } else { Code::EVEX_Vgf2p8mulb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgf2p8mulb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8mulb_xmm_xmm_xmmm128 } else { Code::EVEX_Vgf2p8mulb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vgf2p8mulb_ymm_ymm_ymmm256 } else { Code::EVEX_Vgf2p8mulb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVgf2p8mulb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vgf2p8mulb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vgf2p8mulb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vhaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vhaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhaddpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhaddpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vhaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vhaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhaddps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhaddps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhaddps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhaddps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vhsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vhsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubpd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubpd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vhsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vhsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubps_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVhsubps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vhsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vhsubps_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf128<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinsertf128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf128<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinsertf128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf128<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinsertf128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf128<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinsertf128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x8<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x8(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x8<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf32x8(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x8<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x8(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf32x8<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf32x8(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x2<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertf64x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertf64x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertf64x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinsertf64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti128<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinserti128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti128<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinserti128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti128<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinserti128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti128<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vinserti128_ymm_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x4_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x8<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x8(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x8<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti32x8(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x8<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x8(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti32x8<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti32x8(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti32x8_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_ymm_k1z_ymm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x2<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x2_zmm_k1z_zmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinserti64x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinserti64x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinserti64x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vinserti64x4_zmm_k1z_zmm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vinsertps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vinsertps_xmm_xmm_xmmm32_imm8 } else { Code::EVEX_Vinsertps_xmm_xmm_xmmm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vinsertps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vinsertps_xmm_xmm_xmmm32_imm8 } else { Code::EVEX_Vinsertps_xmm_xmm_xmmm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vinsertps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vinsertps_xmm_xmm_xmmm32_imm8 } else { Code::EVEX_Vinsertps_xmm_xmm_xmmm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVinsertps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vinsertps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vinsertps_xmm_xmm_xmmm32_imm8 } else { Code::EVEX_Vinsertps_xmm_xmm_xmmm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVlddqu<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vlddqu(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vlddqu_xmm_m128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVlddqu<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vlddqu(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vlddqu_ymm_m256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVldmxcsr<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vldmxcsr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Vldmxcsr_m32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovdqu<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaskmovdqu(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_vmaskmovdqu(self.bitness(), op0.register(), op1.register(), Register::None)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovpd<AsmMemoryOperand, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaskmovpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovpd_m128_xmm_xmm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovpd<AsmMemoryOperand, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaskmovpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovpd_m256_ymm_ymm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaskmovpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovpd_xmm_xmm_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaskmovpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovpd_ymm_ymm_m256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovps<AsmMemoryOperand, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaskmovps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovps_m128_xmm_xmm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovps<AsmMemoryOperand, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaskmovps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovps_m256_ymm_ymm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaskmovps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovps_xmm_xmm_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaskmovps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaskmovps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vmaskmovps_ymm_ymm_m256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmaxpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaxpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmaxpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmaxpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxpd_zmm_k1z_zmm_zmmm512b64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vmaxpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vmaxpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vmaxpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vmaxpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vmaxpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vmaxpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxpd_zmm_k1z_zmm_zmmm512b64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_zmm_k1z_zmm_zmmm512b16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxph_zmm_k1z_zmm_zmmm512b16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmaxps_xmm_xmm_xmmm128 } else { Code::EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmaxps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmaxps_ymm_ymm_ymmm256 } else { Code::EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmaxps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxps_zmm_k1z_zmm_zmmm512b32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vmaxps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vmaxps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vmaxps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vmaxps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vmaxps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vmaxps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxps_zmm_k1z_zmm_zmmm512b32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmaxsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vmaxsd_xmm_k1z_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmaxsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vmaxsd_xmm_k1z_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmaxsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmaxss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmaxss_xmm_xmm_xmmm32 } else { Code::EVEX_Vmaxss_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmaxss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmaxss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmaxss_xmm_xmm_xmmm32 } else { Code::EVEX_Vmaxss_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmcall for CodeAssembler {
	#[inline]
	fn vmcall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmcall))
	}
}

#[rustfmt::skip]
impl CodeAsmVmclear<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmclear(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Vmclear_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmfunc for CodeAssembler {
	#[inline]
	fn vmfunc(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmfunc))
	}
}

#[rustfmt::skip]
impl CodeAsmVmgexit for CodeAssembler {
	#[inline]
	fn vmgexit(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmgexit))
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vminpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vminpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vminpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vminpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminpd_zmm_k1z_zmm_zmmm512b64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vminpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vminpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vminpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vminpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vminpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vminpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminpd_zmm_k1z_zmm_zmmm512b64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_zmm_k1z_zmm_zmmm512b16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminph_zmm_k1z_zmm_zmmm512b16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vminps_xmm_xmm_xmmm128 } else { Code::EVEX_Vminps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vminps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vminps_ymm_ymm_ymmm256 } else { Code::EVEX_Vminps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vminps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminps_zmm_k1z_zmm_zmmm512b32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vminps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vminps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vminps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vminps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vminps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vminps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vminps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vminps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminps_zmm_k1z_zmm_zmmm512b32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vminsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vminsd_xmm_k1z_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vminsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vminsd_xmm_k1z_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vminsh_xmm_k1z_xmm_xmmm16_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vminss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vminss_xmm_xmm_xmmm32 } else { Code::EVEX_Vminss_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVminss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vminss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vminss_xmm_xmm_xmmm32 } else { Code::EVEX_Vminss_xmm_k1z_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmlaunch for CodeAssembler {
	#[inline]
	fn vmlaunch(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmlaunch))
	}
}

#[rustfmt::skip]
impl CodeAsmVmload for CodeAssembler {
	fn vmload(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Vmloadq
		} else if self.bitness() >= 32 {
			Code::Vmloadd
		} else {
			Code::Vmloadw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmVmmcall for CodeAssembler {
	#[inline]
	fn vmmcall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmmcall))
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovapd_xmm_xmmm128 } else { Code::EVEX_Vmovapd_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovapd_xmmm128_xmm } else { Code::EVEX_Vmovapd_xmmm128_k1z_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovapd_ymm_ymmm256 } else { Code::EVEX_Vmovapd_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovapd_ymmm256_ymm } else { Code::EVEX_Vmovapd_ymmm256_k1z_ymm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovapd_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovapd_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovapd_xmm_xmmm128 } else { Code::EVEX_Vmovapd_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovapd_ymm_ymmm256 } else { Code::EVEX_Vmovapd_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovapd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovapd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovapd_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovaps_xmm_xmmm128 } else { Code::EVEX_Vmovaps_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovaps_xmmm128_xmm } else { Code::EVEX_Vmovaps_xmmm128_k1z_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovaps_ymm_ymmm256 } else { Code::EVEX_Vmovaps_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovaps_ymmm256_ymm } else { Code::EVEX_Vmovaps_ymmm256_k1z_ymm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovaps_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovaps_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovaps_xmm_xmmm128 } else { Code::EVEX_Vmovaps_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovaps_ymm_ymmm256 } else { Code::EVEX_Vmovaps_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovaps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovaps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovaps_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovd<AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmovd(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovd_xmm_rm32 } else { Code::EVEX_Vmovd_xmm_rm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovd<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovd(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovd_rm32_xmm } else { Code::EVEX_Vmovd_rm32_xmm };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovd_rm32_xmm } else { Code::EVEX_Vmovd_rm32_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovd_xmm_rm32 } else { Code::EVEX_Vmovd_xmm_rm32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovddup_xmm_xmmm64 } else { Code::EVEX_Vmovddup_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovddup_ymm_ymmm256 } else { Code::EVEX_Vmovddup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovddup_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovddup_xmm_xmmm64 } else { Code::EVEX_Vmovddup_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovddup_ymm_ymmm256 } else { Code::EVEX_Vmovddup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovddup<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovddup(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovddup_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_ymmm256_ymm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqa_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa32<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa32(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa32_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqa64<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqa64(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqa64_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_xmmm128_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_ymmm256_ymm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovdqu_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu16<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu16(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu16_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu32<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu32(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu32_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu64<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu64(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu64_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovdqu8<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovdqu8(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovdqu8_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhlps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovhlps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovhlps_xmm_xmm_xmm } else { Code::EVEX_Vmovhlps_xmm_xmm_xmm };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhpd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovhpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovhpd_m64_xmm } else { Code::EVEX_Vmovhpd_m64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhpd3<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovhpd_3(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovhpd_xmm_xmm_m64 } else { Code::EVEX_Vmovhpd_xmm_xmm_m64 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovhps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovhps_m64_xmm } else { Code::EVEX_Vmovhps_m64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovhps3<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovhps_3(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovhps_xmm_xmm_m64 } else { Code::EVEX_Vmovhps_xmm_xmm_m64 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlhps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovlhps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovlhps_xmm_xmm_xmm } else { Code::EVEX_Vmovlhps_xmm_xmm_xmm };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlpd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovlpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovlpd_m64_xmm } else { Code::EVEX_Vmovlpd_m64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlpd3<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovlpd_3(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovlpd_xmm_xmm_m64 } else { Code::EVEX_Vmovlpd_xmm_xmm_m64 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovlps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovlps_m64_xmm } else { Code::EVEX_Vmovlps_m64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovlps3<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovlps_3(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovlps_xmm_xmm_m64 } else { Code::EVEX_Vmovlps_xmm_xmm_m64 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskpd<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovmskpd(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskpd_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskpd<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovmskpd(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskpd_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskpd<AsmRegister32, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovmskpd(&mut self, op0: AsmRegister32, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskpd_r32_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskpd<AsmRegister64, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovmskpd(&mut self, op0: AsmRegister64, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskpd_r64_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskps<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovmskps(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskps_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskps<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovmskps(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskps_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskps<AsmRegister32, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovmskps(&mut self, op0: AsmRegister32, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskps_r32_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovmskps<AsmRegister64, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovmskps(&mut self, op0: AsmRegister64, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vmovmskps_r64_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdq<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovntdq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovntdq_m128_xmm } else { Code::EVEX_Vmovntdq_m128_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdq<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovntdq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovntdq_m256_ymm } else { Code::EVEX_Vmovntdq_m256_ymm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdq<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovntdq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovntdq_m512_zmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdqa<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovntdqa(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovntdqa_xmm_m128 } else { Code::EVEX_Vmovntdqa_xmm_m128 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdqa<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovntdqa(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovntdqa_ymm_m256 } else { Code::EVEX_Vmovntdqa_ymm_m256 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntdqa<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovntdqa(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovntdqa_zmm_m512, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntpd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovntpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovntpd_m128_xmm } else { Code::EVEX_Vmovntpd_m128_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntpd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovntpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovntpd_m256_ymm } else { Code::EVEX_Vmovntpd_m256_ymm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntpd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovntpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovntpd_m512_zmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovntps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovntps_m128_xmm } else { Code::EVEX_Vmovntps_m128_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntps<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovntps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovntps_m256_ymm } else { Code::EVEX_Vmovntps_m256_ymm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovntps<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovntps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovntps_m512_zmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovq_xmm_rm64 } else { Code::EVEX_Vmovq_xmm_rm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovq_rm64_xmm } else { Code::EVEX_Vmovq_rm64_xmm };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovq_xmm_xmmm64 } else { Code::EVEX_Vmovq_xmm_xmmm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovq_xmmm64_xmm } else { Code::EVEX_Vmovq_xmmm64_xmm };
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovq_xmm_xmmm64 } else { Code::EVEX_Vmovq_xmm_xmmm64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovsd_m64_xmm } else { Code::EVEX_Vmovsd_m64_k1_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovsd_xmm_m64 } else { Code::EVEX_Vmovsd_xmm_k1z_m64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsd3<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsd_3(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovsd_xmm_xmm_xmm } else { Code::EVEX_Vmovsd_xmm_k1z_xmm_xmm };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsh<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsh(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovsh_m16_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsh<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsh(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovsh_xmm_k1z_m16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsh3<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsh_3(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmovsh_xmm_k1z_xmm_xmm, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovshdup_xmm_xmmm128 } else { Code::EVEX_Vmovshdup_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovshdup_ymm_ymmm256 } else { Code::EVEX_Vmovshdup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovshdup_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovshdup_xmm_xmmm128 } else { Code::EVEX_Vmovshdup_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovshdup_ymm_ymmm256 } else { Code::EVEX_Vmovshdup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovshdup<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovshdup(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovshdup_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovsldup_xmm_xmmm128 } else { Code::EVEX_Vmovsldup_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovsldup_ymm_ymmm256 } else { Code::EVEX_Vmovsldup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovsldup_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovsldup_xmm_xmmm128 } else { Code::EVEX_Vmovsldup_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovsldup_ymm_ymmm256 } else { Code::EVEX_Vmovsldup_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovsldup<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovsldup(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovsldup_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovss<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovss(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovss_m32_xmm } else { Code::EVEX_Vmovss_m32_k1_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovss_xmm_m32 } else { Code::EVEX_Vmovss_xmm_k1z_m32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovss3<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovss_3(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovss_xmm_xmm_xmm } else { Code::EVEX_Vmovss_xmm_k1z_xmm_xmm };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovupd_xmm_xmmm128 } else { Code::EVEX_Vmovupd_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovupd_xmmm128_xmm } else { Code::EVEX_Vmovupd_xmmm128_k1z_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovupd_ymm_ymmm256 } else { Code::EVEX_Vmovupd_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovupd_ymmm256_ymm } else { Code::EVEX_Vmovupd_ymmm256_k1z_ymm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovupd_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovupd_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovupd_xmm_xmmm128 } else { Code::EVEX_Vmovupd_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovupd_ymm_ymmm256 } else { Code::EVEX_Vmovupd_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovupd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovupd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovupd_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovups_xmm_xmmm128 } else { Code::EVEX_Vmovups_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovups_xmmm128_xmm } else { Code::EVEX_Vmovups_xmmm128_k1z_xmm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovups_ymm_ymmm256 } else { Code::EVEX_Vmovups_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovups_ymmm256_ymm } else { Code::EVEX_Vmovups_ymmm256_k1z_ymm };
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovups_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovups_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovups_xmm_xmmm128 } else { Code::EVEX_Vmovups_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmovups_ymm_ymmm256 } else { Code::EVEX_Vmovups_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovups<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovups(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vmovups_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_xmm_r32m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_xmm_r64m16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_r32m16_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_r64m16_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_r32m16_xmm, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmovw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmovw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vmovw_xmm_r32m16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vmpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vmpsadbw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmptrld<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmptrld(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Vmptrld_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmptrst<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmptrst(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Vmptrst_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmread<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmread(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmread_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmread<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmread(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmread_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmread<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmread(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmread_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmread<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmread(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmread_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmresume for CodeAssembler {
	#[inline]
	fn vmresume(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmresume))
	}
}

#[rustfmt::skip]
impl CodeAsmVmrun for CodeAssembler {
	fn vmrun(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Vmrunq
		} else if self.bitness() >= 32 {
			Code::Vmrund
		} else {
			Code::Vmrunw
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmVmsave for CodeAssembler {
	fn vmsave(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Vmsaveq
		} else if self.bitness() >= 32 {
			Code::Vmsaved
		} else {
			Code::Vmsavew
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmulpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmulpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmulpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmulpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vmulpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vmulpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vmulpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vmulpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vmulpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vmulpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmulps_xmm_xmm_xmmm128 } else { Code::EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vmulps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmulps_ymm_ymm_ymmm256 } else { Code::EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vmulps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vmulps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vmulps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vmulps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vmulps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vmulps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vmulps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmulsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vmulsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmulsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vmulsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vmulsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vmulss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmulss_xmm_xmm_xmmm32 } else { Code::EVEX_Vmulss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmulss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmulss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vmulss_xmm_xmm_xmmm32 } else { Code::EVEX_Vmulss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVmwrite<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vmwrite(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmwrite_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmwrite<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vmwrite(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmwrite_r64_rm64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmwrite<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmwrite(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmwrite_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmwrite<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmwrite(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Vmwrite_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVmxoff for CodeAssembler {
	#[inline]
	fn vmxoff(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Vmxoff))
	}
}

#[rustfmt::skip]
impl CodeAsmVmxon<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vmxon(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Vmxon_m64, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vorpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vorpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vorpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vorpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vorpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vorpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vorpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vorpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vorpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vorpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vorpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vorpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vorpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vorpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vorps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vorps_xmm_xmm_xmmm128 } else { Code::EVEX_Vorps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vorps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vorps_ymm_ymm_ymmm256 } else { Code::EVEX_Vorps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vorps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vorps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vorps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vorps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vorps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vorps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vorps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vorps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vorps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vorps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVorps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vorps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vorps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectd_kp1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp2intersectq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp2intersectq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp2intersectq_kp1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op2.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp4dpwssd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp4dpwssd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp4dpwssd_zmm_k1z_zmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVp4dpwssds<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vp4dpwssds(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vp4dpwssds_zmm_k1z_zmmp3_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsb_xmm_xmmm128 } else { Code::EVEX_Vpabsb_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsb_ymm_ymmm256 } else { Code::EVEX_Vpabsb_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsb_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsb_xmm_xmmm128 } else { Code::EVEX_Vpabsb_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsb_ymm_ymmm256 } else { Code::EVEX_Vpabsb_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsb<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsb(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsb_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpabsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsd_xmm_xmmm128 } else { Code::EVEX_Vpabsd_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpabsd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsd_ymm_ymmm256 } else { Code::EVEX_Vpabsd_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpabsd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsd_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpabsd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpabsd_xmm_k1z_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpabsd_xmm_xmmm128
		} else {
			Code::EVEX_Vpabsd_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpabsd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpabsd_ymm_k1z_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpabsd_ymm_ymmm256
		} else {
			Code::EVEX_Vpabsd_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsd_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsq_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsw_xmm_xmmm128 } else { Code::EVEX_Vpabsw_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsw_ymm_ymmm256 } else { Code::EVEX_Vpabsw_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsw_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsw_xmm_xmmm128 } else { Code::EVEX_Vpabsw_xmm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpabsw_ymm_ymmm256 } else { Code::EVEX_Vpabsw_ymm_k1z_ymmm256 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpabsw<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpabsw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpabsw_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpackssdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpackssdw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpackssdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpackssdw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpackssdw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackssdw_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpackssdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpackssdw_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpackssdw_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpackssdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpackssdw_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpackssdw_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackssdw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackssdw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackssdw_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpacksswb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpacksswb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpacksswb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpacksswb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpacksswb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpacksswb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpacksswb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpacksswb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpacksswb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpacksswb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpacksswb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpacksswb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpackusdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpackusdw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpackusdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpackusdw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpackusdw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackusdw_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpackusdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpackusdw_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpackusdw_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpackusdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpackusdw_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpackusdw_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackusdw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackusdw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackusdw_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpackuswb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpackuswb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpackuswb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpackuswb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackuswb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpackuswb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpackuswb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpackuswb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpackuswb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpackuswb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpackuswb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpackuswb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpaddd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpaddd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpaddd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpaddd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpaddd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpaddd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpaddq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpaddq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpaddq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpaddq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpaddq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpaddq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddsw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddusb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddusb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddusb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddusb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddusb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddusb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddusb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddusb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddusb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddusb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddusw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddusw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddusw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddusw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddusw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddusw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddusw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddusw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddusw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddusw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddusw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddusw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpaddw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpaddw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpaddw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpaddw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpaddw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpaddw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpalignr_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpalignr_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpalignr_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpalignr_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpalignr_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpalignr_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpalignr_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpalignr_xmm_k1z_xmm_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpalignr_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpalignr_ymm_k1z_ymm_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpalignr<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpalignr(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpalignr_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpand<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpand(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpand_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpand<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpand(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpand_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpand<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpand(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpand_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpand<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpand(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpand_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandn<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandn(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpandn_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandn<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandn(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpandn_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandn<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandn(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpandn_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandn<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandn(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpandn_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandnq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandnq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandnq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpandq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpandq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpandq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpavgb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpavgb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpavgb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpavgb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpavgb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpavgb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpavgb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpavgb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpavgb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpavgb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpavgw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpavgw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpavgw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpavgw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpavgw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpavgw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpavgw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpavgw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpavgw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpavgw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpavgw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpavgw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpblendd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendd_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendmw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpblendmw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpblendmw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendvb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendvb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendvb_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendvb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpblendvb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendvb_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendvb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendvb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendvb_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendvb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpblendvb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendvb_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpblendw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpblendw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vpblendw_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_xmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<AsmRegisterYmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: AsmRegisterYmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_ymm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<AsmRegisterZmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: AsmRegisterZmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_zmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastb_xmm_xmmm8 } else { Code::EVEX_Vpbroadcastb_xmm_k1z_xmmm8 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastb_ymm_xmmm8 } else { Code::EVEX_Vpbroadcastb_ymm_k1z_xmmm8 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_zmm_k1z_xmmm8, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastb_xmm_xmmm8 } else { Code::EVEX_Vpbroadcastb_xmm_k1z_xmmm8 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastb_ymm_xmmm8 } else { Code::EVEX_Vpbroadcastb_ymm_k1z_xmmm8 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastb<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastb(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastb_zmm_k1z_xmmm8, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_xmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<AsmRegisterYmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: AsmRegisterYmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_ymm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<AsmRegisterZmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: AsmRegisterZmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_zmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastd_xmm_xmmm32 } else { Code::EVEX_Vpbroadcastd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastd_ymm_xmmm32 } else { Code::EVEX_Vpbroadcastd_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_zmm_k1z_xmmm32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastd_xmm_xmmm32 } else { Code::EVEX_Vpbroadcastd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastd_ymm_xmmm32 } else { Code::EVEX_Vpbroadcastd_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastd_zmm_k1z_xmmm32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmb2q<AsmRegisterXmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmb2q(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmb2q_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmb2q<AsmRegisterYmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmb2q(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmb2q_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmb2q<AsmRegisterZmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmb2q(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmb2q_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmw2d<AsmRegisterXmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmw2d(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmw2d_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmw2d<AsmRegisterYmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmw2d(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmw2d_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastmw2d<AsmRegisterZmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpbroadcastmw2d(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpbroadcastmw2d_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<AsmRegisterXmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: AsmRegisterXmm, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_xmm_k1z_r64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<AsmRegisterYmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: AsmRegisterYmm, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_ymm_k1z_r64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<AsmRegisterZmm, AsmRegister64> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: AsmRegisterZmm, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_zmm_k1z_r64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastq_xmm_xmmm64 } else { Code::EVEX_Vpbroadcastq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastq_ymm_xmmm64 } else { Code::EVEX_Vpbroadcastq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastq_xmm_xmmm64 } else { Code::EVEX_Vpbroadcastq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastq_ymm_xmmm64 } else { Code::EVEX_Vpbroadcastq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastq_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<AsmRegisterXmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: AsmRegisterXmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_xmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<AsmRegisterYmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: AsmRegisterYmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_ymm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<AsmRegisterZmm, AsmRegister32> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: AsmRegisterZmm, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_zmm_k1z_r32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastw_xmm_xmmm16 } else { Code::EVEX_Vpbroadcastw_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastw_ymm_xmmm16 } else { Code::EVEX_Vpbroadcastw_ymm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_zmm_k1z_xmmm16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastw_xmm_xmmm16 } else { Code::EVEX_Vpbroadcastw_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpbroadcastw_ymm_xmmm16 } else { Code::EVEX_Vpbroadcastw_ymm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpbroadcastw<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpbroadcastw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpbroadcastw_zmm_k1z_xmmm16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqhqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqhqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 17)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulhqlqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmulhqlqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqhqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqhqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 16)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmullqlqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpclmullqlqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpclmulqdq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vpclmulqdq_xmm_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vpclmulqdq_ymm_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpclmulqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpclmulqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::EVEX_Vpclmulqdq_zmm_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_ymm_ymm_ymmm256_ymm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmov<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmov(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcmov_ymm_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpb_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpd_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqq_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqq_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpequw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpeqw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpeqw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpeqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpeqw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestri(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestri(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestri(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestri(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri64<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestri64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri64<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestri64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri64<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestri64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestri64<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestri64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestri64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm64<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm64<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm64<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm64(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpestrm64<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpestrm64(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpestrm64_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsed<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsed(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalseuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalseuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpfalsew<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpfalsew(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtq_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtq_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpgtw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpgtw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpgtw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpcmpgtw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistri<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpistri(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistri<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpistri(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistri<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpistri(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistri_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistri<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpistri(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistri_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistrm<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpistrm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistrm<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpistrm(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistrm<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpistrm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpistrm<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpistrm(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpcmpistrm_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpled<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpled(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpleuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmplew<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmplew(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpltw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnequw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnequw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpneqw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpneqw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnled<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnled(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnleuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnleuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnlew<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnlew(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpnltw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmpnltw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrued<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrued(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptrueuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptrueuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmptruew<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcmptruew(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32>>::vpcmpw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpub<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpub(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpub_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpud<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpud(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpud_kr_k1_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuq_kr_k1_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpuw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpuw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpuw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcmpw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcmpw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpcmpw_kr_k1_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomb_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomb_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomb_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomb_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomd_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomeqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomeqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomeqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomeqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomeqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomeqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomequb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomequb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomequd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomequd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomequq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomequq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomequw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomequw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomequw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomeqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomeqw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomeqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 4)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalsed<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalsed(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalsed<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalsed(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalseuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalseuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalseuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalsew<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomfalsew(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomfalsew<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomfalsew(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 6)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomged<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomged(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomged<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomged(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgeuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgeuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgeuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgew<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgew(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgew<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgew(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 3)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomgtw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomgtw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomgtw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 2)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomled<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomled(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomled<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomled(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomleuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomleuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomleuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomlew<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomlew(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomlew<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomlew(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 1)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomltw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomltw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomltw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 0)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomneqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomneqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomneqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomneqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomneqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomneqq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomnequb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomnequb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomnequd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomnequd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomnequq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomnequq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomnequw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomnequw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomnequw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomneqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomneqw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomneqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 5)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressb_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressd_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressq<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressq_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_xmmm128_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_xmmm128_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_ymmm256_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_ymmm256_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_zmmm512_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcompressw<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpcompressw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpcompressw_zmmm512_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomb(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrued<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrued(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrued<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrued(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomd(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomub(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomud(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuq(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtrueuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtrueuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtrueuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomuw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtruew<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpcomtruew(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32>>::vpcomw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomtruew<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpcomtruew(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		<Self as CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32>>::vpcomw(self, op0, op1, op2, 7)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomub_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomub_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomub_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomub_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomud_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomud_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomud_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomud_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuq_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomuw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpcomw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpcomw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpcomw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpcomw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpcomw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpcomw_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictd_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpconflictq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpconflictq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpconflictq_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbssd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbssd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbssd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbssd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbssd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbssd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbssd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbssd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbssd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbssd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbssd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbssd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbssds<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbssds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbssds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbssds<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbssds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbssds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbssds<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbssds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbssds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbssds<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbssds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbssds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbsud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbsud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbsud_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbsud<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbsud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbsud_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbsud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbsud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbsud_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbsud<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbsud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbsud_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbsuds<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbsuds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbsuds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbsuds<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbsuds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbsuds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbsuds<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbsuds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbsuds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbsuds<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbsuds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbsuds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbusd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpdpbusd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbusd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpdpbusd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpdpbusd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpbusd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpdpbusd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpdpbusd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpdpbusd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpdpbusd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpdpbusd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpdpbusd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbusd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpbusd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbusds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpdpbusds_xmm_xmm_xmmm128 } else { Code::EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbusds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpdpbusds_ymm_ymm_ymmm256 } else { Code::EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpdpbusds(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpbusds_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpdpbusds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpdpbusds_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpdpbusds_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpdpbusds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpdpbusds_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpdpbusds_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbusds<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbusds(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpbusds_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbuud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbuud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbuud_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbuud<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbuud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbuud_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbuud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbuud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbuud_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbuud<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbuud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbuud_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbuuds<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpbuuds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbuuds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbuuds<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpbuuds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbuuds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbuuds<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbuuds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbuuds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpbuuds<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpbuuds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpbuuds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwssd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpdpwssd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwssd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpdpwssd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpdpwssd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpwssd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpdpwssd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpdpwssd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpdpwssd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpdpwssd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpdpwssd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpdpwssd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwssd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpwssd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwssds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpdpwssds_xmm_xmm_xmmm128 } else { Code::EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwssds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpdpwssds_ymm_ymm_ymmm256 } else { Code::EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpdpwssds(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpwssds_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpdpwssds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpdpwssds_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpdpwssds_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpdpwssds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpdpwssds_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpdpwssds_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwssds<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwssds(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpdpwssds_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwsud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwsud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwsud_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwsud<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwsud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwsud_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwsud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwsud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwsud_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwsud<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwsud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwsud_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwsuds<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwsuds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwsuds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwsuds<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwsuds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwsuds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwsuds<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwsuds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwsuds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwsuds<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwsuds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwsuds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwusd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwusd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwusd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwusd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwusd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwusd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwusd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwusd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwusd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwusd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwusd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwusd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwusds<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwusds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwusds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwusds<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwusds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwusds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwusds<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwusds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwusds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwusds<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwusds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwusds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwuud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwuud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwuud_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwuud<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwuud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwuud_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwuud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwuud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwuud_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwuud<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwuud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwuud_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwuuds<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpdpwuuds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwuuds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwuuds<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpdpwuuds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwuuds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwuuds<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwuuds(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwuuds_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpdpwuuds<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpdpwuuds(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpdpwuuds_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2f128<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vperm2f128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2f128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2f128<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vperm2f128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2f128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2f128<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vperm2f128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2f128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2f128<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vperm2f128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2f128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2i128<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vperm2i128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2i128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2i128<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vperm2i128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2i128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2i128<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vperm2i128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2i128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVperm2i128<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vperm2i128(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vperm2i128_ymm_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpermd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpermd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2b<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2b(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2b_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2d<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2d(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2d_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2pd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2q<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2q(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2q_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermi2w<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermi2w(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermi2w_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmm_xmmm128_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymm_ymmm256_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_xmm_xmm_xmm_xmmm128_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermil2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2pd_ymm_ymm_ymm_ymmm256_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmm_xmmm128_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand, op4: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymm_ymmm256_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmmm128_xmm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmRegisterYmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.register(), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: AsmRegisterYmm, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymmm256_ymm_imm4, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register(), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_xmm_xmm_xmm_xmmm128_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermil2ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermil2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: AsmMemoryOperand, op4: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with5(Code::VEX_Vpermil2ps_ymm_ymm_ymm_ymmm256_imm4, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()), op4)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpermilpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpermilpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpermilpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpermilpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilpd_xmm_xmmm128_imm8 } else { Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilpd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermilpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilpd_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermilpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilpd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilpd_xmm_xmmm128_imm8 } else { Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilpd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermilpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilpd_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpermilpd_xmm_k1z_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermilpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilpd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermilpd_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilpd<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermilpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilps_xmm_xmm_xmmm128 } else { Code::EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilps_ymm_ymm_ymmm256 } else { Code::EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpermilps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpermilps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpermilps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpermilps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilps_xmm_xmmm128_imm8 } else { Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilps_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermilps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilps_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermilps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilps_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilps_xmm_xmmm128_imm8 } else { Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermilps_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermilps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilps_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpermilps_xmm_k1z_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermilps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermilps_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermilps_ymm_k1z_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermilps<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermilps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermilps_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermpd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermpd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermpd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermpd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermpd_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermpd<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermpd_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermps_ymm_ymm_ymmm256 } else { Code::EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpermps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpermps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermq_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vpermq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermq_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpermq_ymm_ymmm256_imm8 } else { Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vpermq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpermq_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpermq_ymm_k1z_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermq<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpermq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2b<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2b(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2b_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2d<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2d(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2d_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2pd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2pd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2ps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2ps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2q<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2q(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2q_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermt2w<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermt2w(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermt2w_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpermw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpermw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpermw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandb<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandb(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandb_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandd_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandq_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpexpandw<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpexpandw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpexpandw_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<AsmRegister32, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrb_r32m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r32m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<AsmRegister64, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrb_r64m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r64m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrb_r32m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r32m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<AsmRegister32, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrb_r32m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r32m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<AsmRegister64, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrb_r64m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r64m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrb<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrb_r32m8_xmm_imm8 } else { Code::EVEX_Vpextrb_r32m8_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrd<AsmRegister32, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrd(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrd_rm32_xmm_imm8 } else { Code::EVEX_Vpextrd_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrd<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrd_rm32_xmm_imm8 } else { Code::EVEX_Vpextrd_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrd<AsmRegister32, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrd(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrd_rm32_xmm_imm8 } else { Code::EVEX_Vpextrd_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrd<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrd_rm32_xmm_imm8 } else { Code::EVEX_Vpextrd_rm32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrq<AsmRegister64, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrq(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrq_rm64_xmm_imm8 } else { Code::EVEX_Vpextrq_rm64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrq<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrq_rm64_xmm_imm8 } else { Code::EVEX_Vpextrq_rm64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrq<AsmRegister64, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrq(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrq_rm64_xmm_imm8 } else { Code::EVEX_Vpextrq_rm64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrq<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrq_rm64_xmm_imm8 } else { Code::EVEX_Vpextrq_rm64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<AsmRegister32, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrw_r32_xmm_imm8 } else { Code::EVEX_Vpextrw_r32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<AsmRegister64, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrw_r64_xmm_imm8 } else { Code::EVEX_Vpextrw_r64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<AsmMemoryOperand, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrw_r32m16_xmm_imm8 } else { Code::EVEX_Vpextrw_r32m16_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<AsmRegister32, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrw_r32_xmm_imm8 } else { Code::EVEX_Vpextrw_r32_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<AsmRegister64, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrw_r64_xmm_imm8 } else { Code::EVEX_Vpextrw_r64_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpextrw<AsmMemoryOperand, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpextrw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpextrw_r32m16_xmm_imm8 } else { Code::EVEX_Vpextrw_r32m16_xmm_imm8 };
		self.add_instr(Instruction::with3(code, op0.to_memory_operand(self.bitness()), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdd_xmm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdd_ymm_k1_vm32y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdd_zmm_k1_vm32z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd3<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpgatherdd_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherdd_xmm_vm32x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdd3<AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpgatherdd_3(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherdd_ymm_vm32y_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdq_xmm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdq_ymm_k1_vm32x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherdq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherdq_zmm_k1_vm32y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq3<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpgatherdq_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherdq_xmm_vm32x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherdq3<AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpgatherdq_3(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherdq_ymm_vm32x_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpgatherqd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.index().is_xmm() {
			Code::EVEX_Vpgatherqd_xmm_k1_vm64x
		} else if op1.index().is_ymm() {
			Code::EVEX_Vpgatherqd_xmm_k1_vm64y
		} else {
			return Err(IcedError::new("vpgatherqd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherqd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherqd_ymm_k1_vm64z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqd3<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	fn vpgatherqd_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if op1.index().is_xmm() {
			Code::VEX_Vpgatherqd_xmm_vm64x_xmm
		} else if op1.index().is_ymm() {
			Code::VEX_Vpgatherqd_xmm_vm64y_xmm
		} else {
			return Err(IcedError::new("vpgatherqd: invalid operands"));
		};
		self.add_instr(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherqq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherqq_xmm_k1_vm64x, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherqq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherqq_ymm_k1_vm64y, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpgatherqq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpgatherqq_zmm_k1_vm64z, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq3<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpgatherqq_3(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherqq_xmm_vm64x_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpgatherqq3<AsmRegisterYmm, AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpgatherqq_3(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpgatherqq_ymm_vm64y_ymm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddbd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddbd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddbq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddbq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddbw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphaddd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadddq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphadddq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadddq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadddq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphadddq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadddq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddsw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddsw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddsw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphaddsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddsw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddsw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddsw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddsw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddsw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddubd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddubd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddubq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddubq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddubw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddubw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddubw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddubw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddudq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddudq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddudq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddudq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddudq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddudq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadduwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphadduwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadduwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadduwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphadduwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadduwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadduwq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphadduwq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadduwq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphadduwq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphadduwq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphadduwq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphaddw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphaddw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddwq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphaddwq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddwq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphaddwq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphaddwq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphaddwq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphminposuw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphminposuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vphminposuw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphminposuw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphminposuw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vphminposuw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubbw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubbw_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubbw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubbw_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphsubd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubdq_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubdq_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubsw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubsw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubsw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphsubsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubsw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubsw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubsw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubsw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubsw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vphsubw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vphsubw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vphsubwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubwd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVphsubwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vphsubwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::XOP_Vphsubwd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r32m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r32m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r64m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r64m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r32m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r32m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r32m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r32m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r64m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r64m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpinsrb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrb_xmm_xmm_r32m8_imm8 } else { Code::EVEX_Vpinsrb_xmm_xmm_r32m8_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrd<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn vpinsrd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrd_xmm_xmm_rm32_imm8 } else { Code::EVEX_Vpinsrd_xmm_xmm_rm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpinsrd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrd_xmm_xmm_rm32_imm8 } else { Code::EVEX_Vpinsrd_xmm_xmm_rm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrd<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn vpinsrd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrd_xmm_xmm_rm32_imm8 } else { Code::EVEX_Vpinsrd_xmm_xmm_rm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpinsrd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrd_xmm_xmm_rm32_imm8 } else { Code::EVEX_Vpinsrd_xmm_xmm_rm32_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrq<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn vpinsrq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrq_xmm_xmm_rm64_imm8 } else { Code::EVEX_Vpinsrq_xmm_xmm_rm64_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpinsrq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrq_xmm_xmm_rm64_imm8 } else { Code::EVEX_Vpinsrq_xmm_xmm_rm64_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrq<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn vpinsrq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrq_xmm_xmm_rm64_imm8 } else { Code::EVEX_Vpinsrq_xmm_xmm_rm64_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpinsrq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrq_xmm_xmm_rm64_imm8 } else { Code::EVEX_Vpinsrq_xmm_xmm_rm64_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32, i32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r32m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r32m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64, i32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r64m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r64m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r32m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r32m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<AsmRegisterXmm, AsmRegisterXmm, AsmRegister32, u32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister32, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r32m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r32m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<AsmRegisterXmm, AsmRegisterXmm, AsmRegister64, u32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegister64, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r64m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r64m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpinsrw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpinsrw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpinsrw_xmm_xmm_r32m16_imm8 } else { Code::EVEX_Vpinsrw_xmm_xmm_r32m16_imm8 };
		self.add_instr(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntd_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVplzcntq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vplzcntq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vplzcntq_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdqh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdqh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdqh_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdqh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdqh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdqh_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdql<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdql(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdql_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsdql<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsdql(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsdql_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdqh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdqh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdqh_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdqh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdqh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdqh_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdql<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdql(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdql_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssdql<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssdql(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssdql_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsswd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsswd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsswd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsswd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssww<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssww(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssww_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacssww<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacssww(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacssww_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacswd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacswd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacswd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacswd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsww<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsww(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsww_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmacsww<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmacsww(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmacsww_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadcsswd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadcsswd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmadcsswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadcsswd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadcsswd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmadcsswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadcswd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadcswd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmadcswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadcswd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadcswd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpmadcswd_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmadd52huq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmadd52huq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52huq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmadd52huq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmadd52huq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmadd52huq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmadd52huq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmadd52huq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmadd52huq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52huq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmadd52huq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52huq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmadd52luq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmadd52luq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52luq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmadd52luq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmadd52luq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmadd52luq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmadd52luq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmadd52luq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmadd52luq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmadd52luq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmadd52luq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmadd52luq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaddubsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaddubsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaddubsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaddubsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaddubsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaddubsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaddubsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaddubsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaddubsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddubsw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddubsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaddubsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaddwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaddwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaddwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaddwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaddwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaddwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaddwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaddwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaddwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaddwd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaddwd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaddwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovd<AsmMemoryOperand, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaskmovd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovd_m128_xmm_xmm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovd<AsmMemoryOperand, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaskmovd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovd_m256_ymm_ymm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaskmovd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovd_xmm_xmm_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaskmovd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovd_ymm_ymm_m256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovq<AsmMemoryOperand, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaskmovq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovq_m128_xmm_xmm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovq<AsmMemoryOperand, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaskmovq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovq_m256_ymm_ymm, op0.to_memory_operand(self.bitness()), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaskmovq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovq_xmm_xmm_m128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaskmovq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaskmovq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpmaskmovq_ymm_ymm_m256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxsd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxsd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmaxsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmaxsd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmaxsd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmaxsd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmaxsd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmaxsd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxsw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxub_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxub_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxub_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxub_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxub_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxub_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxub_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxub_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxub_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxub<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxub(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxub_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxud_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxud_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxud(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxud_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmaxud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmaxud_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmaxud_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmaxud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmaxud_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmaxud_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxud<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxud(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxud_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmaxuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmaxuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmaxuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmaxuw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmaxuw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmaxuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminsd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminsd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpminsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpminsd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpminsd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpminsd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpminsd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpminsd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminsw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminub_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminub_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminub_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminub_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminub_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminub_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminub_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminub_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminub_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminub<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminub(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminub_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminud_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminud_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminud(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminud_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpminud(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpminud_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpminud_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpminud(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpminud_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpminud_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminud<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminud(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminud_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpminuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpminuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpminuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpminuw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpminuw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpminuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovb2m<AsmRegisterK, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovb2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovb2m_kr_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovb2m<AsmRegisterK, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovb2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovb2m_kr_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovb2m<AsmRegisterK, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovb2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovb2m_kr_zmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovd2m<AsmRegisterK, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovd2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovd2m_kr_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovd2m<AsmRegisterK, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovd2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovd2m_kr_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovd2m<AsmRegisterK, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovd2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovd2m_kr_zmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovdb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdb_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovdw<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovdw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovdw_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2b<AsmRegisterXmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2b(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2b_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2b<AsmRegisterYmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2b(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2b_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2b<AsmRegisterZmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2b(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2b_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2d<AsmRegisterXmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2d(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2d_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2d<AsmRegisterYmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2d(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2d_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2d<AsmRegisterZmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2d(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2d_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2q<AsmRegisterXmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2q(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2q_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2q<AsmRegisterYmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2q(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2q_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2q<AsmRegisterZmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2q(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2q_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2w<AsmRegisterXmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2w(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2w_xmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2w<AsmRegisterYmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2w(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2w_ymm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovm2w<AsmRegisterZmm, AsmRegisterK> for CodeAssembler {
	#[inline]
	fn vpmovm2w(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterK) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovm2w_zmm_kr, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovmskb<AsmRegister32, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovmskb(&mut self, op0: AsmRegister32, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vpmovmskb_r32_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovmskb<AsmRegister64, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovmskb(&mut self, op0: AsmRegister64, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vpmovmskb_r64_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovmskb<AsmRegister32, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovmskb(&mut self, op0: AsmRegister32, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vpmovmskb_r32_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovmskb<AsmRegister64, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovmskb(&mut self, op0: AsmRegister64, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vpmovmskb_r64_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovq2m<AsmRegisterK, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovq2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovq2m_kr_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovq2m<AsmRegisterK, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovq2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovq2m_kr_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovq2m<AsmRegisterK, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovq2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovq2m_kr_zmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm16_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm16_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm32_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm32_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm64_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqb_xmmm64_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqd_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovqw<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovqw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovqw_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsdb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdb_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsdw<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsdw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsdw_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm16_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm16_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm32_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm32_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm64_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqb_xmmm64_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqd_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsqw<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovsqw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsqw_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovswb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovswb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovswb_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbd_xmm_xmmm32 } else { Code::EVEX_Vpmovsxbd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbd_ymm_xmmm64 } else { Code::EVEX_Vpmovsxbd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbd_zmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbd_xmm_xmmm32 } else { Code::EVEX_Vpmovsxbd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbd_ymm_xmmm64 } else { Code::EVEX_Vpmovsxbd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbd_zmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbq_xmm_xmmm16 } else { Code::EVEX_Vpmovsxbq_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbq_ymm_xmmm32 } else { Code::EVEX_Vpmovsxbq_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbq_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbq_xmm_xmmm16 } else { Code::EVEX_Vpmovsxbq_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbq_ymm_xmmm32 } else { Code::EVEX_Vpmovsxbq_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbq_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbw_xmm_xmmm64 } else { Code::EVEX_Vpmovsxbw_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbw_ymm_xmmm128 } else { Code::EVEX_Vpmovsxbw_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbw_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbw_xmm_xmmm64 } else { Code::EVEX_Vpmovsxbw_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxbw_ymm_xmmm128 } else { Code::EVEX_Vpmovsxbw_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxbw<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxbw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxbw_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxdq_xmm_xmmm64 } else { Code::EVEX_Vpmovsxdq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxdq_ymm_xmmm128 } else { Code::EVEX_Vpmovsxdq_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxdq_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxdq_xmm_xmmm64 } else { Code::EVEX_Vpmovsxdq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxdq_ymm_xmmm128 } else { Code::EVEX_Vpmovsxdq_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxdq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxdq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxdq_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxwd_xmm_xmmm64 } else { Code::EVEX_Vpmovsxwd_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxwd_ymm_xmmm128 } else { Code::EVEX_Vpmovsxwd_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxwd_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxwd_xmm_xmmm64 } else { Code::EVEX_Vpmovsxwd_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxwd_ymm_xmmm128 } else { Code::EVEX_Vpmovsxwd_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxwd_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxwq_xmm_xmmm32 } else { Code::EVEX_Vpmovsxwq_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxwq_ymm_xmmm64 } else { Code::EVEX_Vpmovsxwq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxwq_zmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxwq_xmm_xmmm32 } else { Code::EVEX_Vpmovsxwq_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovsxwq_ymm_xmmm64 } else { Code::EVEX_Vpmovsxwq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovsxwq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovsxwq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovsxwq_zmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusdb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdb_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusdw<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusdw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusdw_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm16_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm16_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm32_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm32_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm64_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqb_xmmm64_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqd_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm32_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm32_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm64_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm64_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<AsmRegisterXmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm128_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovusqw<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovusqw(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovusqw_xmmm128_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovuswb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovuswb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovuswb_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovw2m<AsmRegisterK, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovw2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovw2m_kr_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovw2m<AsmRegisterK, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovw2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovw2m_kr_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovw2m<AsmRegisterK, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovw2m(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::EVEX_Vpmovw2m_kr_zmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_xmmm64_k1z_xmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_xmmm64_k1z_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<AsmRegisterXmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_xmmm128_k1z_ymm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_xmmm128_k1z_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<AsmRegisterYmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_ymmm256_k1z_zmm, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovwb<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmovwb(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovwb_ymmm256_k1z_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbd_xmm_xmmm32 } else { Code::EVEX_Vpmovzxbd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbd_ymm_xmmm64 } else { Code::EVEX_Vpmovzxbd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbd_zmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbd_xmm_xmmm32 } else { Code::EVEX_Vpmovzxbd_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbd_ymm_xmmm64 } else { Code::EVEX_Vpmovzxbd_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbd_zmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbq_xmm_xmmm16 } else { Code::EVEX_Vpmovzxbq_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbq_ymm_xmmm32 } else { Code::EVEX_Vpmovzxbq_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbq_zmm_k1z_xmmm64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbq_xmm_xmmm16 } else { Code::EVEX_Vpmovzxbq_xmm_k1z_xmmm16 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbq_ymm_xmmm32 } else { Code::EVEX_Vpmovzxbq_ymm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbq_zmm_k1z_xmmm64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbw_xmm_xmmm64 } else { Code::EVEX_Vpmovzxbw_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbw_ymm_xmmm128 } else { Code::EVEX_Vpmovzxbw_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbw_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbw_xmm_xmmm64 } else { Code::EVEX_Vpmovzxbw_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxbw_ymm_xmmm128 } else { Code::EVEX_Vpmovzxbw_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxbw<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxbw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxbw_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxdq_xmm_xmmm64 } else { Code::EVEX_Vpmovzxdq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxdq_ymm_xmmm128 } else { Code::EVEX_Vpmovzxdq_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxdq_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxdq_xmm_xmmm64 } else { Code::EVEX_Vpmovzxdq_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxdq_ymm_xmmm128 } else { Code::EVEX_Vpmovzxdq_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxdq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxdq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxdq_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxwd_xmm_xmmm64 } else { Code::EVEX_Vpmovzxwd_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxwd_ymm_xmmm128 } else { Code::EVEX_Vpmovzxwd_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<AsmRegisterZmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxwd_zmm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxwd_xmm_xmmm64 } else { Code::EVEX_Vpmovzxwd_xmm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxwd_ymm_xmmm128 } else { Code::EVEX_Vpmovzxwd_ymm_k1z_xmmm128 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxwd_zmm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxwq_xmm_xmmm32 } else { Code::EVEX_Vpmovzxwq_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxwq_ymm_xmmm64 } else { Code::EVEX_Vpmovzxwq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxwq_zmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxwq_xmm_xmmm32 } else { Code::EVEX_Vpmovzxwq_xmm_k1z_xmmm32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmovzxwq_ymm_xmmm64 } else { Code::EVEX_Vpmovzxwq_ymm_k1z_xmmm64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmovzxwq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmovzxwq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpmovzxwq_zmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmuldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmuldq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmuldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmuldq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmuldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmuldq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmuldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmuldq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmuldq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmuldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmuldq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmuldq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuldq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmuldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmuldq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhrsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhrsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhrsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhrsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhrsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhrsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhrsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhrsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhrsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhrsw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhrsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhrsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhuw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhuw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhuw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhuw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhuw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhuw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhuw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulhw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulhw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulhw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulhw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulhw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulhw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmulld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmulld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmulld_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmulld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulld_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmulld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmulld_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmulld_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmulld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmulld_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmulld_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmulld<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmulld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmulld_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmullw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmullw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmullw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmullw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmullw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmullw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmullw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmullw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmullw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmullw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmullw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmultishiftqb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmultishiftqb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmultishiftqb_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpmuludq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmuludq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpmuludq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpmuludq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpmuludq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmuludq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmuludq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmuludq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpmuludq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpmuludq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpmuludq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpmuludq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpmuludq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpmuludq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpmuludq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntb<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntb(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntb_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntd_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntq<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntq_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_xmm_k1z_xmmm128, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_ymm_k1z_ymmm256, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_zmm_k1z_zmmm512, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_xmm_k1z_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_ymm_k1z_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpopcntw<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpopcntw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpopcntw_zmm_k1z_zmmm512, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpor<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpor(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpor_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpor<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpor(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpor_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpor<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpor(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpor_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpor<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpor(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpor_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpord<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpord(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpord_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVporq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vporq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vporq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpperm<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpperm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpperm_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register(), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpperm<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpperm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpperm_xmm_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpperm<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpperm(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::XOP_Vpperm_xmm_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register(), op3.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprold<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprold(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprold_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolq<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprolq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprolvq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprolvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprolvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprord<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprord(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprord_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorq<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprorq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprorvq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprorvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vprorvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotb<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprotb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotb_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprotd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprotq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVprotw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vprotw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vprotw_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsadbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsadbw_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsadbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsadbw_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsadbw_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsadbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsadbw_xmm_xmm_xmmm128 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsadbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsadbw_ymm_ymm_ymmm256 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsadbw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsadbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsadbw_zmm_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpscatterdd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdd_vm32x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpscatterdd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdd_vm32y_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpscatterdd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdd_vm32z_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdq<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpscatterdq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdq_vm32x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdq<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpscatterdq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdq_vm32x_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterdq<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpscatterdq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterdq_vm32y_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	fn vpscatterqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if op0.index().is_xmm() {
			Code::EVEX_Vpscatterqd_vm64x_k1_xmm
		} else if op0.index().is_ymm() {
			Code::EVEX_Vpscatterqd_vm64y_k1_xmm
		} else {
			return Err(IcedError::new("vpscatterqd: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpscatterqd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterqd_vm64z_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqq<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpscatterqq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterqq_vm64x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqq<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpscatterqq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterqq_vm64y_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpscatterqq<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpscatterqq(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vpscatterqq_vm64z_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshab<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshab(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshab_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshab<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshab(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshab_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshab<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshab(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshab_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshad<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshad(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshad_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshad<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshad(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshad_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshad<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshad(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshad_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshaq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaq_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaq<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshaq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaq_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshaq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshaw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaw_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaw<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshaw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaw_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshaw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshaw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshaw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlb_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlb<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlb(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlb_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshlb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshld<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshld_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshld<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshld(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshld_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshld<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshld_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldvw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshldvw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshldvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshldw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshldw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshldw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlq_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlq<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlq_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshlq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlq_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlw_xmm_xmmm128_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlw<AsmRegisterXmm, AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshlw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlw_xmm_xmmm128_xmm, op0.register(), op1.to_memory_operand(self.bitness()), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshlw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshlw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::XOP_Vpshlw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdvw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshrdvw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshrdvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_xmm_k1z_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_ymm_k1z_ymm_ymmm256_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshrdw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshrdw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpshrdw_zmm_k1z_zmm_zmmm512_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpshufb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpshufb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpshufb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpshufb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufbitqmb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpshufbitqmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufbitqmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufd_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vpshufd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpshufd_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vpshufd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpshufd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufd_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufd_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vpshufd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpshufd_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vpshufd_xmm_k1z_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vpshufd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpshufd_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vpshufd_ymm_k1z_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufd<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshufd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufd_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufhw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufhw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufhw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufhw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufhw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufhw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufhw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshufhw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshufhw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshufhw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshufhw<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshufhw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshufhw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshuflw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshuflw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshuflw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshuflw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshuflw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshuflw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshuflw_xmm_xmmm128_imm8 } else { Code::EVEX_Vpshuflw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpshuflw_ymm_ymmm256_imm8 } else { Code::EVEX_Vpshuflw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpshuflw<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpshuflw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpshuflw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsignb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsignb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignb_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignb_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsignd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsignd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignd_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignd_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsignw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsignw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignw_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsignw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsignw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpsignw_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpslld_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslld_ymm_ymm_xmmm128 } else { Code::EVEX_Vpslld_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpslld_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslld_ymm_ymm_xmmm128 } else { Code::EVEX_Vpslld_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslld_xmm_xmm_imm8 } else { Code::EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslld_ymm_ymm_imm8 } else { Code::EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslld_xmm_xmm_imm8 } else { Code::EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslld_ymm_ymm_imm8 } else { Code::EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslld<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslld(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpslld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslldq_xmm_xmm_imm8 } else { Code::EVEX_Vpslldq_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslldq_ymm_ymm_imm8 } else { Code::EVEX_Vpslldq_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_zmm_zmmm512_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_zmm_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslldq_xmm_xmm_imm8 } else { Code::EVEX_Vpslldq_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpslldq_ymm_ymm_imm8 } else { Code::EVEX_Vpslldq_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_zmm_zmmm512_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpslldq<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpslldq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpslldq_zmm_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllq_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllq_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsllq_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllq_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllq_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsllq_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllq_xmm_xmm_imm8 } else { Code::EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllq_ymm_ymm_imm8 } else { Code::EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllq_xmm_xmm_imm8 } else { Code::EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllq_ymm_ymm_imm8 } else { Code::EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllq<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllvd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsllvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllvd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsllvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsllvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsllvd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsllvd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsllvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsllvd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsllvd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllvq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsllvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllvq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsllvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsllvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsllvq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsllvq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsllvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsllvq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsllvq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllvw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllvw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsllw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsllw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsllw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllw_xmm_xmm_imm8 } else { Code::EVEX_Vpsllw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllw_ymm_ymm_imm8 } else { Code::EVEX_Vpsllw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllw_xmm_xmm_imm8 } else { Code::EVEX_Vpsllw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsllw_ymm_ymm_imm8 } else { Code::EVEX_Vpsllw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsllw<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsllw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsllw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrad_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrad_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrad_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrad_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrad_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrad_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrad_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrad_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrad_xmm_xmm_imm8 } else { Code::EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrad_ymm_ymm_imm8 } else { Code::EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrad_xmm_xmm_imm8 } else { Code::EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrad_ymm_ymm_imm8 } else { Code::EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrad<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrad(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrad_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraq<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsravd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsravd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsravd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsravd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsravd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsravd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsravd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsravd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsravd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsravd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsravd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsravw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsravw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsravw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsraw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsraw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsraw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsraw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsraw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsraw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsraw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsraw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsraw_xmm_xmm_imm8 } else { Code::EVEX_Vpsraw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsraw_ymm_ymm_imm8 } else { Code::EVEX_Vpsraw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsraw_xmm_xmm_imm8 } else { Code::EVEX_Vpsraw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsraw_ymm_ymm_imm8 } else { Code::EVEX_Vpsraw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsraw<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsraw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsraw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrld_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrld_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrld_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrld_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrld_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrld_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrld_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrld_xmm_xmm_imm8 } else { Code::EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrld_ymm_ymm_imm8 } else { Code::EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrld_xmm_xmm_imm8 } else { Code::EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrld_ymm_ymm_imm8 } else { Code::EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrld<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrld(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrld_zmm_k1z_zmmm512b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrldq_xmm_xmm_imm8 } else { Code::EVEX_Vpsrldq_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrldq_ymm_ymm_imm8 } else { Code::EVEX_Vpsrldq_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_zmm_zmmm512_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_zmm_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrldq_xmm_xmm_imm8 } else { Code::EVEX_Vpsrldq_xmm_xmmm128_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrldq_ymm_ymm_imm8 } else { Code::EVEX_Vpsrldq_ymm_ymmm256_imm8 };
		self.add_instr(Instruction::with3(code, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_zmm_zmmm512_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrldq<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrldq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::EVEX_Vpsrldq_zmm_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlq_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlq_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrlq_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlq_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlq_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrlq_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlq_xmm_xmm_imm8 } else { Code::EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlq_ymm_ymm_imm8 } else { Code::EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlq_xmm_xmm_imm8 } else { Code::EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlq_ymm_ymm_imm8 } else { Code::EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlq<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlq(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlq_zmm_k1z_zmmm512b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlvd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsrlvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlvd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsrlvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsrlvd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsrlvd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsrlvd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsrlvd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsrlvd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsrlvd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlvq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsrlvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlvq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsrlvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsrlvq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsrlvq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsrlvq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsrlvq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsrlvq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsrlvq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_xmm_k1z_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_ymm_k1z_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlvw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlvw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlvw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrlw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsrlw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlw_ymm_ymm_xmmm128 } else { Code::EVEX_Vpsrlw_ymm_k1z_ymm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlw_xmm_xmm_imm8 } else { Code::EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlw_ymm_ymm_imm8 } else { Code::EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlw_xmm_xmm_imm8 } else { Code::EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsrlw_ymm_ymm_imm8 } else { Code::EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_xmm_k1z_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_ymm_k1z_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsrlw<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpsrlw(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsrlw_zmm_k1z_zmmm512_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsubd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsubd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsubd_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsubd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsubd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsubd_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubd_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsubq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsubq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpsubq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpsubq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpsubq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpsubq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubsb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubsb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubsb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubsb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubsb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubsw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubsw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubsw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubsw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubsw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubsw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubsw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubusb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubusb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubusb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubusb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubusb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubusb_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubusb_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubusb_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubusb_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusb<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusb(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubusb_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubusw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubusw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubusw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubusw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubusw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubusw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubusw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubusw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubusw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubusw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubusw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubusw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpsubw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpsubw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpsubw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpsubw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpsubw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpsubw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogd_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpternlogq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vpternlogq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vpternlogq_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptest<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptest(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vptest_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVptest<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptest(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vptest_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVptest<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptest(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vptest_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVptest<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptest(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vptest_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestmw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestmw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmb<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmb(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmb_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmd<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmd(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmd_kr_k1_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmq<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmq(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmq_kr_k1_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<AsmRegisterK, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<AsmRegisterK, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<AsmRegisterK, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<AsmRegisterK, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<AsmRegisterK, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVptestnmw<AsmRegisterK, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vptestnmw(&mut self, op0: AsmRegisterK, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vptestnmw_kr_k1_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhbw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhbw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhbw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhbw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhbw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhbw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhbw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckhdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhdq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckhdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhdq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckhdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhdq_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpunpckhdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpunpckhdq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpunpckhdq_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpunpckhdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpunpckhdq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpunpckhdq_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhdq_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhqdq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckhqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhqdq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckhqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhqdq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpunpckhqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpunpckhqdq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpunpckhqdq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpunpckhqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpunpckhqdq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpunpckhqdq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhqdq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckhwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckhwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckhwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckhwd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckhwd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckhwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklbw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklbw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklbw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklbw_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklbw_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklbw_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklbw_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklbw<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklbw(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklbw_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpckldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckldq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpckldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpckldq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpckldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckldq_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpunpckldq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpunpckldq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpunpckldq_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpunpckldq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpunpckldq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpunpckldq_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpckldq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpckldq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpckldq_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpcklqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklqdq_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpcklqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklqdq_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpcklqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklqdq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vpunpcklqdq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpunpcklqdq_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vpunpcklqdq_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vpunpcklqdq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vpunpcklqdq_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vpunpcklqdq_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklqdq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklqdq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklqdq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklwd_xmm_xmm_xmmm128 } else { Code::EVEX_Vpunpcklwd_xmm_k1z_xmm_xmmm128 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vpunpcklwd_ymm_ymm_ymmm256 } else { Code::EVEX_Vpunpcklwd_ymm_k1z_ymm_ymmm256 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpunpcklwd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpunpcklwd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpunpcklwd_zmm_k1z_zmm_zmmm512, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxor<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpxor(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpxor_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpxor<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpxor(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpxor_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpxor<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxor(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpxor_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpxor<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxor(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vpxor_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxord<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxord(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxord_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVpxorq<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vpxorq(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vpxorq_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_xmm_k1z_xmm_xmmm128b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangepd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangepd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangepd_zmm_k1z_zmm_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_xmm_k1z_xmm_xmmm128b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangeps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangeps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangeps_zmm_k1z_zmm_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrangesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrangesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangess<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrangess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangess<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrangess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangess<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrangess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrangess<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrangess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrangess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14pd_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14ps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp14ps_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp14sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp14sd_xmm_k1z_xmm_xmmm64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp14sd_xmm_k1z_xmm_xmmm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp14ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp14ss_xmm_k1z_xmm_xmmm32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp14ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp14ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp14ss_xmm_k1z_xmm_xmmm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28pd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcp28pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp28pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp28pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp28pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28ps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcp28ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp28ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28ps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp28ps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcp28ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp28sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp28sd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp28sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp28sd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcp28ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp28ss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcp28ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcp28ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcp28ss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_zmm_k1z_zmmm512b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpph<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrcpph_zmm_k1z_zmmm512b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcpps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrcpps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrcpps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrcpps_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrcpps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrcpps_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcpsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcpsh_xmm_k1z_xmm_xmmm16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrcpsh_xmm_k1z_xmm_xmmm16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrcpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vrcpss_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrcpss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrcpss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vrcpss_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducepd<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducepd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreducepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceph<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreduceps<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreduceps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vreduceps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreducesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreducesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreducesh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducesh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreducesh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducesh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducesh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducess<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vreducess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducess<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vreducess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducess<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vreducess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVreducess<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vreducess(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vreducess_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_xmm_k1z_xmmm128b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_ymm_k1z_ymmm256b64_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalepd<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalepd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscalepd_zmm_k1z_zmmm512b64_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_xmm_k1z_xmmm128b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_ymm_k1z_ymmm256b16_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleph<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleph_zmm_k1z_zmmm512b16_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.register(), op2)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.register(), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_xmm_k1z_xmmm128b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_ymm_k1z_ymmm256b32_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaleps<AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaleps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrndscaleps_zmm_k1z_zmmm512b32_imm8_sae, op0.register(), op1.to_memory_operand(self.bitness()), op2)?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalesd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesd_xmm_k1z_xmm_xmmm64_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscalesh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscalesh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscalesh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscalesh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscalesh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscalesh_xmm_k1z_xmm_xmmm16_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaless<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vrndscaless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaless<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vrndscaless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaless<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vrndscaless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.register(), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrndscaless<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vrndscaless(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vrndscaless_xmm_k1z_xmm_xmmm32_imm8_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_ymm_ymmm256_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_ymm_ymmm256_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundpd<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundpd_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_ymm_ymmm256_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_xmm_xmmm128_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_ymm_ymmm256_imm8, op0.register(), op1.register(), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_xmm_xmmm128_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundps<AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand, op2: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vroundps_ymm_ymmm256_imm8, op0.register(), op1.to_memory_operand(self.bitness()), op2)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vroundsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vroundsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundsd_xmm_xmm_xmmm64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vroundss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vroundss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vroundss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVroundss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vroundss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vroundss_xmm_xmm_xmmm32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_xmm_k1z_xmmm128b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_ymm_k1z_ymmm256b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_zmm_k1z_zmmm512b64, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_xmm_k1z_xmmm128b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_ymm_k1z_ymmm256b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14pd_zmm_k1z_zmmm512b64, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_xmm_k1z_xmmm128b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_ymm_k1z_ymmm256b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_zmm_k1z_zmmm512b32, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_xmm_k1z_xmmm128b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_ymm_k1z_ymmm256b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14ps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt14ps_zmm_k1z_zmmm512b32, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt14sd_xmm_k1z_xmm_xmmm64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt14sd_xmm_k1z_xmm_xmmm64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt14ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt14ss_xmm_k1z_xmm_xmmm32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt14ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt14ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt14ss_xmm_k1z_xmm_xmmm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28pd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrt28pd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt28pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28pd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt28pd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt28pd_zmm_k1z_zmmm512b64_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28ps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrt28ps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt28ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28ps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt28ps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrt28ps_zmm_k1z_zmmm512b32_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28sd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt28sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt28sd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28sd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt28sd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt28sd_xmm_k1z_xmm_xmmm64_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28ss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrt28ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt28ss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrt28ss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrt28ss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrt28ss_xmm_k1z_xmm_xmmm32_sae, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_zmm_k1z_zmmm512b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtph<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vrsqrtph_zmm_k1z_zmmm512b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrtps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrsqrtps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vrsqrtps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrsqrtps_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrsqrtps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vrsqrtps_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrtsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrtsh_xmm_k1z_xmm_xmmm16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vrsqrtsh_xmm_k1z_xmm_xmmm16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vrsqrtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vrsqrtss_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVrsqrtss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vrsqrtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vrsqrtss_xmm_xmm_xmmm32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_xmm_k1z_xmm_xmmm128b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_ymm_k1z_ymm_ymmm256b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_xmm_k1z_xmm_xmmm128b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_ymm_k1z_ymm_ymmm256b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefsd_xmm_k1z_xmm_xmmm64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefsd_xmm_k1z_xmm_xmmm64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscalefss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefss_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscalefss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscalefss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vscalefss_xmm_k1z_xmm_xmmm32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdpd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscatterdpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdpd_vm32x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdpd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscatterdpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdpd_vm32x_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdpd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscatterdpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdpd_vm32y_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscatterdps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdps_vm32x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdps<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscatterdps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdps_vm32y_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterdps<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscatterdps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterdps_vm32z_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf0dpd<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf0dpd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf0dpd_vm32y_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf0dps<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf0dps(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf0dps_vm32z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf0qpd<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf0qpd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf0qpd_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf0qps<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf0qps(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf0qps_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf1dpd<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf1dpd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf1dpd_vm32y_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf1dps<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf1dps(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf1dps_vm32z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf1qpd<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf1qpd(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf1qpd_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterpf1qps<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vscatterpf1qps(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with1(Code::EVEX_Vscatterpf1qps_vm64z_k1, op0.to_memory_operand(self.bitness()))?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqpd<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vscatterqpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterqpd_vm64x_k1_xmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqpd<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscatterqpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterqpd_vm64y_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqpd<AsmMemoryOperand, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vscatterqpd(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterqpd_vm64z_k1_zmm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqps<AsmMemoryOperand, AsmRegisterXmm> for CodeAssembler {
	fn vscatterqps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if op0.index().is_xmm() {
			Code::EVEX_Vscatterqps_vm64x_k1_xmm
		} else if op0.index().is_ymm() {
			Code::EVEX_Vscatterqps_vm64y_k1_xmm
		} else {
			return Err(IcedError::new("vscatterqps: invalid operands"));
		};
		self.add_instr_with_state(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVscatterqps<AsmMemoryOperand, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vscatterqps(&mut self, op0: AsmMemoryOperand, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vscatterqps_vm64z_k1_ymm, op0.to_memory_operand(self.bitness()), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsha512msg1<AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsha512msg1(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vsha512msg1_ymm_xmm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsha512msg2<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsha512msg2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vsha512msg2_ymm_ymm, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsha512rnds2<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsha512rnds2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsha512rnds2_ymm_ymm_xmm, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff32x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshuff32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshuff64x2<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshuff64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshuff64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_ymm_k1z_ymm_ymmm256b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi32x4<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufi32x4(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi32x4_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_ymm_k1z_ymm_ymmm256b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufi64x2<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufi64x2(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufi64x2_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vshufpd_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vshufpd_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vshufpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vshufpd_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vshufpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vshufpd_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vshufpd_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vshufpd_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vshufpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vshufpd_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vshufpd_xmm_k1z_xmm_xmmm128b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vshufpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vshufpd_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vshufpd_ymm_k1z_ymm_ymmm256b64_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufpd_zmm_k1z_zmm_zmmm512b64_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vshufps_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, i32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: i32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vshufps_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, i32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vshufps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vshufps_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, i32> for CodeAssembler {
	fn vshufps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vshufps_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vshufps_xmm_xmm_xmmm128_imm8 } else { Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm, u32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm, op3: u32) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vshufps_ymm_ymm_ymmm256_imm8 } else { Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8 };
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm, u32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.register(), op3)?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vshufps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vshufps_xmm_xmm_xmmm128_imm8
		} else {
			Code::EVEX_Vshufps_xmm_k1z_xmm_xmmm128b32_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand, u32> for CodeAssembler {
	fn vshufps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vshufps_ymm_ymm_ymmm256_imm8
		} else {
			Code::EVEX_Vshufps_ymm_k1z_ymm_ymmm256b32_imm8
		};
		self.add_instr_with_state(Instruction::with4(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVshufps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vshufps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with4(Code::EVEX_Vshufps_zmm_k1z_zmm_zmmm512b32_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsm3msg1<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsm3msg1(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm3msg1_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm3msg1<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsm3msg1(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm3msg1_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm3msg2<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsm3msg2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm3msg2_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm3msg2<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsm3msg2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm3msg2_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm3rnds2<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, i32> for CodeAssembler {
	#[inline]
	fn vsm3rnds2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vsm3rnds2_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm3rnds2<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, i32> for CodeAssembler {
	#[inline]
	fn vsm3rnds2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vsm3rnds2_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm3rnds2<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm, u32> for CodeAssembler {
	#[inline]
	fn vsm3rnds2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vsm3rnds2_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.register(), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm3rnds2<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand, u32> for CodeAssembler {
	#[inline]
	fn vsm3rnds2(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand, op3: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with4(Code::VEX_Vsm3rnds2_xmm_xmm_xmmm128_imm8, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()), op3)?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm4key4<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsm4key4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm4key4_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm4key4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsm4key4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm4key4_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm4key4<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsm4key4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm4key4_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm4key4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsm4key4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm4key4_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm4rnds4<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsm4rnds4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm4rnds4_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm4rnds4<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsm4rnds4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm4rnds4_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm4rnds4<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsm4rnds4(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm4rnds4_xmm_xmm_xmmm128, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsm4rnds4<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsm4rnds4(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with3(Code::VEX_Vsm4rnds4_ymm_ymm_ymmm256, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsqrtpd_xmm_xmmm128 } else { Code::EVEX_Vsqrtpd_xmm_k1z_xmmm128b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsqrtpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsqrtpd_ymm_ymmm256 } else { Code::EVEX_Vsqrtpd_ymm_k1z_ymmm256b64 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsqrtpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtpd_zmm_k1z_zmmm512b64_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vsqrtpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vsqrtpd_xmm_k1z_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vsqrtpd_xmm_xmmm128
		} else {
			Code::EVEX_Vsqrtpd_xmm_k1z_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vsqrtpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vsqrtpd_ymm_k1z_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vsqrtpd_ymm_ymmm256
		} else {
			Code::EVEX_Vsqrtpd_ymm_k1z_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtpd<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtpd(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtpd_zmm_k1z_zmmm512b64_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_xmm_k1z_xmmm128b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_ymm_k1z_ymmm256b16, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_zmm_k1z_zmmm512b16_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_xmm_k1z_xmmm128b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_ymm_k1z_ymmm256b16, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtph<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtph(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtph_zmm_k1z_zmmm512b16_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsqrtps_xmm_xmmm128 } else { Code::EVEX_Vsqrtps_xmm_k1z_xmmm128b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsqrtps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsqrtps_ymm_ymmm256 } else { Code::EVEX_Vsqrtps_ymm_k1z_ymmm256b32 };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsqrtps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtps_zmm_k1z_zmmm512b32_er, op0.register(), op1.register())?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vsqrtps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vsqrtps_xmm_k1z_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vsqrtps_xmm_xmmm128
		} else {
			Code::EVEX_Vsqrtps_xmm_k1z_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vsqrtps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op1.is_broadcast() {
			Code::EVEX_Vsqrtps_ymm_k1z_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vsqrtps_ymm_ymmm256
		} else {
			Code::EVEX_Vsqrtps_ymm_k1z_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtps<AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtps(&mut self, op0: AsmRegisterZmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vsqrtps_zmm_k1z_zmmm512b32_er, op0.register(), op1.to_memory_operand(self.bitness()))?, op0.state().merge(op1.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsqrtsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vsqrtsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsqrtsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vsqrtsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsqrtsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsqrtsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsqrtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsqrtss_xmm_xmm_xmmm32 } else { Code::EVEX_Vsqrtss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsqrtss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsqrtss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsqrtss_xmm_xmm_xmmm32 } else { Code::EVEX_Vsqrtss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVstmxcsr<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vstmxcsr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::VEX_Vstmxcsr_m32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsubpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsubpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsubpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vsubpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vsubpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vsubpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vsubpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vsubpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vsubpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubpd_zmm_k1z_zmm_zmmm512b64_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_xmm_k1z_xmm_xmmm128b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_ymm_k1z_ymm_ymmm256b16, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubph<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubph(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubph_zmm_k1z_zmm_zmmm512b16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsubps_xmm_xmm_xmmm128 } else { Code::EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsubps_ymm_ymm_ymmm256 } else { Code::EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vsubps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vsubps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vsubps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vsubps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vsubps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vsubps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vsubps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubps_zmm_k1z_zmm_zmmm512b32_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubsd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsubsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vsubsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubsd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubsd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsubsd_xmm_xmm_xmmm64 } else { Code::EVEX_Vsubsd_xmm_k1z_xmm_xmmm64_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubsh<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubsh<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubsh(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vsubsh_xmm_k1z_xmm_xmmm16_er, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubss<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vsubss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsubss_xmm_xmm_xmmm32 } else { Code::EVEX_Vsubss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVsubss<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vsubss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vsubss_xmm_xmm_xmmm32 } else { Code::EVEX_Vsubss_xmm_k1z_xmm_xmmm32_er };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVtestpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vtestpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestpd<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vtestpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestpd_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vtestpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestpd<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vtestpd(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestpd_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vtestps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestps<AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vtestps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestps_ymm_ymmm256, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vtestps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVtestps<AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vtestps(&mut self, op0: AsmRegisterYmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::VEX_Vtestps_ymm_ymmm256, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmVucomisd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vucomisd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vucomisd_xmm_xmmm64 } else { Code::EVEX_Vucomisd_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomisd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vucomisd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vucomisd_xmm_xmmm64 } else { Code::EVEX_Vucomisd_xmm_xmmm64_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomish<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vucomish(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vucomish_xmm_xmmm16_sae, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomish<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vucomish(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with2(Code::EVEX_Vucomish_xmm_xmmm16_sae, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomiss<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vucomiss(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vucomiss_xmm_xmmm32 } else { Code::EVEX_Vucomiss_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.register())?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVucomiss<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vucomiss(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vucomiss_xmm_xmmm32 } else { Code::EVEX_Vucomiss_xmm_xmmm32_sae };
		self.add_instr_with_state(Instruction::with2(code, op0.register(), op1.to_memory_operand(self.bitness()))?, op1.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vunpckhpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vunpckhpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vunpckhpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vunpckhpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vunpckhpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpckhpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vunpckhpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vunpckhpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vunpckhpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vunpckhpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vunpckhpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vunpckhpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vunpckhpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpckhpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vunpckhps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vunpckhps_xmm_xmm_xmmm128 } else { Code::EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vunpckhps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vunpckhps_ymm_ymm_ymmm256 } else { Code::EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vunpckhps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpckhps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vunpckhps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vunpckhps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vunpckhps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vunpckhps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vunpckhps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vunpckhps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpckhps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vunpckhps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpckhps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vunpcklpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vunpcklpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vunpcklpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vunpcklpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vunpcklpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpcklpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vunpcklpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vunpcklpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vunpcklpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vunpcklpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vunpcklpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vunpcklpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vunpcklpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpcklpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vunpcklps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vunpcklps_xmm_xmm_xmmm128 } else { Code::EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vunpcklps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vunpcklps_ymm_ymm_ymmm256 } else { Code::EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vunpcklps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpcklps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vunpcklps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vunpcklps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vunpcklps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vunpcklps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vunpcklps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vunpcklps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVunpcklps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vunpcklps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vunpcklps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vxorpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vxorpd_xmm_xmm_xmmm128 } else { Code::EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vxorpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vxorpd_ymm_ymm_ymmm256 } else { Code::EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vxorpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vxorpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vxorpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vxorpd_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vxorpd_xmm_k1z_xmm_xmmm128b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vxorpd(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vxorpd_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vxorpd_ymm_k1z_ymm_ymmm256b64
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorpd<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vxorpd(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vxorpd_zmm_k1z_zmm_zmmm512b64, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<AsmRegisterXmm, AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn vxorps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmRegisterXmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vxorps_xmm_xmm_xmmm128 } else { Code::EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<AsmRegisterYmm, AsmRegisterYmm, AsmRegisterYmm> for CodeAssembler {
	#[inline]
	fn vxorps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmRegisterYmm) -> Result<(), IcedError> {
		let code = if self.instruction_prefer_vex() { Code::VEX_Vxorps_ymm_ymm_ymmm256 } else { Code::EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32 };
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<AsmRegisterZmm, AsmRegisterZmm, AsmRegisterZmm> for CodeAssembler {
	#[inline]
	fn vxorps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmRegisterZmm) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vxorps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.register())?, op0.state())
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<AsmRegisterXmm, AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	fn vxorps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vxorps_xmm_xmm_xmmm128
		} else {
			Code::EVEX_Vxorps_xmm_k1z_xmm_xmmm128b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<AsmRegisterYmm, AsmRegisterYmm, AsmMemoryOperand> for CodeAssembler {
	fn vxorps(&mut self, op0: AsmRegisterYmm, op1: AsmRegisterYmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		let code = if op2.is_broadcast() {
			Code::EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32
		} else if self.instruction_prefer_vex() {
			Code::VEX_Vxorps_ymm_ymm_ymmm256
		} else {
			Code::EVEX_Vxorps_ymm_k1z_ymm_ymmm256b32
		};
		self.add_instr_with_state(Instruction::with3(code, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVxorps<AsmRegisterZmm, AsmRegisterZmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn vxorps(&mut self, op0: AsmRegisterZmm, op1: AsmRegisterZmm, op2: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr_with_state(Instruction::with3(Code::EVEX_Vxorps_zmm_k1z_zmm_zmmm512b32, op0.register(), op1.register(), op2.to_memory_operand(self.bitness()))?, op0.state().merge(op2.state()))
	}
}

#[rustfmt::skip]
impl CodeAsmVzeroall for CodeAssembler {
	#[inline]
	fn vzeroall(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::VEX_Vzeroall))
	}
}

#[rustfmt::skip]
impl CodeAsmVzeroupper for CodeAssembler {
	#[inline]
	fn vzeroupper(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::VEX_Vzeroupper))
	}
}

#[rustfmt::skip]
impl CodeAsmWait for CodeAssembler {
	#[inline]
	fn wait(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wait))
	}
}

#[rustfmt::skip]
impl CodeAsmWbinvd for CodeAssembler {
	#[inline]
	fn wbinvd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wbinvd))
	}
}

#[rustfmt::skip]
impl CodeAsmWbnoinvd for CodeAssembler {
	#[inline]
	fn wbnoinvd(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wbnoinvd))
	}
}

#[rustfmt::skip]
impl CodeAsmWrfsbase<AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrfsbase(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrfsbase_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrfsbase<AsmRegister64> for CodeAssembler {
	#[inline]
	fn wrfsbase(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrfsbase_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrgsbase<AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrgsbase(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrgsbase_r32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrgsbase<AsmRegister64> for CodeAssembler {
	#[inline]
	fn wrgsbase(&mut self, op0: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrgsbase_r64, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrmsr for CodeAssembler {
	#[inline]
	fn wrmsr(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wrmsr))
	}
}

#[rustfmt::skip]
impl CodeAsmWrmsrlist for CodeAssembler {
	#[inline]
	fn wrmsrlist(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wrmsrlist))
	}
}

#[rustfmt::skip]
impl CodeAsmWrmsrns for CodeAssembler {
	#[inline]
	fn wrmsrns(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wrmsrns))
	}
}

#[rustfmt::skip]
impl CodeAsmWrpkru for CodeAssembler {
	#[inline]
	fn wrpkru(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wrpkru))
	}
}

#[rustfmt::skip]
impl CodeAsmWrshr<AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrshr(&mut self, op0: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrshr_rm32, op0.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrshr<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn wrshr(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Wrshr_rm32, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrssd<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrssd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Wrssd_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrssq<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn wrssq(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Wrssq_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrudbg for CodeAssembler {
	#[inline]
	fn wrudbg(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Wrudbg))
	}
}

#[rustfmt::skip]
impl CodeAsmWrussd<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn wrussd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Wrussd_m32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmWrussq<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn wrussq(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Wrussq_m64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXabort<i32> for CodeAssembler {
	#[inline]
	fn xabort(&mut self, op0: i32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xabort_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXabort<u32> for CodeAssembler {
	#[inline]
	fn xabort(&mut self, op0: u32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xabort_imm8, op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXadd<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn xadd(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xadd_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbegin<CodeLabel> for CodeAssembler {
	#[inline]
	fn xbegin(&mut self, op0: CodeLabel) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_xbegin(self.bitness(), op0.id())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbegin<u64> for CodeAssembler {
	#[inline]
	fn xbegin(&mut self, op0: u64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with_xbegin(self.bitness(), op0)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbts<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn xbts(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xbts_r16_rm16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbts<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn xbts(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xbts_r32_rm32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbts<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xbts(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xbts_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXbts<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xbts(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xbts_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		let code = if op1.register() == Register::AX { Code::Xchg_r16_AX } else { Code::Xchg_rm16_r16 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		let code = if op1.register() == Register::EAX { Code::Xchg_r32_EAX } else { Code::Xchg_rm32_r32 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		let code = if op1.register() == Register::RAX { Code::Xchg_r64_RAX } else { Code::Xchg_rm64_r64 };
		self.add_instr(Instruction::with2(code, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXchg<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn xchg(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xchg_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptcbc for CodeAssembler {
	fn xcryptcbc(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptcbc_64
		} else if self.bitness() >= 32 {
			Code::Xcryptcbc_32
		} else {
			Code::Xcryptcbc_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptcfb for CodeAssembler {
	fn xcryptcfb(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptcfb_64
		} else if self.bitness() >= 32 {
			Code::Xcryptcfb_32
		} else {
			Code::Xcryptcfb_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptctr for CodeAssembler {
	fn xcryptctr(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptctr_64
		} else if self.bitness() >= 32 {
			Code::Xcryptctr_32
		} else {
			Code::Xcryptctr_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptecb for CodeAssembler {
	fn xcryptecb(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptecb_64
		} else if self.bitness() >= 32 {
			Code::Xcryptecb_32
		} else {
			Code::Xcryptecb_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXcryptofb for CodeAssembler {
	fn xcryptofb(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xcryptofb_64
		} else if self.bitness() >= 32 {
			Code::Xcryptofb_32
		} else {
			Code::Xcryptofb_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXend for CodeAssembler {
	#[inline]
	fn xend(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xend))
	}
}

#[rustfmt::skip]
impl CodeAsmXgetbv for CodeAssembler {
	#[inline]
	fn xgetbv(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xgetbv))
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister8, AsmRegister8> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister8, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm8_r8, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmMemoryOperand, AsmRegister8> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmMemoryOperand, op1: AsmRegister8) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm8_r8, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister16, AsmRegister16> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister16, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm16_r16, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmMemoryOperand, AsmRegister16> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmMemoryOperand, op1: AsmRegister16) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm16_r16, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister32, AsmRegister32> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister32, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm32_r32, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmMemoryOperand, AsmRegister32> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmMemoryOperand, op1: AsmRegister32) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm32_r32, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister64, AsmRegister64> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister64, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm64_r64, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmMemoryOperand, AsmRegister64> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmMemoryOperand, op1: AsmRegister64) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_rm64_r64, op0.to_memory_operand(self.bitness()), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister8, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister8, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_r8_rm8, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister16, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister16, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_r16_rm16, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister32, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister32, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_r32_rm32, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister64, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister64, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xor_r64_rm64, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister8, i32> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister8, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Xor_AL_imm8 } else { Code::Xor_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister16, i32> for CodeAssembler {
	fn xor(&mut self, op0: AsmRegister16, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Xor_AX_imm16
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Xor_rm16_imm8
		} else {
			Code::Xor_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister32, i32> for CodeAssembler {
	fn xor(&mut self, op0: AsmRegister32, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Xor_EAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Xor_rm32_imm8
		} else {
			Code::Xor_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister64, i32> for CodeAssembler {
	fn xor(&mut self, op0: AsmRegister64, op1: i32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::RAX {
			Code::Xor_RAX_imm32
		} else if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 {
			Code::Xor_rm64_imm8
		} else {
			Code::Xor_rm64_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmMemoryOperand, i32> for CodeAssembler {
	fn xor(&mut self, op0: AsmMemoryOperand, op1: i32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Qword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Xor_rm64_imm8 } else { Code::Xor_rm64_imm32 }
		} else if op0.size() == MemoryOperandSize::Dword {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Xor_rm32_imm8 } else { Code::Xor_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 >= i8::MIN as i32 && op1 <= i8::MAX as i32 { Code::Xor_rm16_imm8 } else { Code::Xor_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Xor_rm8_imm8
		} else {
			return Err(IcedError::new("xor: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister8, u32> for CodeAssembler {
	#[inline]
	fn xor(&mut self, op0: AsmRegister8, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AL { Code::Xor_AL_imm8 } else { Code::Xor_rm8_imm8 };
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister16, u32> for CodeAssembler {
	fn xor(&mut self, op0: AsmRegister16, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::AX {
			Code::Xor_AX_imm16
		} else if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) {
			Code::Xor_rm16_imm8
		} else {
			Code::Xor_rm16_imm16
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmRegister32, u32> for CodeAssembler {
	fn xor(&mut self, op0: AsmRegister32, op1: u32) -> Result<(), IcedError> {
		let code = if op0.register() == Register::EAX {
			Code::Xor_EAX_imm32
		} else if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 {
			Code::Xor_rm32_imm8
		} else {
			Code::Xor_rm32_imm32
		};
		self.add_instr(Instruction::with2(code, op0.register(), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXor<AsmMemoryOperand, u32> for CodeAssembler {
	fn xor(&mut self, op0: AsmMemoryOperand, op1: u32) -> Result<(), IcedError> {
		let code = if op0.size() == MemoryOperandSize::Dword {
			if op1 <= i8::MAX as u32 || 0xFFFF_FF80 <= op1 { Code::Xor_rm32_imm8 } else { Code::Xor_rm32_imm32 }
		} else if op0.size() == MemoryOperandSize::Word {
			if op1 <= i8::MAX as u32 || (0xFF80 <= op1 && op1 <= 0xFFFF) { Code::Xor_rm16_imm8 } else { Code::Xor_rm16_imm16 }
		} else if op0.size() == MemoryOperandSize::Byte {
			Code::Xor_rm8_imm8
		} else {
			return Err(IcedError::new("xor: invalid operands"));
		};
		self.add_instr(Instruction::with2(code, op0.to_memory_operand(self.bitness()), op1)?)
	}
}

#[rustfmt::skip]
impl CodeAsmXorpd<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn xorpd(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xorpd_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXorpd<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xorpd(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xorpd_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXorps<AsmRegisterXmm, AsmRegisterXmm> for CodeAssembler {
	#[inline]
	fn xorps(&mut self, op0: AsmRegisterXmm, op1: AsmRegisterXmm) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xorps_xmm_xmmm128, op0.register(), op1.register())?)
	}
}

#[rustfmt::skip]
impl CodeAsmXorps<AsmRegisterXmm, AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xorps(&mut self, op0: AsmRegisterXmm, op1: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with2(Code::Xorps_xmm_xmmm128, op0.register(), op1.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXresldtrk for CodeAssembler {
	#[inline]
	fn xresldtrk(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xresldtrk))
	}
}

#[rustfmt::skip]
impl CodeAsmXrstor<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xrstor(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xrstor_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXrstor64<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xrstor64(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xrstor64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXrstors<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xrstors(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xrstors_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXrstors64<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xrstors64(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xrstors64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsave<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsave(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsave_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsave64<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsave64(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsave64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsavec<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsavec(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsavec_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsavec64<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsavec64(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsavec64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsaveopt<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsaveopt(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsaveopt_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsaveopt64<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsaveopt64(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsaveopt64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsaves<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsaves(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsaves_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsaves64<AsmMemoryOperand> for CodeAssembler {
	#[inline]
	fn xsaves64(&mut self, op0: AsmMemoryOperand) -> Result<(), IcedError> {
		self.add_instr(Instruction::with1(Code::Xsaves64_mem, op0.to_memory_operand(self.bitness()))?)
	}
}

#[rustfmt::skip]
impl CodeAsmXsetbv for CodeAssembler {
	#[inline]
	fn xsetbv(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xsetbv))
	}
}

#[rustfmt::skip]
impl CodeAsmXsha1 for CodeAssembler {
	fn xsha1(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xsha1_64
		} else if self.bitness() >= 32 {
			Code::Xsha1_32
		} else {
			Code::Xsha1_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXsha256 for CodeAssembler {
	fn xsha256(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xsha256_64
		} else if self.bitness() >= 32 {
			Code::Xsha256_32
		} else {
			Code::Xsha256_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXsha512 for CodeAssembler {
	fn xsha512(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xsha512_64
		} else if self.bitness() >= 32 {
			Code::Xsha512_32
		} else {
			Code::Xsha512_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXsha512_alt for CodeAssembler {
	fn xsha512_alt(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xsha512_alt_64
		} else if self.bitness() >= 32 {
			Code::Xsha512_alt_32
		} else {
			Code::Xsha512_alt_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXstore for CodeAssembler {
	fn xstore(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xstore_64
		} else if self.bitness() >= 32 {
			Code::Xstore_32
		} else {
			Code::Xstore_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXstore_alt for CodeAssembler {
	fn xstore_alt(&mut self) -> Result<(), IcedError> {
		let code = if self.bitness() == 64 {
			Code::Xstore_alt_64
		} else if self.bitness() >= 32 {
			Code::Xstore_alt_32
		} else {
			Code::Xstore_alt_16
		};
		self.add_instr(Instruction::with(code))
	}
}

#[rustfmt::skip]
impl CodeAsmXsusldtrk for CodeAssembler {
	#[inline]
	fn xsusldtrk(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xsusldtrk))
	}
}

#[rustfmt::skip]
impl CodeAsmXtest for CodeAssembler {
	#[inline]
	fn xtest(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Xtest))
	}
}

#[rustfmt::skip]
impl CodeAsmZero_bytes for CodeAssembler {
	#[inline]
	fn zero_bytes(&mut self) -> Result<(), IcedError> {
		self.add_instr(Instruction::with(Code::Zero_bytes))
	}
}
