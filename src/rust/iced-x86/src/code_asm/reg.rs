// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

// âš ï¸This file was generated by GENERATOR!ğŸ¦¹â€â™‚ï¸

use crate::code_asm::op_state::CodeAsmOpState;
use crate::Register;

/// All 8-bit general purpose registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::gpr8::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegister8 {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegister8 {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegister8> for Register {
	#[inline]
	fn from(reg: __AsmRegister8) -> Self {
		reg.register
	}
}

/// All 16-bit general purpose registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::gpr16::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegister16 {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegister16 {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegister16> for Register {
	#[inline]
	fn from(reg: __AsmRegister16) -> Self {
		reg.register
	}
}

/// All 32-bit general purpose registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::gpr32::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
pub struct __AsmRegister32 {
	register: Register,
	state: CodeAsmOpState,
}

#[rustfmt::skip]
impl __AsmRegister32 {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register, state: CodeAsmOpState::new() }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}

	#[must_use]
	#[inline]
	pub(crate) fn state(&self) -> CodeAsmOpState {
		self.state
	}

	/// Adds a `{k1}` opmask register
	#[must_use]
	#[inline]
	pub fn k1(mut self) -> Self {
		self.state.set_k1();
		self
	}

	/// Adds a `{k2}` opmask register
	#[must_use]
	#[inline]
	pub fn k2(mut self) -> Self {
		self.state.set_k2();
		self
	}

	/// Adds a `{k3}` opmask register
	#[must_use]
	#[inline]
	pub fn k3(mut self) -> Self {
		self.state.set_k3();
		self
	}

	/// Adds a `{k4}` opmask register
	#[must_use]
	#[inline]
	pub fn k4(mut self) -> Self {
		self.state.set_k4();
		self
	}

	/// Adds a `{k5}` opmask register
	#[must_use]
	#[inline]
	pub fn k5(mut self) -> Self {
		self.state.set_k5();
		self
	}

	/// Adds a `{k6}` opmask register
	#[must_use]
	#[inline]
	pub fn k6(mut self) -> Self {
		self.state.set_k6();
		self
	}

	/// Adds a `{k7}` opmask register
	#[must_use]
	#[inline]
	pub fn k7(mut self) -> Self {
		self.state.set_k7();
		self
	}

	/// Enables zeroing masking `{z}`
	#[must_use]
	#[inline]
	pub fn z(mut self) -> Self {
		self.state.set_zeroing_masking();
		self
	}

	/// Enables suppress all exceptions `{sae}`
	#[must_use]
	#[inline]
	pub fn sae(mut self) -> Self {
		self.state.set_suppress_all_exceptions();
		self
	}

	/// Round to nearest (even)
	#[must_use]
	#[inline]
	pub fn rn_sae(mut self) -> Self {
		self.state.rn_sae();
		self
	}

	/// Round down (toward -inf)
	#[must_use]
	#[inline]
	pub fn rd_sae(mut self) -> Self {
		self.state.rd_sae();
		self
	}

	/// Round up (toward +inf)
	#[must_use]
	#[inline]
	pub fn ru_sae(mut self) -> Self {
		self.state.ru_sae();
		self
	}

	/// Round toward zero (truncate)
	#[must_use]
	#[inline]
	pub fn rz_sae(mut self) -> Self {
		self.state.rz_sae();
		self
	}
}

#[rustfmt::skip]
impl From<__AsmRegister32> for Register {
	#[inline]
	fn from(reg: __AsmRegister32) -> Self {
		reg.register
	}
}

/// All 64-bit general purpose registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::gpr64::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
pub struct __AsmRegister64 {
	register: Register,
	state: CodeAsmOpState,
}

#[rustfmt::skip]
impl __AsmRegister64 {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register, state: CodeAsmOpState::new() }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}

	#[must_use]
	#[inline]
	pub(crate) fn state(&self) -> CodeAsmOpState {
		self.state
	}

	/// Adds a `{k1}` opmask register
	#[must_use]
	#[inline]
	pub fn k1(mut self) -> Self {
		self.state.set_k1();
		self
	}

	/// Adds a `{k2}` opmask register
	#[must_use]
	#[inline]
	pub fn k2(mut self) -> Self {
		self.state.set_k2();
		self
	}

	/// Adds a `{k3}` opmask register
	#[must_use]
	#[inline]
	pub fn k3(mut self) -> Self {
		self.state.set_k3();
		self
	}

	/// Adds a `{k4}` opmask register
	#[must_use]
	#[inline]
	pub fn k4(mut self) -> Self {
		self.state.set_k4();
		self
	}

	/// Adds a `{k5}` opmask register
	#[must_use]
	#[inline]
	pub fn k5(mut self) -> Self {
		self.state.set_k5();
		self
	}

	/// Adds a `{k6}` opmask register
	#[must_use]
	#[inline]
	pub fn k6(mut self) -> Self {
		self.state.set_k6();
		self
	}

	/// Adds a `{k7}` opmask register
	#[must_use]
	#[inline]
	pub fn k7(mut self) -> Self {
		self.state.set_k7();
		self
	}

	/// Enables zeroing masking `{z}`
	#[must_use]
	#[inline]
	pub fn z(mut self) -> Self {
		self.state.set_zeroing_masking();
		self
	}

	/// Enables suppress all exceptions `{sae}`
	#[must_use]
	#[inline]
	pub fn sae(mut self) -> Self {
		self.state.set_suppress_all_exceptions();
		self
	}

	/// Round to nearest (even)
	#[must_use]
	#[inline]
	pub fn rn_sae(mut self) -> Self {
		self.state.rn_sae();
		self
	}

	/// Round down (toward -inf)
	#[must_use]
	#[inline]
	pub fn rd_sae(mut self) -> Self {
		self.state.rd_sae();
		self
	}

	/// Round up (toward +inf)
	#[must_use]
	#[inline]
	pub fn ru_sae(mut self) -> Self {
		self.state.ru_sae();
		self
	}

	/// Round toward zero (truncate)
	#[must_use]
	#[inline]
	pub fn rz_sae(mut self) -> Self {
		self.state.rz_sae();
		self
	}
}

#[rustfmt::skip]
impl From<__AsmRegister64> for Register {
	#[inline]
	fn from(reg: __AsmRegister64) -> Self {
		reg.register
	}
}

/// All segment registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::segment::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegisterSegment {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegisterSegment {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterSegment> for Register {
	#[inline]
	fn from(reg: __AsmRegisterSegment) -> Self {
		reg.register
	}
}

/// All control registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::cr::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegisterCr {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegisterCr {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterCr> for Register {
	#[inline]
	fn from(reg: __AsmRegisterCr) -> Self {
		reg.register
	}
}

/// All debug registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::dr::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegisterDr {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegisterDr {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterDr> for Register {
	#[inline]
	fn from(reg: __AsmRegisterDr) -> Self {
		reg.register
	}
}

/// All test registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::tr::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegisterTr {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegisterTr {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterTr> for Register {
	#[inline]
	fn from(reg: __AsmRegisterTr) -> Self {
		reg.register
	}
}

/// All FPU registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::st::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegisterSt {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegisterSt {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterSt> for Register {
	#[inline]
	fn from(reg: __AsmRegisterSt) -> Self {
		reg.register
	}
}

/// All MMX registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::mm::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegisterMm {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegisterMm {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterMm> for Register {
	#[inline]
	fn from(reg: __AsmRegisterMm) -> Self {
		reg.register
	}
}

/// All 128-bit vector registers (XMM).
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::xmm::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
pub struct __AsmRegisterXmm {
	register: Register,
	state: CodeAsmOpState,
}

#[rustfmt::skip]
impl __AsmRegisterXmm {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register, state: CodeAsmOpState::new() }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}

	#[must_use]
	#[inline]
	pub(crate) fn state(&self) -> CodeAsmOpState {
		self.state
	}

	/// Adds a `{k1}` opmask register
	#[must_use]
	#[inline]
	pub fn k1(mut self) -> Self {
		self.state.set_k1();
		self
	}

	/// Adds a `{k2}` opmask register
	#[must_use]
	#[inline]
	pub fn k2(mut self) -> Self {
		self.state.set_k2();
		self
	}

	/// Adds a `{k3}` opmask register
	#[must_use]
	#[inline]
	pub fn k3(mut self) -> Self {
		self.state.set_k3();
		self
	}

	/// Adds a `{k4}` opmask register
	#[must_use]
	#[inline]
	pub fn k4(mut self) -> Self {
		self.state.set_k4();
		self
	}

	/// Adds a `{k5}` opmask register
	#[must_use]
	#[inline]
	pub fn k5(mut self) -> Self {
		self.state.set_k5();
		self
	}

	/// Adds a `{k6}` opmask register
	#[must_use]
	#[inline]
	pub fn k6(mut self) -> Self {
		self.state.set_k6();
		self
	}

	/// Adds a `{k7}` opmask register
	#[must_use]
	#[inline]
	pub fn k7(mut self) -> Self {
		self.state.set_k7();
		self
	}

	/// Enables zeroing masking `{z}`
	#[must_use]
	#[inline]
	pub fn z(mut self) -> Self {
		self.state.set_zeroing_masking();
		self
	}

	/// Enables suppress all exceptions `{sae}`
	#[must_use]
	#[inline]
	pub fn sae(mut self) -> Self {
		self.state.set_suppress_all_exceptions();
		self
	}

	/// Round to nearest (even)
	#[must_use]
	#[inline]
	pub fn rn_sae(mut self) -> Self {
		self.state.rn_sae();
		self
	}

	/// Round down (toward -inf)
	#[must_use]
	#[inline]
	pub fn rd_sae(mut self) -> Self {
		self.state.rd_sae();
		self
	}

	/// Round up (toward +inf)
	#[must_use]
	#[inline]
	pub fn ru_sae(mut self) -> Self {
		self.state.ru_sae();
		self
	}

	/// Round toward zero (truncate)
	#[must_use]
	#[inline]
	pub fn rz_sae(mut self) -> Self {
		self.state.rz_sae();
		self
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterXmm> for Register {
	#[inline]
	fn from(reg: __AsmRegisterXmm) -> Self {
		reg.register
	}
}

/// All 256-bit vector registers (YMM).
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::ymm::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
pub struct __AsmRegisterYmm {
	register: Register,
	state: CodeAsmOpState,
}

#[rustfmt::skip]
impl __AsmRegisterYmm {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register, state: CodeAsmOpState::new() }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}

	#[must_use]
	#[inline]
	pub(crate) fn state(&self) -> CodeAsmOpState {
		self.state
	}

	/// Adds a `{k1}` opmask register
	#[must_use]
	#[inline]
	pub fn k1(mut self) -> Self {
		self.state.set_k1();
		self
	}

	/// Adds a `{k2}` opmask register
	#[must_use]
	#[inline]
	pub fn k2(mut self) -> Self {
		self.state.set_k2();
		self
	}

	/// Adds a `{k3}` opmask register
	#[must_use]
	#[inline]
	pub fn k3(mut self) -> Self {
		self.state.set_k3();
		self
	}

	/// Adds a `{k4}` opmask register
	#[must_use]
	#[inline]
	pub fn k4(mut self) -> Self {
		self.state.set_k4();
		self
	}

	/// Adds a `{k5}` opmask register
	#[must_use]
	#[inline]
	pub fn k5(mut self) -> Self {
		self.state.set_k5();
		self
	}

	/// Adds a `{k6}` opmask register
	#[must_use]
	#[inline]
	pub fn k6(mut self) -> Self {
		self.state.set_k6();
		self
	}

	/// Adds a `{k7}` opmask register
	#[must_use]
	#[inline]
	pub fn k7(mut self) -> Self {
		self.state.set_k7();
		self
	}

	/// Enables zeroing masking `{z}`
	#[must_use]
	#[inline]
	pub fn z(mut self) -> Self {
		self.state.set_zeroing_masking();
		self
	}

	/// Enables suppress all exceptions `{sae}`
	#[must_use]
	#[inline]
	pub fn sae(mut self) -> Self {
		self.state.set_suppress_all_exceptions();
		self
	}

	/// Round to nearest (even)
	#[must_use]
	#[inline]
	pub fn rn_sae(mut self) -> Self {
		self.state.rn_sae();
		self
	}

	/// Round down (toward -inf)
	#[must_use]
	#[inline]
	pub fn rd_sae(mut self) -> Self {
		self.state.rd_sae();
		self
	}

	/// Round up (toward +inf)
	#[must_use]
	#[inline]
	pub fn ru_sae(mut self) -> Self {
		self.state.ru_sae();
		self
	}

	/// Round toward zero (truncate)
	#[must_use]
	#[inline]
	pub fn rz_sae(mut self) -> Self {
		self.state.rz_sae();
		self
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterYmm> for Register {
	#[inline]
	fn from(reg: __AsmRegisterYmm) -> Self {
		reg.register
	}
}

/// All 512-bit vector registers (ZMM).
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::zmm::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
pub struct __AsmRegisterZmm {
	register: Register,
	state: CodeAsmOpState,
}

#[rustfmt::skip]
impl __AsmRegisterZmm {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register, state: CodeAsmOpState::new() }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}

	#[must_use]
	#[inline]
	pub(crate) fn state(&self) -> CodeAsmOpState {
		self.state
	}

	/// Adds a `{k1}` opmask register
	#[must_use]
	#[inline]
	pub fn k1(mut self) -> Self {
		self.state.set_k1();
		self
	}

	/// Adds a `{k2}` opmask register
	#[must_use]
	#[inline]
	pub fn k2(mut self) -> Self {
		self.state.set_k2();
		self
	}

	/// Adds a `{k3}` opmask register
	#[must_use]
	#[inline]
	pub fn k3(mut self) -> Self {
		self.state.set_k3();
		self
	}

	/// Adds a `{k4}` opmask register
	#[must_use]
	#[inline]
	pub fn k4(mut self) -> Self {
		self.state.set_k4();
		self
	}

	/// Adds a `{k5}` opmask register
	#[must_use]
	#[inline]
	pub fn k5(mut self) -> Self {
		self.state.set_k5();
		self
	}

	/// Adds a `{k6}` opmask register
	#[must_use]
	#[inline]
	pub fn k6(mut self) -> Self {
		self.state.set_k6();
		self
	}

	/// Adds a `{k7}` opmask register
	#[must_use]
	#[inline]
	pub fn k7(mut self) -> Self {
		self.state.set_k7();
		self
	}

	/// Enables zeroing masking `{z}`
	#[must_use]
	#[inline]
	pub fn z(mut self) -> Self {
		self.state.set_zeroing_masking();
		self
	}

	/// Enables suppress all exceptions `{sae}`
	#[must_use]
	#[inline]
	pub fn sae(mut self) -> Self {
		self.state.set_suppress_all_exceptions();
		self
	}

	/// Round to nearest (even)
	#[must_use]
	#[inline]
	pub fn rn_sae(mut self) -> Self {
		self.state.rn_sae();
		self
	}

	/// Round down (toward -inf)
	#[must_use]
	#[inline]
	pub fn rd_sae(mut self) -> Self {
		self.state.rd_sae();
		self
	}

	/// Round up (toward +inf)
	#[must_use]
	#[inline]
	pub fn ru_sae(mut self) -> Self {
		self.state.ru_sae();
		self
	}

	/// Round toward zero (truncate)
	#[must_use]
	#[inline]
	pub fn rz_sae(mut self) -> Self {
		self.state.rz_sae();
		self
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterZmm> for Register {
	#[inline]
	fn from(reg: __AsmRegisterZmm) -> Self {
		reg.register
	}
}

/// All tile registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::tmm::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegisterTmm {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegisterTmm {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterTmm> for Register {
	#[inline]
	fn from(reg: __AsmRegisterTmm) -> Self {
		reg.register
	}
}

/// All opmask registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::k::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
pub struct __AsmRegisterK {
	register: Register,
	state: CodeAsmOpState,
}

#[rustfmt::skip]
impl __AsmRegisterK {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register, state: CodeAsmOpState::new() }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}

	#[must_use]
	#[inline]
	pub(crate) fn state(&self) -> CodeAsmOpState {
		self.state
	}

	/// Adds a `{k1}` opmask register
	#[must_use]
	#[inline]
	pub fn k1(mut self) -> Self {
		self.state.set_k1();
		self
	}

	/// Adds a `{k2}` opmask register
	#[must_use]
	#[inline]
	pub fn k2(mut self) -> Self {
		self.state.set_k2();
		self
	}

	/// Adds a `{k3}` opmask register
	#[must_use]
	#[inline]
	pub fn k3(mut self) -> Self {
		self.state.set_k3();
		self
	}

	/// Adds a `{k4}` opmask register
	#[must_use]
	#[inline]
	pub fn k4(mut self) -> Self {
		self.state.set_k4();
		self
	}

	/// Adds a `{k5}` opmask register
	#[must_use]
	#[inline]
	pub fn k5(mut self) -> Self {
		self.state.set_k5();
		self
	}

	/// Adds a `{k6}` opmask register
	#[must_use]
	#[inline]
	pub fn k6(mut self) -> Self {
		self.state.set_k6();
		self
	}

	/// Adds a `{k7}` opmask register
	#[must_use]
	#[inline]
	pub fn k7(mut self) -> Self {
		self.state.set_k7();
		self
	}

	/// Enables zeroing masking `{z}`
	#[must_use]
	#[inline]
	pub fn z(mut self) -> Self {
		self.state.set_zeroing_masking();
		self
	}

	/// Enables suppress all exceptions `{sae}`
	#[must_use]
	#[inline]
	pub fn sae(mut self) -> Self {
		self.state.set_suppress_all_exceptions();
		self
	}

	/// Round to nearest (even)
	#[must_use]
	#[inline]
	pub fn rn_sae(mut self) -> Self {
		self.state.rn_sae();
		self
	}

	/// Round down (toward -inf)
	#[must_use]
	#[inline]
	pub fn rd_sae(mut self) -> Self {
		self.state.rd_sae();
		self
	}

	/// Round up (toward +inf)
	#[must_use]
	#[inline]
	pub fn ru_sae(mut self) -> Self {
		self.state.ru_sae();
		self
	}

	/// Round toward zero (truncate)
	#[must_use]
	#[inline]
	pub fn rz_sae(mut self) -> Self {
		self.state.rz_sae();
		self
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterK> for Register {
	#[inline]
	fn from(reg: __AsmRegisterK) -> Self {
		reg.register
	}
}

/// All bound registers.
///
/// This type is *not* part of the public API! It's an implementation detail.
/// The register identifiers, however, *are* part of the public API.
///
/// To use the registers, you must import everything from the module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::*;
/// ```
///
/// or import them from this module:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::*;
/// ```
///
/// or import only these registers:
///
/// ```
/// # #![allow(unused_imports)]
/// use iced_x86::code_asm::registers::bnd::*;
/// ```
#[derive(Debug, Copy, Clone, Eq, PartialEq)]
#[rustfmt::skip]
#[repr(transparent)]
pub struct __AsmRegisterBnd {
	register: Register,
}

#[rustfmt::skip]
impl __AsmRegisterBnd {
	#[must_use]
	#[inline]
	pub(crate) const fn new(register: Register) -> Self {
		Self { register }
	}

	#[must_use]
	#[inline]
	pub(crate) fn register(&self) -> Register {
		self.register
	}
}

#[rustfmt::skip]
impl From<__AsmRegisterBnd> for Register {
	#[inline]
	fn from(reg: __AsmRegisterBnd) -> Self {
		reg.register
	}
}
