// SPDX-License-Identifier: MIT
// Copyright wtfsck@protonmail.com
// Copyright iced contributors

use super::iced_constants::IcedConstants;
use core::fmt;
use core::iter::{ExactSizeIterator, FusedIterator, Iterator};

// GENERATOR-BEGIN: RelocKind
// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
/// Relocation kind
#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[cfg_attr(not(feature = "exhaustive_enums"), non_exhaustive)]
pub enum RelocKind {
	/// 64-bit offset. Only used if it's 64-bit code.
	Offset64 = 0,
}
#[rustfmt::skip]
static GEN_DEBUG_RELOC_KIND: [&str; 1] = [
	"Offset64",
];
impl fmt::Debug for RelocKind {
	#[inline]
	fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
		write!(f, "{}", GEN_DEBUG_RELOC_KIND[*self as usize])?;
		Ok(())
	}
}
impl Default for RelocKind {
	#[must_use]
	#[inline]
	fn default() -> Self {
		RelocKind::Offset64
	}
}
#[rustfmt::skip]
impl RelocKind {
	/// Iterates over all `RelocKind` enum values
	#[inline]
	pub fn values() -> impl Iterator<Item = RelocKind> + ExactSizeIterator + FusedIterator {
		RelocKindIterator { index: 0 }
	}
}
#[allow(non_camel_case_types)]
struct RelocKindIterator {
	index: u32,
}
#[rustfmt::skip]
impl Iterator for RelocKindIterator {
	type Item = RelocKind;
	#[inline]
	fn next(&mut self) -> Option<Self::Item> {
		let index = self.index;
		if index < IcedConstants::RELOC_KIND_ENUM_COUNT as u32 {
			self.index = index + 1;
			Some(RelocKind::Offset64)
		} else {
			None
		}
	}
	#[inline]
	fn size_hint(&self) -> (usize, Option<usize>) {
		let len = IcedConstants::RELOC_KIND_ENUM_COUNT - self.index as usize;
		(len, Some(len))
	}
}
impl ExactSizeIterator for RelocKindIterator {}
impl FusedIterator for RelocKindIterator {}
#[test]
#[rustfmt::skip]
fn test_relockind_values() {
	let mut iter = RelocKind::values();
	assert_eq!(iter.size_hint(), (IcedConstants::RELOC_KIND_ENUM_COUNT, Some(IcedConstants::RELOC_KIND_ENUM_COUNT)));
	assert_eq!(iter.len(), IcedConstants::RELOC_KIND_ENUM_COUNT);
	assert!(iter.next().is_some());
	assert_eq!(iter.size_hint(), (IcedConstants::RELOC_KIND_ENUM_COUNT - 1, Some(IcedConstants::RELOC_KIND_ENUM_COUNT - 1)));
	assert_eq!(iter.len(), IcedConstants::RELOC_KIND_ENUM_COUNT - 1);

	let values: Vec<RelocKind> = RelocKind::values().collect();
	assert_eq!(values.len(), IcedConstants::RELOC_KIND_ENUM_COUNT);
	for (i, value) in values.into_iter().enumerate() {
		assert_eq!(i, value as usize);
	}
}
// GENERATOR-END: RelocKind

// GENERATOR-BEGIN: BlockEncoderOptions
// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
/// [`BlockEncoder`] options
///
/// [`BlockEncoder`]: struct.BlockEncoder.html
#[allow(missing_copy_implementations)]
#[allow(missing_debug_implementations)]
pub struct BlockEncoderOptions;
impl BlockEncoderOptions {
	/// No option is set
	pub const NONE: u32 = 0x0000_0000;
	/// By default, branches get updated if the target is too far away, eg. `Jcc SHORT` -> `Jcc NEAR` or if 64-bit mode, `Jcc + JMP [RIP+mem]`. If this option is enabled, no branches are fixed.
	pub const DONT_FIX_BRANCHES: u32 = 0x0000_0001;
	/// The [`BlockEncoder`] should return [`RelocInfo`]s
	///
	/// [`BlockEncoder`]: struct.BlockEncoder.html
	/// [`RelocInfo`]: struct.RelocInfo.html
	pub const RETURN_RELOC_INFOS: u32 = 0x0000_0002;
	/// The [`BlockEncoder`] should return new instruction offsets
	///
	/// [`BlockEncoder`]: struct.BlockEncoder.html
	pub const RETURN_NEW_INSTRUCTION_OFFSETS: u32 = 0x0000_0004;
	/// The [`BlockEncoder`] should return [`ConstantOffsets`]
	///
	/// [`BlockEncoder`]: struct.BlockEncoder.html
	/// [`ConstantOffsets`]: struct.ConstantOffsets.html
	pub const RETURN_CONSTANT_OFFSETS: u32 = 0x0000_0008;
}
// GENERATOR-END: BlockEncoderOptions
