// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

use crate::instruction_internal;
use crate::*;
use core::{u16, u32, u64};
use static_assertions::const_assert_eq;

impl Instruction {
	fn init_memory_operand(instruction: &mut Instruction, memory: &MemoryOperand) {
		instruction.set_memory_base(memory.base);
		instruction.set_memory_index(memory.index);
		instruction.set_memory_index_scale(memory.scale);
		instruction.set_memory_displ_size(memory.displ_size);
		let addr_size = instruction_internal::get_address_size_in_bytes(memory.base, memory.index, memory.displ_size, CodeSize::Unknown);
		if addr_size == 8 {
			instruction.set_memory_displacement64(memory.displacement as u64);
		} else {
			instruction_internal::internal_set_memory_displacement64_lo(instruction, memory.displacement as u32);
		}
		instruction.set_is_broadcast(memory.is_broadcast);
		instruction.set_segment_prefix(memory.segment_prefix);
	}

	// GENERATOR-BEGIN: Create
	// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
	/// Creates an instruction with no operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with(code: Code) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		debug_assert_eq!(instruction.op_count(), 0);
		instruction
	}

	/// Creates an instruction with 1 operand
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_reg(code: Code, register: Register) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		debug_assert_eq!(instruction.op_count(), 1);
		instruction
	}

	/// Creates an instruction with 1 operand
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_i32(code: Code, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction_internal::initialize_signed_immediate(&mut instruction, 0, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 1);
		Ok(instruction)
	}

	/// Creates an instruction with 1 operand
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_i32(code: Code, immediate: i32) -> Self {
		Instruction::try_with_i32(code, immediate).unwrap()
	}

	/// Creates an instruction with 1 operand
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_u32(code: Code, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 0, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 1);
		Ok(instruction)
	}

	/// Creates an instruction with 1 operand
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_u32(code: Code, immediate: u32) -> Self {
		Instruction::try_with_u32(code, immediate).unwrap()
	}

	/// Creates an instruction with 1 operand
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_mem(code: Code, memory: MemoryOperand) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction.set_op0_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		debug_assert_eq!(instruction.op_count(), 1);
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_reg_reg(code: Code, register1: Register, register2: Register) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		debug_assert_eq!(instruction.op_count(), 2);
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_i32(code: Code, register: Register, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_i32(code: Code, register: Register, immediate: i32) -> Self {
		Instruction::try_with_reg_i32(code, register, immediate).unwrap()
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_u32(code: Code, register: Register, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_u32(code: Code, register: Register, immediate: u32) -> Self {
		Instruction::try_with_reg_u32(code, register, immediate).unwrap()
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_i64(code: Code, register: Register, immediate: i64) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate)?;

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_i64() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_i64(code: Code, register: Register, immediate: i64) -> Self {
		Instruction::try_with_reg_i64(code, register, immediate).unwrap()
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_u64(code: Code, register: Register, immediate: u64) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate)?;

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate`: op1: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_u64() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_u64(code: Code, register: Register, immediate: u64) -> Self {
		Instruction::try_with_reg_u64(code, register, immediate).unwrap()
	}

	/// Creates an instruction with 2 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `memory`: op1: Memory operand
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_reg_mem(code: Code, register: Register, memory: MemoryOperand) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		instruction.set_op1_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		debug_assert_eq!(instruction.op_count(), 2);
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	/// * `register`: op1: Register
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_i32_reg(code: Code, immediate: i32, register: Register) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction_internal::initialize_signed_immediate(&mut instruction, 0, immediate as i64)?;

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register);

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	/// * `register`: op1: Register
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_i32_reg() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_i32_reg(code: Code, immediate: i32, register: Register) -> Self {
		Instruction::try_with_i32_reg(code, immediate, register).unwrap()
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	/// * `register`: op1: Register
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_u32_reg(code: Code, immediate: u32, register: Register) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 0, immediate as u64)?;

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register);

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate`: op0: Immediate value
	/// * `register`: op1: Register
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_u32_reg() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_u32_reg(code: Code, immediate: u32, register: Register) -> Self {
		Instruction::try_with_u32_reg(code, immediate, register).unwrap()
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate1`: op0: Immediate value
	/// * `immediate2`: op1: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_i32_i32(code: Code, immediate1: i32, immediate2: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction_internal::initialize_signed_immediate(&mut instruction, 0, immediate1 as i64)?;

		instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate2 as i64)?;

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate1`: op0: Immediate value
	/// * `immediate2`: op1: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_i32_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_i32_i32(code: Code, immediate1: i32, immediate2: i32) -> Self {
		Instruction::try_with_i32_i32(code, immediate1, immediate2).unwrap()
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate1`: op0: Immediate value
	/// * `immediate2`: op1: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_u32_u32(code: Code, immediate1: u32, immediate2: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 0, immediate1 as u64)?;

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate2 as u64)?;

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `immediate1`: op0: Immediate value
	/// * `immediate2`: op1: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_u32_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_u32_u32(code: Code, immediate1: u32, immediate2: u32) -> Self {
		Instruction::try_with_u32_u32(code, immediate1, immediate2).unwrap()
	}

	/// Creates an instruction with 2 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register`: op1: Register
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_mem_reg(code: Code, memory: MemoryOperand, register: Register) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction.set_op0_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register);

		debug_assert_eq!(instruction.op_count(), 2);
		instruction
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `immediate`: op1: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_mem_i32(code: Code, memory: MemoryOperand, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction.set_op0_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `immediate`: op1: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_mem_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_mem_i32(code: Code, memory: MemoryOperand, immediate: i32) -> Self {
		Instruction::try_with_mem_i32(code, memory, immediate).unwrap()
	}

	/// Creates an instruction with 2 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `immediate`: op1: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_mem_u32(code: Code, memory: MemoryOperand, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction.set_op0_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 2);
		Ok(instruction)
	}

	/// Creates an instruction with 2 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `immediate`: op1: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_mem_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_mem_u32(code: Code, memory: MemoryOperand, immediate: u32) -> Self {
		Instruction::try_with_mem_u32(code, memory, immediate).unwrap()
	}

	/// Creates an instruction with 3 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_reg_reg_reg(code: Code, register1: Register, register2: Register, register3: Register) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register3);

		debug_assert_eq!(instruction.op_count(), 3);
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_i32(code: Code, register1: Register, register2: Register, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 3);
		Ok(instruction)
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_i32(code: Code, register1: Register, register2: Register, immediate: i32) -> Self {
		Instruction::try_with_reg_reg_i32(code, register1, register2, immediate).unwrap()
	}

	/// Creates an instruction with 3 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_u32(code: Code, register1: Register, register2: Register, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 3);
		Ok(instruction)
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_u32(code: Code, register1: Register, register2: Register, immediate: u32) -> Self {
		Instruction::try_with_reg_reg_u32(code, register1, register2, immediate).unwrap()
	}

	/// Creates an instruction with 3 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_reg_reg_mem(code: Code, register1: Register, register2: Register, memory: MemoryOperand) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction.set_op2_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		debug_assert_eq!(instruction.op_count(), 3);
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate1`: op1: Immediate value
	/// * `immediate2`: op2: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_i32_i32(code: Code, register: Register, immediate1: i32, immediate2: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		instruction_internal::initialize_signed_immediate(&mut instruction, 1, immediate1 as i64)?;

		instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate2 as i64)?;

		debug_assert_eq!(instruction.op_count(), 3);
		Ok(instruction)
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate1`: op1: Immediate value
	/// * `immediate2`: op2: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_i32_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_i32_i32(code: Code, register: Register, immediate1: i32, immediate2: i32) -> Self {
		Instruction::try_with_reg_i32_i32(code, register, immediate1, immediate2).unwrap()
	}

	/// Creates an instruction with 3 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate1`: op1: Immediate value
	/// * `immediate2`: op2: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_u32_u32(code: Code, register: Register, immediate1: u32, immediate2: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 1, immediate1 as u64)?;

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate2 as u64)?;

		debug_assert_eq!(instruction.op_count(), 3);
		Ok(instruction)
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `immediate1`: op1: Immediate value
	/// * `immediate2`: op2: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_u32_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_u32_u32(code: Code, register: Register, immediate1: u32, immediate2: u32) -> Self {
		Instruction::try_with_reg_u32_u32(code, register, immediate1, immediate2).unwrap()
	}

	/// Creates an instruction with 3 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `memory`: op1: Memory operand
	/// * `register2`: op2: Register
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_reg_mem_reg(code: Code, register1: Register, memory: MemoryOperand, register2: Register) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		instruction.set_op1_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register2);

		debug_assert_eq!(instruction.op_count(), 3);
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `memory`: op1: Memory operand
	/// * `immediate`: op2: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_mem_i32(code: Code, register: Register, memory: MemoryOperand, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		instruction.set_op1_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 3);
		Ok(instruction)
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `memory`: op1: Memory operand
	/// * `immediate`: op2: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_mem_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_mem_i32(code: Code, register: Register, memory: MemoryOperand, immediate: i32) -> Self {
		Instruction::try_with_reg_mem_i32(code, register, memory, immediate).unwrap()
	}

	/// Creates an instruction with 3 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `memory`: op1: Memory operand
	/// * `immediate`: op2: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_mem_u32(code: Code, register: Register, memory: MemoryOperand, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register);

		instruction.set_op1_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 3);
		Ok(instruction)
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: op0: Register
	/// * `memory`: op1: Memory operand
	/// * `immediate`: op2: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_mem_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_mem_u32(code: Code, register: Register, memory: MemoryOperand, immediate: u32) -> Self {
		Instruction::try_with_reg_mem_u32(code, register, memory, immediate).unwrap()
	}

	/// Creates an instruction with 3 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register1`: op1: Register
	/// * `register2`: op2: Register
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_mem_reg_reg(code: Code, memory: MemoryOperand, register1: Register, register2: Register) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction.set_op0_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register2);

		debug_assert_eq!(instruction.op_count(), 3);
		instruction
	}

	/// Creates an instruction with 3 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_mem_reg_i32(code: Code, memory: MemoryOperand, register: Register, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction.set_op0_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register);

		instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 3);
		Ok(instruction)
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_mem_reg_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_mem_reg_i32(code: Code, memory: MemoryOperand, register: Register, immediate: i32) -> Self {
		Instruction::try_with_mem_reg_i32(code, memory, register, immediate).unwrap()
	}

	/// Creates an instruction with 3 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_mem_reg_u32(code: Code, memory: MemoryOperand, register: Register, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction.set_op0_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 3);
		Ok(instruction)
	}

	/// Creates an instruction with 3 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `memory`: op0: Memory operand
	/// * `register`: op1: Register
	/// * `immediate`: op2: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_mem_reg_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_mem_reg_u32(code: Code, memory: MemoryOperand, register: Register, immediate: u32) -> Self {
		Instruction::try_with_mem_reg_u32(code, memory, register, immediate).unwrap()
	}

	/// Creates an instruction with 4 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `register4`: op3: Register
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_reg_reg_reg_reg(code: Code, register1: Register, register2: Register, register3: Register, register4: Register) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register3);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op3_kind(OpKind::Register);
		instruction.set_op3_register(register4);

		debug_assert_eq!(instruction.op_count(), 4);
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `immediate`: op3: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_reg_i32(code: Code, register1: Register, register2: Register, register3: Register, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register3);

		instruction_internal::initialize_signed_immediate(&mut instruction, 3, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 4);
		Ok(instruction)
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `immediate`: op3: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_reg_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_reg_i32(code: Code, register1: Register, register2: Register, register3: Register, immediate: i32) -> Self {
		Instruction::try_with_reg_reg_reg_i32(code, register1, register2, register3, immediate).unwrap()
	}

	/// Creates an instruction with 4 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `immediate`: op3: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_reg_u32(code: Code, register1: Register, register2: Register, register3: Register, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register3);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 3, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 4);
		Ok(instruction)
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `immediate`: op3: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_reg_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_reg_u32(code: Code, register1: Register, register2: Register, register3: Register, immediate: u32) -> Self {
		Instruction::try_with_reg_reg_reg_u32(code, register1, register2, register3, immediate).unwrap()
	}

	/// Creates an instruction with 4 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `memory`: op3: Memory operand
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_reg_reg_reg_mem(code: Code, register1: Register, register2: Register, register3: Register, memory: MemoryOperand) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register3);

		instruction.set_op3_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		debug_assert_eq!(instruction.op_count(), 4);
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate1`: op2: Immediate value
	/// * `immediate2`: op3: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_i32_i32(code: Code, register1: Register, register2: Register, immediate1: i32, immediate2: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction_internal::initialize_signed_immediate(&mut instruction, 2, immediate1 as i64)?;

		instruction_internal::initialize_signed_immediate(&mut instruction, 3, immediate2 as i64)?;

		debug_assert_eq!(instruction.op_count(), 4);
		Ok(instruction)
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate1`: op2: Immediate value
	/// * `immediate2`: op3: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_i32_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_i32_i32(code: Code, register1: Register, register2: Register, immediate1: i32, immediate2: i32) -> Self {
		Instruction::try_with_reg_reg_i32_i32(code, register1, register2, immediate1, immediate2).unwrap()
	}

	/// Creates an instruction with 4 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate1`: op2: Immediate value
	/// * `immediate2`: op3: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_u32_u32(code: Code, register1: Register, register2: Register, immediate1: u32, immediate2: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 2, immediate1 as u64)?;

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 3, immediate2 as u64)?;

		debug_assert_eq!(instruction.op_count(), 4);
		Ok(instruction)
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `immediate1`: op2: Immediate value
	/// * `immediate2`: op3: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_u32_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_u32_u32(code: Code, register1: Register, register2: Register, immediate1: u32, immediate2: u32) -> Self {
		Instruction::try_with_reg_reg_u32_u32(code, register1, register2, immediate1, immediate2).unwrap()
	}

	/// Creates an instruction with 4 operands
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `register3`: op3: Register
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_reg_reg_mem_reg(code: Code, register1: Register, register2: Register, memory: MemoryOperand, register3: Register) -> Self {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction.set_op2_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op3_kind(OpKind::Register);
		instruction.set_op3_register(register3);

		debug_assert_eq!(instruction.op_count(), 4);
		instruction
	}

	/// Creates an instruction with 4 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `immediate`: op3: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_mem_i32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction.set_op2_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		instruction_internal::initialize_signed_immediate(&mut instruction, 3, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 4);
		Ok(instruction)
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `immediate`: op3: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_mem_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_mem_i32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, immediate: i32) -> Self {
		Instruction::try_with_reg_reg_mem_i32(code, register1, register2, memory, immediate).unwrap()
	}

	/// Creates an instruction with 4 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `immediate`: op3: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_mem_u32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction.set_op2_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 3, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 4);
		Ok(instruction)
	}

	/// Creates an instruction with 4 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `immediate`: op3: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_mem_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_mem_u32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, immediate: u32) -> Self {
		Instruction::try_with_reg_reg_mem_u32(code, register1, register2, memory, immediate).unwrap()
	}

	/// Creates an instruction with 5 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `register4`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_reg_reg_i32(code: Code, register1: Register, register2: Register, register3: Register, register4: Register, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register3);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op3_kind(OpKind::Register);
		instruction.set_op3_register(register4);

		instruction_internal::initialize_signed_immediate(&mut instruction, 4, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 5);
		Ok(instruction)
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `register4`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_reg_reg_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_reg_reg_i32(code: Code, register1: Register, register2: Register, register3: Register, register4: Register, immediate: i32) -> Self {
		Instruction::try_with_reg_reg_reg_reg_i32(code, register1, register2, register3, register4, immediate).unwrap()
	}

	/// Creates an instruction with 5 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `register4`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_reg_reg_u32(code: Code, register1: Register, register2: Register, register3: Register, register4: Register, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register3);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op3_kind(OpKind::Register);
		instruction.set_op3_register(register4);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 4, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 5);
		Ok(instruction)
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `register4`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_reg_reg_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_reg_reg_u32(code: Code, register1: Register, register2: Register, register3: Register, register4: Register, immediate: u32) -> Self {
		Instruction::try_with_reg_reg_reg_reg_u32(code, register1, register2, register3, register4, immediate).unwrap()
	}

	/// Creates an instruction with 5 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `memory`: op3: Memory operand
	/// * `immediate`: op4: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_reg_mem_i32(code: Code, register1: Register, register2: Register, register3: Register, memory: MemoryOperand, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register3);

		instruction.set_op3_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		instruction_internal::initialize_signed_immediate(&mut instruction, 4, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 5);
		Ok(instruction)
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `memory`: op3: Memory operand
	/// * `immediate`: op4: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_reg_mem_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_reg_mem_i32(code: Code, register1: Register, register2: Register, register3: Register, memory: MemoryOperand, immediate: i32) -> Self {
		Instruction::try_with_reg_reg_reg_mem_i32(code, register1, register2, register3, memory, immediate).unwrap()
	}

	/// Creates an instruction with 5 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `memory`: op3: Memory operand
	/// * `immediate`: op4: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_reg_mem_u32(code: Code, register1: Register, register2: Register, register3: Register, memory: MemoryOperand, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op2_kind(OpKind::Register);
		instruction.set_op2_register(register3);

		instruction.set_op3_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 4, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 5);
		Ok(instruction)
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `register3`: op2: Register
	/// * `memory`: op3: Memory operand
	/// * `immediate`: op4: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_reg_mem_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_reg_mem_u32(code: Code, register1: Register, register2: Register, register3: Register, memory: MemoryOperand, immediate: u32) -> Self {
		Instruction::try_with_reg_reg_reg_mem_u32(code, register1, register2, register3, memory, immediate).unwrap()
	}

	/// Creates an instruction with 5 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `register3`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_mem_reg_i32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, register3: Register, immediate: i32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction.set_op2_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op3_kind(OpKind::Register);
		instruction.set_op3_register(register3);

		instruction_internal::initialize_signed_immediate(&mut instruction, 4, immediate as i64)?;

		debug_assert_eq!(instruction.op_count(), 5);
		Ok(instruction)
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `register3`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_mem_reg_i32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_mem_reg_i32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, register3: Register, immediate: i32) -> Self {
		Instruction::try_with_reg_reg_mem_reg_i32(code, register1, register2, memory, register3, immediate).unwrap()
	}

	/// Creates an instruction with 5 operands
	///
	/// # Errors
	///
	/// Fails if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `register3`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_reg_reg_mem_reg_u32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, register3: Register, immediate: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op0_kind(OpKind::Register);
		instruction.set_op0_register(register1);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op1_kind(OpKind::Register);
		instruction.set_op1_register(register2);

		instruction.set_op2_kind(OpKind::Memory);
		Instruction::init_memory_operand(&mut instruction, &memory);

		const_assert_eq!(OpKind::Register as u32, 0);
		//instruction.set_op3_kind(OpKind::Register);
		instruction.set_op3_register(register3);

		instruction_internal::initialize_unsigned_immediate(&mut instruction, 4, immediate as u64)?;

		debug_assert_eq!(instruction.op_count(), 5);
		Ok(instruction)
	}

	/// Creates an instruction with 5 operands
	///
	/// # Panics
	///
	/// Panics if the immediate is invalid
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register1`: op0: Register
	/// * `register2`: op1: Register
	/// * `memory`: op2: Memory operand
	/// * `register3`: op3: Register
	/// * `immediate`: op4: Immediate value
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_reg_reg_mem_reg_u32() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_reg_mem_reg_u32(code: Code, register1: Register, register2: Register, memory: MemoryOperand, register3: Register, immediate: u32) -> Self {
		Instruction::try_with_reg_reg_mem_reg_u32(code, register1, register2, memory, register3, immediate).unwrap()
	}

	/// Creates a new near/short branch instruction
	///
	/// # Errors
	///
	/// Fails if the created instruction doesn't have a near branch operand
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `target`: Target address
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_branch(code: Code, target: u64) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction.set_op0_kind(instruction_internal::get_near_branch_op_kind(code, 0)?);
		instruction.set_near_branch64(target);

		debug_assert_eq!(instruction.op_count(), 1);
		Ok(instruction)
	}

	/// Creates a new near/short branch instruction
	///
	/// # Panics
	///
	/// Panics if the created instruction doesn't have a near branch operand
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `target`: Target address
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_branch() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_branch(code: Code, target: u64) -> Self {
		Instruction::try_with_branch(code, target).unwrap()
	}

	/// Creates a new far branch instruction
	///
	/// # Errors
	///
	/// Fails if the created instruction doesn't have a far branch operand
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `selector`: Selector/segment value
	/// * `offset`: Offset
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_far_branch(code: Code, selector: u16, offset: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(code);

		instruction.set_op0_kind(instruction_internal::get_far_branch_op_kind(code, 0)?);
		instruction.set_far_branch_selector(selector);
		instruction.set_far_branch32(offset);

		debug_assert_eq!(instruction.op_count(), 1);
		Ok(instruction)
	}

	/// Creates a new far branch instruction
	///
	/// # Panics
	///
	/// Panics if the created instruction doesn't have a far branch operand
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `selector`: Selector/segment value
	/// * `offset`: Offset
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_far_branch() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_far_branch(code: Code, selector: u16, offset: u32) -> Self {
		Instruction::try_with_far_branch(code, selector, offset).unwrap()
	}

	/// Creates a new `XBEGIN` instruction
	///
	/// # Errors
	///
	/// Fails if `bitness` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `bitness`: 16, 32, or 64
	/// * `target`: Target address
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_xbegin(bitness: u32, target: u64) -> Result<Self, IcedError> {
		let mut instruction = Self::default();

		match bitness {
			16 => {
				instruction.set_code(Code::Xbegin_rel16);
				instruction.set_op0_kind(OpKind::NearBranch32);
				instruction.set_near_branch32(target as u32);
			}

			32 => {
				instruction.set_code(Code::Xbegin_rel32);
				instruction.set_op0_kind(OpKind::NearBranch32);
				instruction.set_near_branch32(target as u32);
			}

			64 => {
				instruction.set_code(Code::Xbegin_rel32);
				instruction.set_op0_kind(OpKind::NearBranch64);
				instruction.set_near_branch64(target);
			}

			_ => return Err(IcedError::new("Invalid bitness")),
		}

		debug_assert_eq!(instruction.op_count(), 1);
		Ok(instruction)
	}

	/// Creates a new `XBEGIN` instruction
	///
	/// # Panics
	///
	/// Panics if `bitness` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `bitness`: 16, 32, or 64
	/// * `target`: Target address
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_xbegin() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_xbegin(bitness: u32, target: u64) -> Self {
		Instruction::try_with_xbegin(bitness, target).unwrap()
	}

	/// Creates an instruction with a 64-bit memory offset as the second operand, eg. `mov al,[123456789ABCDEF0]`
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `register`: Register (`AL`, `AX`, `EAX`, `RAX`)
	/// * `address`: 64-bit address
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[deprecated(since = "1.11.0", note = "Use with_reg_mem() with a MemoryOperand arg instead")]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_reg_mem64(code: Code, register: Register, address: u64, segment_prefix: Register) -> Self {
		Instruction::with_reg_mem(code, register, MemoryOperand::with_base_displ_size_bcst_seg(Register::None, address as i64, 8, false, segment_prefix))
	}

	/// Creates an instruction with a 64-bit memory offset as the first operand, eg. `mov [123456789ABCDEF0],al`
	///
	/// # Arguments
	///
	/// * `code`: Code value
	/// * `address`: 64-bit address
	/// * `register`: Register (`AL`, `AX`, `EAX`, `RAX`)
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[deprecated(since = "1.11.0", note = "Use with_mem_reg() with a MemoryOperand arg instead")]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_mem64_reg(code: Code, address: u64, register: Register, segment_prefix: Register) -> Self {
		Instruction::with_mem_reg(code, MemoryOperand::with_base_displ_size_bcst_seg(Register::None, address as i64, 8, false, segment_prefix), register)
	}

	/// Creates a `OUTSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_outsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Outsb_DX_m8, address_size, Register::DX, segment_prefix, rep_prefix)
	}

	/// Creates a `OUTSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_outsb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_outsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_outsb(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP OUTSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_outsb(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Outsb_DX_m8, address_size, Register::DX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP OUTSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_outsb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_outsb(address_size: u32) -> Self {
		Instruction::try_with_rep_outsb(address_size).unwrap()
	}

	/// Creates a `OUTSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_outsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Outsw_DX_m16, address_size, Register::DX, segment_prefix, rep_prefix)
	}

	/// Creates a `OUTSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_outsw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_outsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_outsw(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP OUTSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_outsw(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Outsw_DX_m16, address_size, Register::DX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP OUTSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_outsw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_outsw(address_size: u32) -> Self {
		Instruction::try_with_rep_outsw(address_size).unwrap()
	}

	/// Creates a `OUTSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_outsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Outsd_DX_m32, address_size, Register::DX, segment_prefix, rep_prefix)
	}

	/// Creates a `OUTSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_outsd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_outsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_outsd(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP OUTSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_outsd(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Outsd_DX_m32, address_size, Register::DX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP OUTSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_outsd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_outsd(address_size: u32) -> Self {
		Instruction::try_with_rep_outsd(address_size).unwrap()
	}

	/// Creates a `LODSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_lodsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Lodsb_AL_m8, address_size, Register::AL, segment_prefix, rep_prefix)
	}

	/// Creates a `LODSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_lodsb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_lodsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_lodsb(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP LODSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_lodsb(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Lodsb_AL_m8, address_size, Register::AL, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP LODSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_lodsb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_lodsb(address_size: u32) -> Self {
		Instruction::try_with_rep_lodsb(address_size).unwrap()
	}

	/// Creates a `LODSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_lodsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Lodsw_AX_m16, address_size, Register::AX, segment_prefix, rep_prefix)
	}

	/// Creates a `LODSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_lodsw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_lodsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_lodsw(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP LODSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_lodsw(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Lodsw_AX_m16, address_size, Register::AX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP LODSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_lodsw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_lodsw(address_size: u32) -> Self {
		Instruction::try_with_rep_lodsw(address_size).unwrap()
	}

	/// Creates a `LODSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_lodsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Lodsd_EAX_m32, address_size, Register::EAX, segment_prefix, rep_prefix)
	}

	/// Creates a `LODSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_lodsd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_lodsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_lodsd(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP LODSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_lodsd(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Lodsd_EAX_m32, address_size, Register::EAX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP LODSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_lodsd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_lodsd(address_size: u32) -> Self {
		Instruction::try_with_rep_lodsd(address_size).unwrap()
	}

	/// Creates a `LODSQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_lodsq(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Lodsq_RAX_m64, address_size, Register::RAX, segment_prefix, rep_prefix)
	}

	/// Creates a `LODSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_lodsq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_lodsq(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_lodsq(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP LODSQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_lodsq(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_segrsi(Code::Lodsq_RAX_m64, address_size, Register::RAX, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP LODSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_lodsq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_lodsq(address_size: u32) -> Self {
		Instruction::try_with_rep_lodsq(address_size).unwrap()
	}

	/// Creates a `SCASB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_scasb(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasb_AL_m8, address_size, Register::AL, rep_prefix)
	}

	/// Creates a `SCASB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_scasb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_scasb(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_scasb(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REPE SCASB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repe_scasb(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasb_AL_m8, address_size, Register::AL, RepPrefixKind::Repe)
	}

	/// Creates a `REPE SCASB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repe_scasb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repe_scasb(address_size: u32) -> Self {
		Instruction::try_with_repe_scasb(address_size).unwrap()
	}

	/// Creates a `REPNE SCASB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repne_scasb(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasb_AL_m8, address_size, Register::AL, RepPrefixKind::Repne)
	}

	/// Creates a `REPNE SCASB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repne_scasb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repne_scasb(address_size: u32) -> Self {
		Instruction::try_with_repne_scasb(address_size).unwrap()
	}

	/// Creates a `SCASW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_scasw(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasw_AX_m16, address_size, Register::AX, rep_prefix)
	}

	/// Creates a `SCASW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_scasw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_scasw(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_scasw(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REPE SCASW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repe_scasw(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasw_AX_m16, address_size, Register::AX, RepPrefixKind::Repe)
	}

	/// Creates a `REPE SCASW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repe_scasw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repe_scasw(address_size: u32) -> Self {
		Instruction::try_with_repe_scasw(address_size).unwrap()
	}

	/// Creates a `REPNE SCASW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repne_scasw(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasw_AX_m16, address_size, Register::AX, RepPrefixKind::Repne)
	}

	/// Creates a `REPNE SCASW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repne_scasw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repne_scasw(address_size: u32) -> Self {
		Instruction::try_with_repne_scasw(address_size).unwrap()
	}

	/// Creates a `SCASD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_scasd(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasd_EAX_m32, address_size, Register::EAX, rep_prefix)
	}

	/// Creates a `SCASD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_scasd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_scasd(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_scasd(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REPE SCASD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repe_scasd(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasd_EAX_m32, address_size, Register::EAX, RepPrefixKind::Repe)
	}

	/// Creates a `REPE SCASD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repe_scasd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repe_scasd(address_size: u32) -> Self {
		Instruction::try_with_repe_scasd(address_size).unwrap()
	}

	/// Creates a `REPNE SCASD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repne_scasd(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasd_EAX_m32, address_size, Register::EAX, RepPrefixKind::Repne)
	}

	/// Creates a `REPNE SCASD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repne_scasd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repne_scasd(address_size: u32) -> Self {
		Instruction::try_with_repne_scasd(address_size).unwrap()
	}

	/// Creates a `SCASQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_scasq(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasq_RAX_m64, address_size, Register::RAX, rep_prefix)
	}

	/// Creates a `SCASQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_scasq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_scasq(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_scasq(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REPE SCASQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repe_scasq(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasq_RAX_m64, address_size, Register::RAX, RepPrefixKind::Repe)
	}

	/// Creates a `REPE SCASQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repe_scasq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repe_scasq(address_size: u32) -> Self {
		Instruction::try_with_repe_scasq(address_size).unwrap()
	}

	/// Creates a `REPNE SCASQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repne_scasq(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_reg_esrdi(Code::Scasq_RAX_m64, address_size, Register::RAX, RepPrefixKind::Repne)
	}

	/// Creates a `REPNE SCASQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repne_scasq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repne_scasq(address_size: u32) -> Self {
		Instruction::try_with_repne_scasq(address_size).unwrap()
	}

	/// Creates a `INSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_insb(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Insb_m8_DX, address_size, Register::DX, rep_prefix)
	}

	/// Creates a `INSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_insb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_insb(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_insb(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REP INSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_insb(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Insb_m8_DX, address_size, Register::DX, RepPrefixKind::Repe)
	}

	/// Creates a `REP INSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_insb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_insb(address_size: u32) -> Self {
		Instruction::try_with_rep_insb(address_size).unwrap()
	}

	/// Creates a `INSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_insw(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Insw_m16_DX, address_size, Register::DX, rep_prefix)
	}

	/// Creates a `INSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_insw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_insw(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_insw(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REP INSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_insw(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Insw_m16_DX, address_size, Register::DX, RepPrefixKind::Repe)
	}

	/// Creates a `REP INSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_insw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_insw(address_size: u32) -> Self {
		Instruction::try_with_rep_insw(address_size).unwrap()
	}

	/// Creates a `INSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_insd(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Insd_m32_DX, address_size, Register::DX, rep_prefix)
	}

	/// Creates a `INSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_insd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_insd(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_insd(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REP INSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_insd(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Insd_m32_DX, address_size, Register::DX, RepPrefixKind::Repe)
	}

	/// Creates a `REP INSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_insd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_insd(address_size: u32) -> Self {
		Instruction::try_with_rep_insd(address_size).unwrap()
	}

	/// Creates a `STOSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_stosb(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Stosb_m8_AL, address_size, Register::AL, rep_prefix)
	}

	/// Creates a `STOSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_stosb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_stosb(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_stosb(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REP STOSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_stosb(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Stosb_m8_AL, address_size, Register::AL, RepPrefixKind::Repe)
	}

	/// Creates a `REP STOSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_stosb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_stosb(address_size: u32) -> Self {
		Instruction::try_with_rep_stosb(address_size).unwrap()
	}

	/// Creates a `STOSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_stosw(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Stosw_m16_AX, address_size, Register::AX, rep_prefix)
	}

	/// Creates a `STOSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_stosw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_stosw(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_stosw(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REP STOSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_stosw(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Stosw_m16_AX, address_size, Register::AX, RepPrefixKind::Repe)
	}

	/// Creates a `REP STOSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_stosw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_stosw(address_size: u32) -> Self {
		Instruction::try_with_rep_stosw(address_size).unwrap()
	}

	/// Creates a `STOSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_stosd(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Stosd_m32_EAX, address_size, Register::EAX, rep_prefix)
	}

	/// Creates a `STOSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_stosd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_stosd(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_stosd(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REP STOSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_stosd(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Stosd_m32_EAX, address_size, Register::EAX, RepPrefixKind::Repe)
	}

	/// Creates a `REP STOSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_stosd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_stosd(address_size: u32) -> Self {
		Instruction::try_with_rep_stosd(address_size).unwrap()
	}

	/// Creates a `STOSQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_stosq(address_size: u32, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Stosq_m64_RAX, address_size, Register::RAX, rep_prefix)
	}

	/// Creates a `STOSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_stosq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_stosq(address_size: u32, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_stosq(address_size, rep_prefix).unwrap()
	}

	/// Creates a `REP STOSQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_stosq(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_reg(Code::Stosq_m64_RAX, address_size, Register::RAX, RepPrefixKind::Repe)
	}

	/// Creates a `REP STOSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_stosq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_stosq(address_size: u32) -> Self {
		Instruction::try_with_rep_stosq(address_size).unwrap()
	}

	/// Creates a `CMPSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_cmpsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsb_m8_m8, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `CMPSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_cmpsb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_cmpsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_cmpsb(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REPE CMPSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repe_cmpsb(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsb_m8_m8, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REPE CMPSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repe_cmpsb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repe_cmpsb(address_size: u32) -> Self {
		Instruction::try_with_repe_cmpsb(address_size).unwrap()
	}

	/// Creates a `REPNE CMPSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repne_cmpsb(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsb_m8_m8, address_size, Register::None, RepPrefixKind::Repne)
	}

	/// Creates a `REPNE CMPSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repne_cmpsb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repne_cmpsb(address_size: u32) -> Self {
		Instruction::try_with_repne_cmpsb(address_size).unwrap()
	}

	/// Creates a `CMPSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_cmpsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsw_m16_m16, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `CMPSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_cmpsw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_cmpsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_cmpsw(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REPE CMPSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repe_cmpsw(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsw_m16_m16, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REPE CMPSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repe_cmpsw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repe_cmpsw(address_size: u32) -> Self {
		Instruction::try_with_repe_cmpsw(address_size).unwrap()
	}

	/// Creates a `REPNE CMPSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repne_cmpsw(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsw_m16_m16, address_size, Register::None, RepPrefixKind::Repne)
	}

	/// Creates a `REPNE CMPSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repne_cmpsw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repne_cmpsw(address_size: u32) -> Self {
		Instruction::try_with_repne_cmpsw(address_size).unwrap()
	}

	/// Creates a `CMPSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_cmpsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsd_m32_m32, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `CMPSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_cmpsd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_cmpsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_cmpsd(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REPE CMPSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repe_cmpsd(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsd_m32_m32, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REPE CMPSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repe_cmpsd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repe_cmpsd(address_size: u32) -> Self {
		Instruction::try_with_repe_cmpsd(address_size).unwrap()
	}

	/// Creates a `REPNE CMPSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repne_cmpsd(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsd_m32_m32, address_size, Register::None, RepPrefixKind::Repne)
	}

	/// Creates a `REPNE CMPSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repne_cmpsd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repne_cmpsd(address_size: u32) -> Self {
		Instruction::try_with_repne_cmpsd(address_size).unwrap()
	}

	/// Creates a `CMPSQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_cmpsq(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsq_m64_m64, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `CMPSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_cmpsq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_cmpsq(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_cmpsq(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REPE CMPSQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repe_cmpsq(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsq_m64_m64, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REPE CMPSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repe_cmpsq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repe_cmpsq(address_size: u32) -> Self {
		Instruction::try_with_repe_cmpsq(address_size).unwrap()
	}

	/// Creates a `REPNE CMPSQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_repne_cmpsq(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_segrsi_esrdi(Code::Cmpsq_m64_m64, address_size, Register::None, RepPrefixKind::Repne)
	}

	/// Creates a `REPNE CMPSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_repne_cmpsq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_repne_cmpsq(address_size: u32) -> Self {
		Instruction::try_with_repne_cmpsq(address_size).unwrap()
	}

	/// Creates a `MOVSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_movsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_segrsi(Code::Movsb_m8_m8, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `MOVSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_movsb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_movsb(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_movsb(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP MOVSB` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_movsb(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_segrsi(Code::Movsb_m8_m8, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP MOVSB` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_movsb() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_movsb(address_size: u32) -> Self {
		Instruction::try_with_rep_movsb(address_size).unwrap()
	}

	/// Creates a `MOVSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_movsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_segrsi(Code::Movsw_m16_m16, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `MOVSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_movsw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_movsw(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_movsw(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP MOVSW` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_movsw(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_segrsi(Code::Movsw_m16_m16, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP MOVSW` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_movsw() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_movsw(address_size: u32) -> Self {
		Instruction::try_with_rep_movsw(address_size).unwrap()
	}

	/// Creates a `MOVSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_movsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_segrsi(Code::Movsd_m32_m32, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `MOVSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_movsd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_movsd(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_movsd(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP MOVSD` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_movsd(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_segrsi(Code::Movsd_m32_m32, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP MOVSD` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_movsd() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_movsd(address_size: u32) -> Self {
		Instruction::try_with_rep_movsd(address_size).unwrap()
	}

	/// Creates a `MOVSQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_movsq(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_segrsi(Code::Movsq_m64_m64, address_size, segment_prefix, rep_prefix)
	}

	/// Creates a `MOVSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `segment_prefix`: Segment override or [`Register::None`]
	/// * `rep_prefix`: Rep prefix or [`RepPrefixKind::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	/// [`RepPrefixKind::None`]: enum.RepPrefixKind.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_movsq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_movsq(address_size: u32, segment_prefix: Register, rep_prefix: RepPrefixKind) -> Self {
		Instruction::try_with_movsq(address_size, segment_prefix, rep_prefix).unwrap()
	}

	/// Creates a `REP MOVSQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_rep_movsq(address_size: u32) -> Result<Self, IcedError> {
		instruction_internal::with_string_esrdi_segrsi(Code::Movsq_m64_m64, address_size, Register::None, RepPrefixKind::Repe)
	}

	/// Creates a `REP MOVSQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_rep_movsq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_rep_movsq(address_size: u32) -> Self {
		Instruction::try_with_rep_movsq(address_size).unwrap()
	}

	/// Creates a `MASKMOVQ` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `register1`: Register
	/// * `register2`: Register
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_maskmovq(address_size: u32, register1: Register, register2: Register, segment_prefix: Register) -> Result<Self, IcedError> {
		instruction_internal::with_maskmov(Code::Maskmovq_rDI_mm_mm, address_size, register1, register2, segment_prefix)
	}

	/// Creates a `MASKMOVQ` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `register1`: Register
	/// * `register2`: Register
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_maskmovq() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_maskmovq(address_size: u32, register1: Register, register2: Register, segment_prefix: Register) -> Self {
		Instruction::try_with_maskmovq(address_size, register1, register2, segment_prefix).unwrap()
	}

	/// Creates a `MASKMOVDQU` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `register1`: Register
	/// * `register2`: Register
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_maskmovdqu(address_size: u32, register1: Register, register2: Register, segment_prefix: Register) -> Result<Self, IcedError> {
		instruction_internal::with_maskmov(Code::Maskmovdqu_rDI_xmm_xmm, address_size, register1, register2, segment_prefix)
	}

	/// Creates a `MASKMOVDQU` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `register1`: Register
	/// * `register2`: Register
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_maskmovdqu() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_maskmovdqu(address_size: u32, register1: Register, register2: Register, segment_prefix: Register) -> Self {
		Instruction::try_with_maskmovdqu(address_size, register1, register2, segment_prefix).unwrap()
	}

	/// Creates a `VMASKMOVDQU` instruction
	///
	/// # Errors
	///
	/// Fails if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `register1`: Register
	/// * `register2`: Register
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[inline]
	#[rustfmt::skip]
	pub fn try_with_vmaskmovdqu(address_size: u32, register1: Register, register2: Register, segment_prefix: Register) -> Result<Self, IcedError> {
		instruction_internal::with_maskmov(Code::VEX_Vmaskmovdqu_rDI_xmm_xmm, address_size, register1, register2, segment_prefix)
	}

	/// Creates a `VMASKMOVDQU` instruction
	///
	/// # Panics
	///
	/// Panics if `address_size` is not one of 16, 32, 64.
	///
	/// # Arguments
	///
	/// * `address_size`: 16, 32, or 64
	/// * `register1`: Register
	/// * `register2`: Register
	/// * `segment_prefix`: Segment override or [`Register::None`]
	///
	/// [`Register::None`]: enum.Register.html#variant.None
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_vmaskmovdqu() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_vmaskmovdqu(address_size: u32, register1: Register, register2: Register, segment_prefix: Register) -> Self {
		Instruction::try_with_vmaskmovdqu(address_size, register1, register2, segment_prefix).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_1(b0: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 1);

		instruction.try_set_declare_byte_value(0, b0)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_1(b0: u8) -> Self {
		Instruction::try_with_declare_byte_1(b0).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_2(b0: u8, b1: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 2);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_2(b0: u8, b1: u8) -> Self {
		Instruction::try_with_declare_byte_2(b0, b1).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_3(b0: u8, b1: u8, b2: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 3);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_3(b0: u8, b1: u8, b2: u8) -> Self {
		Instruction::try_with_declare_byte_3(b0, b1, b2).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_4(b0: u8, b1: u8, b2: u8, b3: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 4);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_4(b0: u8, b1: u8, b2: u8, b3: u8) -> Self {
		Instruction::try_with_declare_byte_4(b0, b1, b2, b3).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_5(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 5);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_5(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8) -> Self {
		Instruction::try_with_declare_byte_5(b0, b1, b2, b3, b4).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_6(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 6);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_6(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8) -> Self {
		Instruction::try_with_declare_byte_6(b0, b1, b2, b3, b4, b5).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_7(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 7);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_7(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8) -> Self {
		Instruction::try_with_declare_byte_7(b0, b1, b2, b3, b4, b5, b6).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_8(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 8);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;
		instruction.try_set_declare_byte_value(7, b7)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_8(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8) -> Self {
		Instruction::try_with_declare_byte_8(b0, b1, b2, b3, b4, b5, b6, b7).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_9(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 9);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;
		instruction.try_set_declare_byte_value(7, b7)?;
		instruction.try_set_declare_byte_value(8, b8)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_9(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8) -> Self {
		Instruction::try_with_declare_byte_9(b0, b1, b2, b3, b4, b5, b6, b7, b8).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_10(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 10);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;
		instruction.try_set_declare_byte_value(7, b7)?;
		instruction.try_set_declare_byte_value(8, b8)?;
		instruction.try_set_declare_byte_value(9, b9)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_10(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8) -> Self {
		Instruction::try_with_declare_byte_10(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_11(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 11);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;
		instruction.try_set_declare_byte_value(7, b7)?;
		instruction.try_set_declare_byte_value(8, b8)?;
		instruction.try_set_declare_byte_value(9, b9)?;
		instruction.try_set_declare_byte_value(10, b10)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_11(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8) -> Self {
		Instruction::try_with_declare_byte_11(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_12(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 12);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;
		instruction.try_set_declare_byte_value(7, b7)?;
		instruction.try_set_declare_byte_value(8, b8)?;
		instruction.try_set_declare_byte_value(9, b9)?;
		instruction.try_set_declare_byte_value(10, b10)?;
		instruction.try_set_declare_byte_value(11, b11)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_12(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8) -> Self {
		Instruction::try_with_declare_byte_12(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_13(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 13);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;
		instruction.try_set_declare_byte_value(7, b7)?;
		instruction.try_set_declare_byte_value(8, b8)?;
		instruction.try_set_declare_byte_value(9, b9)?;
		instruction.try_set_declare_byte_value(10, b10)?;
		instruction.try_set_declare_byte_value(11, b11)?;
		instruction.try_set_declare_byte_value(12, b12)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_13(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8) -> Self {
		Instruction::try_with_declare_byte_13(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	/// * `b13`: Byte 13
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_14(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 14);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;
		instruction.try_set_declare_byte_value(7, b7)?;
		instruction.try_set_declare_byte_value(8, b8)?;
		instruction.try_set_declare_byte_value(9, b9)?;
		instruction.try_set_declare_byte_value(10, b10)?;
		instruction.try_set_declare_byte_value(11, b11)?;
		instruction.try_set_declare_byte_value(12, b12)?;
		instruction.try_set_declare_byte_value(13, b13)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	/// * `b13`: Byte 13
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_14(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8) -> Self {
		Instruction::try_with_declare_byte_14(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	/// * `b13`: Byte 13
	/// * `b14`: Byte 14
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_15(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8, b14: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 15);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;
		instruction.try_set_declare_byte_value(7, b7)?;
		instruction.try_set_declare_byte_value(8, b8)?;
		instruction.try_set_declare_byte_value(9, b9)?;
		instruction.try_set_declare_byte_value(10, b10)?;
		instruction.try_set_declare_byte_value(11, b11)?;
		instruction.try_set_declare_byte_value(12, b12)?;
		instruction.try_set_declare_byte_value(13, b13)?;
		instruction.try_set_declare_byte_value(14, b14)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	/// * `b13`: Byte 13
	/// * `b14`: Byte 14
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_15(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8, b14: u8) -> Self {
		Instruction::try_with_declare_byte_15(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	/// * `b13`: Byte 13
	/// * `b14`: Byte 14
	/// * `b15`: Byte 15
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte_16(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8, b14: u8, b15: u8) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 16);

		instruction.try_set_declare_byte_value(0, b0)?;
		instruction.try_set_declare_byte_value(1, b1)?;
		instruction.try_set_declare_byte_value(2, b2)?;
		instruction.try_set_declare_byte_value(3, b3)?;
		instruction.try_set_declare_byte_value(4, b4)?;
		instruction.try_set_declare_byte_value(5, b5)?;
		instruction.try_set_declare_byte_value(6, b6)?;
		instruction.try_set_declare_byte_value(7, b7)?;
		instruction.try_set_declare_byte_value(8, b8)?;
		instruction.try_set_declare_byte_value(9, b9)?;
		instruction.try_set_declare_byte_value(10, b10)?;
		instruction.try_set_declare_byte_value(11, b11)?;
		instruction.try_set_declare_byte_value(12, b12)?;
		instruction.try_set_declare_byte_value(13, b13)?;
		instruction.try_set_declare_byte_value(14, b14)?;
		instruction.try_set_declare_byte_value(15, b15)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Arguments
	///
	/// * `b0`: Byte 0
	/// * `b1`: Byte 1
	/// * `b2`: Byte 2
	/// * `b3`: Byte 3
	/// * `b4`: Byte 4
	/// * `b5`: Byte 5
	/// * `b6`: Byte 6
	/// * `b7`: Byte 7
	/// * `b8`: Byte 8
	/// * `b9`: Byte 9
	/// * `b10`: Byte 10
	/// * `b11`: Byte 11
	/// * `b12`: Byte 12
	/// * `b13`: Byte 13
	/// * `b14`: Byte 14
	/// * `b15`: Byte 15
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_byte_16(b0: u8, b1: u8, b2: u8, b3: u8, b4: u8, b5: u8, b6: u8, b7: u8, b8: u8, b9: u8, b10: u8, b11: u8, b12: u8, b13: u8, b14: u8, b15: u8) -> Self {
		Instruction::try_with_declare_byte_16(b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15).unwrap()
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Errors
	///
	/// Fails if `data.len()` is not 1-16
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_byte(data: &[u8]) -> Result<Self, IcedError> {
		if data.len().wrapping_sub(1) > 16 - 1 {
			return Err(IcedError::new("Invalid slice length"));
		}

		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareByte);
		instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32);

		for i in data.iter().enumerate() {
			instruction.try_set_declare_byte_value(i.0, *i.1)?;
		}

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `db`/`.byte` asm directive
	///
	/// # Panics
	///
	/// Panics if `data.len()` is not 1-16
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_declare_byte() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_declare_byte(data: &[u8]) -> Self {
		Instruction::try_with_declare_byte(data).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_word_1(w0: u16) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 1);

		instruction.try_set_declare_word_value(0, w0)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_word_1(w0: u16) -> Self {
		Instruction::try_with_declare_word_1(w0).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_word_2(w0: u16, w1: u16) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 2);

		instruction.try_set_declare_word_value(0, w0)?;
		instruction.try_set_declare_word_value(1, w1)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_word_2(w0: u16, w1: u16) -> Self {
		Instruction::try_with_declare_word_2(w0, w1).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_word_3(w0: u16, w1: u16, w2: u16) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 3);

		instruction.try_set_declare_word_value(0, w0)?;
		instruction.try_set_declare_word_value(1, w1)?;
		instruction.try_set_declare_word_value(2, w2)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_word_3(w0: u16, w1: u16, w2: u16) -> Self {
		Instruction::try_with_declare_word_3(w0, w1, w2).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_word_4(w0: u16, w1: u16, w2: u16, w3: u16) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 4);

		instruction.try_set_declare_word_value(0, w0)?;
		instruction.try_set_declare_word_value(1, w1)?;
		instruction.try_set_declare_word_value(2, w2)?;
		instruction.try_set_declare_word_value(3, w3)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_word_4(w0: u16, w1: u16, w2: u16, w3: u16) -> Self {
		Instruction::try_with_declare_word_4(w0, w1, w2, w3).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_word_5(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 5);

		instruction.try_set_declare_word_value(0, w0)?;
		instruction.try_set_declare_word_value(1, w1)?;
		instruction.try_set_declare_word_value(2, w2)?;
		instruction.try_set_declare_word_value(3, w3)?;
		instruction.try_set_declare_word_value(4, w4)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_word_5(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16) -> Self {
		Instruction::try_with_declare_word_5(w0, w1, w2, w3, w4).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	/// * `w5`: Word 5
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_word_6(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16, w5: u16) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 6);

		instruction.try_set_declare_word_value(0, w0)?;
		instruction.try_set_declare_word_value(1, w1)?;
		instruction.try_set_declare_word_value(2, w2)?;
		instruction.try_set_declare_word_value(3, w3)?;
		instruction.try_set_declare_word_value(4, w4)?;
		instruction.try_set_declare_word_value(5, w5)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	/// * `w5`: Word 5
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_word_6(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16, w5: u16) -> Self {
		Instruction::try_with_declare_word_6(w0, w1, w2, w3, w4, w5).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	/// * `w5`: Word 5
	/// * `w6`: Word 6
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_word_7(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16, w5: u16, w6: u16) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 7);

		instruction.try_set_declare_word_value(0, w0)?;
		instruction.try_set_declare_word_value(1, w1)?;
		instruction.try_set_declare_word_value(2, w2)?;
		instruction.try_set_declare_word_value(3, w3)?;
		instruction.try_set_declare_word_value(4, w4)?;
		instruction.try_set_declare_word_value(5, w5)?;
		instruction.try_set_declare_word_value(6, w6)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	/// * `w5`: Word 5
	/// * `w6`: Word 6
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_word_7(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16, w5: u16, w6: u16) -> Self {
		Instruction::try_with_declare_word_7(w0, w1, w2, w3, w4, w5, w6).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	/// * `w5`: Word 5
	/// * `w6`: Word 6
	/// * `w7`: Word 7
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_word_8(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16, w5: u16, w6: u16, w7: u16) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 8);

		instruction.try_set_declare_word_value(0, w0)?;
		instruction.try_set_declare_word_value(1, w1)?;
		instruction.try_set_declare_word_value(2, w2)?;
		instruction.try_set_declare_word_value(3, w3)?;
		instruction.try_set_declare_word_value(4, w4)?;
		instruction.try_set_declare_word_value(5, w5)?;
		instruction.try_set_declare_word_value(6, w6)?;
		instruction.try_set_declare_word_value(7, w7)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Arguments
	///
	/// * `w0`: Word 0
	/// * `w1`: Word 1
	/// * `w2`: Word 2
	/// * `w3`: Word 3
	/// * `w4`: Word 4
	/// * `w5`: Word 5
	/// * `w6`: Word 6
	/// * `w7`: Word 7
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_word_8(w0: u16, w1: u16, w2: u16, w3: u16, w4: u16, w5: u16, w6: u16, w7: u16) -> Self {
		Instruction::try_with_declare_word_8(w0, w1, w2, w3, w4, w5, w6, w7).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails if `data.len()` is not 2-16 or not a multiple of 2
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	#[allow(trivial_casts)]
	pub fn try_with_declare_word_slice_u8(data: &[u8]) -> Result<Self, IcedError> {
		if data.len().wrapping_sub(1) > 16 - 1 || (data.len() & 1) != 0 {
			return Err(IcedError::new("Invalid slice length"));
		}

		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32 / 2);

		for i in 0..data.len() / 2 {
			let v = (data[i * 2] as u16) | ((data[i * 2 + 1] as u16) << 8);
			instruction.try_set_declare_word_value(i, v)?;
		}

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `data.len()` is not 2-16 or not a multiple of 2
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_declare_word_slice_u8() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_declare_word_slice_u8(data: &[u8]) -> Self {
		Instruction::try_with_declare_word_slice_u8(data).unwrap()
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Errors
	///
	/// Fails if `data.len()` is not 1-8
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_word(data: &[u16]) -> Result<Self, IcedError> {
		if data.len().wrapping_sub(1) > 8 - 1 {
			return Err(IcedError::new("Invalid slice length"));
		}

		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareWord);
		instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32);

		for i in data.iter().enumerate() {
			instruction.try_set_declare_word_value(i.0, *i.1)?;
		}

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dw`/`.word` asm directive
	///
	/// # Panics
	///
	/// Panics if `data.len()` is not 1-8
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_declare_word() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_declare_word(data: &[u16]) -> Self {
		Instruction::try_with_declare_word(data).unwrap()
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_dword_1(d0: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareDword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 1);

		instruction.try_set_declare_dword_value(0, d0)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_dword_1(d0: u32) -> Self {
		Instruction::try_with_declare_dword_1(d0).unwrap()
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	/// * `d1`: Dword 1
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_dword_2(d0: u32, d1: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareDword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 2);

		instruction.try_set_declare_dword_value(0, d0)?;
		instruction.try_set_declare_dword_value(1, d1)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	/// * `d1`: Dword 1
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_dword_2(d0: u32, d1: u32) -> Self {
		Instruction::try_with_declare_dword_2(d0, d1).unwrap()
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	/// * `d1`: Dword 1
	/// * `d2`: Dword 2
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_dword_3(d0: u32, d1: u32, d2: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareDword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 3);

		instruction.try_set_declare_dword_value(0, d0)?;
		instruction.try_set_declare_dword_value(1, d1)?;
		instruction.try_set_declare_dword_value(2, d2)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	/// * `d1`: Dword 1
	/// * `d2`: Dword 2
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_dword_3(d0: u32, d1: u32, d2: u32) -> Self {
		Instruction::try_with_declare_dword_3(d0, d1, d2).unwrap()
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	/// * `d1`: Dword 1
	/// * `d2`: Dword 2
	/// * `d3`: Dword 3
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_dword_4(d0: u32, d1: u32, d2: u32, d3: u32) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareDword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 4);

		instruction.try_set_declare_dword_value(0, d0)?;
		instruction.try_set_declare_dword_value(1, d1)?;
		instruction.try_set_declare_dword_value(2, d2)?;
		instruction.try_set_declare_dword_value(3, d3)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Arguments
	///
	/// * `d0`: Dword 0
	/// * `d1`: Dword 1
	/// * `d2`: Dword 2
	/// * `d3`: Dword 3
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_dword_4(d0: u32, d1: u32, d2: u32, d3: u32) -> Self {
		Instruction::try_with_declare_dword_4(d0, d1, d2, d3).unwrap()
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Errors
	///
	/// Fails if `data.len()` is not 4-16 or not a multiple of 4
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	#[allow(trivial_casts)]
	pub fn try_with_declare_dword_slice_u8(data: &[u8]) -> Result<Self, IcedError> {
		if data.len().wrapping_sub(1) > 16 - 1 || (data.len() & 3) != 0 {
			return Err(IcedError::new("Invalid slice length"));
		}

		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareDword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32 / 4);

		for i in 0..data.len() / 4 {
			let v = (data[i * 4] as u32) | ((data[i * 4 + 1] as u32) << 8) | ((data[i * 4 + 2] as u32) << 16) | ((data[i * 4 + 3] as u32) << 24);
			instruction.try_set_declare_dword_value(i, v)?;
		}

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Panics
	///
	/// Panics if `data.len()` is not 4-16 or not a multiple of 4
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_declare_dword_slice_u8() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_declare_dword_slice_u8(data: &[u8]) -> Self {
		Instruction::try_with_declare_dword_slice_u8(data).unwrap()
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Errors
	///
	/// Fails if `data.len()` is not 1-4
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_dword(data: &[u32]) -> Result<Self, IcedError> {
		if data.len().wrapping_sub(1) > 4 - 1 {
			return Err(IcedError::new("Invalid slice length"));
		}

		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareDword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32);

		for i in data.iter().enumerate() {
			instruction.try_set_declare_dword_value(i.0, *i.1)?;
		}

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dd`/`.int` asm directive
	///
	/// # Panics
	///
	/// Panics if `data.len()` is not 1-4
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_declare_dword() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_declare_dword(data: &[u32]) -> Self {
		Instruction::try_with_declare_dword(data).unwrap()
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `q0`: Qword 0
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_qword_1(q0: u64) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareQword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 1);

		instruction.try_set_declare_qword_value(0, q0)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Arguments
	///
	/// * `q0`: Qword 0
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_qword_1(q0: u64) -> Self {
		Instruction::try_with_declare_qword_1(q0).unwrap()
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Errors
	///
	/// Fails NEVER!
	///
	/// # Arguments
	///
	/// * `q0`: Qword 0
	/// * `q1`: Qword 1
	#[doc(hidden)]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_qword_2(q0: u64, q1: u64) -> Result<Self, IcedError> {
		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareQword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, 2);

		instruction.try_set_declare_qword_value(0, q0)?;
		instruction.try_set_declare_qword_value(1, q1)?;

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Arguments
	///
	/// * `q0`: Qword 0
	/// * `q1`: Qword 1
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn with_declare_qword_2(q0: u64, q1: u64) -> Self {
		Instruction::try_with_declare_qword_2(q0, q1).unwrap()
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Errors
	///
	/// Fails if `data.len()` is not 8-16 or not a multiple of 8
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	#[allow(trivial_casts)]
	pub fn try_with_declare_qword_slice_u8(data: &[u8]) -> Result<Self, IcedError> {
		if data.len().wrapping_sub(1) > 16 - 1 || (data.len() & 7) != 0 {
			return Err(IcedError::new("Invalid slice length"));
		}

		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareQword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32 / 8);

		for i in 0..data.len() / 8 {
			let v = (data[i * 8] as u64) | ((data[i * 8 + 1] as u64) << 8) | ((data[i * 8 + 2] as u64) << 16) | ((data[i * 8 + 3] as u64) << 24)
				| ((data[i * 8 + 4] as u64) << 32) | ((data[i * 8 + 5] as u64) << 40) | ((data[i * 8 + 6] as u64) << 48) | ((data[i * 8 + 7] as u64) << 56);
			instruction.try_set_declare_qword_value(i, v)?;
		}

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Panics
	///
	/// Panics if `data.len()` is not 8-16 or not a multiple of 8
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_declare_qword_slice_u8() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_declare_qword_slice_u8(data: &[u8]) -> Self {
		Instruction::try_with_declare_qword_slice_u8(data).unwrap()
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Errors
	///
	/// Fails if `data.len()` is not 1-2
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[allow(clippy::missing_inline_in_public_items)]
	#[rustfmt::skip]
	pub fn try_with_declare_qword(data: &[u64]) -> Result<Self, IcedError> {
		if data.len().wrapping_sub(1) > 2 - 1 {
			return Err(IcedError::new("Invalid slice length"));
		}

		let mut instruction = Self::default();
		instruction.set_code(Code::DeclareQword);
		instruction_internal::internal_set_declare_data_len(&mut instruction, data.len() as u32);

		for i in data.iter().enumerate() {
			instruction.try_set_declare_qword_value(i.0, *i.1)?;
		}

		debug_assert_eq!(instruction.op_count(), 0);
		Ok(instruction)
	}

	/// Creates a `dq`/`.quad` asm directive
	///
	/// # Panics
	///
	/// Panics if `data.len()` is not 1-2
	///
	/// # Arguments
	///
	/// * `data`: Data
	#[deprecated(since = "1.10.0", note = "This method can panic, use try_with_declare_qword() instead")]
	#[allow(clippy::unwrap_used)]
	#[must_use]
	#[inline]
	#[rustfmt::skip]
	pub fn with_declare_qword(data: &[u64]) -> Self {
		Instruction::try_with_declare_qword(data).unwrap()
	}
	// GENERATOR-END: Create
}
