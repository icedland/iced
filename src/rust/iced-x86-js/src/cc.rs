// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

use wasm_bindgen::prelude::*;

// GENERATOR-BEGIN: CC_b
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JB` / `JC` / `JNAE`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_b {
	/// `JB`, `CMOVB`, `SETB`
	b = 0,
	/// `JC`, `CMOVC`, `SETC`
	c = 1,
	/// `JNAE`, `CMOVNAE`, `SETNAE`
	nae = 2,
}
// GENERATOR-END: CC_b

// GENERATOR-BEGIN: CC_ae
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JAE` / `JNB` / `JNC`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_ae {
	/// `JAE`, `CMOVAE`, `SETAE`
	ae = 0,
	/// `JNB`, `CMOVNB`, `SETNB`
	nb = 1,
	/// `JNC`, `CMOVNC`, `SETNC`
	nc = 2,
}
// GENERATOR-END: CC_ae

// GENERATOR-BEGIN: CC_e
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JE` / `JZ`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_e {
	/// `JE`, `CMOVE`, `SETE`, `LOOPE`, `REPE`
	e = 0,
	/// `JZ`, `CMOVZ`, `SETZ`, `LOOPZ`, `REPZ`
	z = 1,
}
// GENERATOR-END: CC_e

// GENERATOR-BEGIN: CC_ne
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JNE` / `JNZ`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_ne {
	/// `JNE`, `CMOVNE`, `SETNE`, `LOOPNE`, `REPNE`
	ne = 0,
	/// `JNZ`, `CMOVNZ`, `SETNZ`, `LOOPNZ`, `REPNZ`
	nz = 1,
}
// GENERATOR-END: CC_ne

// GENERATOR-BEGIN: CC_be
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JBE` / `JNA`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_be {
	/// `JBE`, `CMOVBE`, `SETBE`
	be = 0,
	/// `JNA`, `CMOVNA`, `SETNA`
	na = 1,
}
// GENERATOR-END: CC_be

// GENERATOR-BEGIN: CC_a
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JA` / `JNBE`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_a {
	/// `JA`, `CMOVA`, `SETA`
	a = 0,
	/// `JNBE`, `CMOVNBE`, `SETNBE`
	nbe = 1,
}
// GENERATOR-END: CC_a

// GENERATOR-BEGIN: CC_p
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JP` / `JPE`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_p {
	/// `JP`, `CMOVP`, `SETP`
	p = 0,
	/// `JPE`, `CMOVPE`, `SETPE`
	pe = 1,
}
// GENERATOR-END: CC_p

// GENERATOR-BEGIN: CC_np
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JNP` / `JPO`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_np {
	/// `JNP`, `CMOVNP`, `SETNP`
	np = 0,
	/// `JPO`, `CMOVPO`, `SETPO`
	po = 1,
}
// GENERATOR-END: CC_np

// GENERATOR-BEGIN: CC_l
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JL` / `JNGE`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_l {
	/// `JL`, `CMOVL`, `SETL`
	l = 0,
	/// `JNGE`, `CMOVNGE`, `SETNGE`
	nge = 1,
}
// GENERATOR-END: CC_l

// GENERATOR-BEGIN: CC_ge
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JGE` / `JNL`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_ge {
	/// `JGE`, `CMOVGE`, `SETGE`
	ge = 0,
	/// `JNL`, `CMOVNL`, `SETNL`
	nl = 1,
}
// GENERATOR-END: CC_ge

// GENERATOR-BEGIN: CC_le
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JLE` / `JNG`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_le {
	/// `JLE`, `CMOVLE`, `SETLE`
	le = 0,
	/// `JNG`, `CMOVNG`, `SETNG`
	ng = 1,
}
// GENERATOR-END: CC_le

// GENERATOR-BEGIN: CC_g
// âš ï¸This was generated by GENERATOR!ðŸ¦¹â€â™‚ï¸
/// Mnemonic condition code selector (eg. `JG` / `JNLE`)
#[wasm_bindgen]
#[derive(Copy, Clone)]
#[allow(non_camel_case_types)]
pub enum CC_g {
	/// `JG`, `CMOVG`, `SETG`
	g = 0,
	/// `JNLE`, `CMOVNLE`, `SETNLE`
	nle = 1,
}
// GENERATOR-END: CC_g

#[allow(dead_code)]
pub(crate) fn cc_b_to_iced(value: CC_b) -> iced_x86_rust::CC_b {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_b(value: iced_x86_rust::CC_b) -> CC_b {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_ae_to_iced(value: CC_ae) -> iced_x86_rust::CC_ae {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_ae(value: iced_x86_rust::CC_ae) -> CC_ae {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_e_to_iced(value: CC_e) -> iced_x86_rust::CC_e {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_e(value: iced_x86_rust::CC_e) -> CC_e {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_ne_to_iced(value: CC_ne) -> iced_x86_rust::CC_ne {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_ne(value: iced_x86_rust::CC_ne) -> CC_ne {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_be_to_iced(value: CC_be) -> iced_x86_rust::CC_be {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_be(value: iced_x86_rust::CC_be) -> CC_be {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_a_to_iced(value: CC_a) -> iced_x86_rust::CC_a {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_a(value: iced_x86_rust::CC_a) -> CC_a {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_p_to_iced(value: CC_p) -> iced_x86_rust::CC_p {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_p(value: iced_x86_rust::CC_p) -> CC_p {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_np_to_iced(value: CC_np) -> iced_x86_rust::CC_np {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_np(value: iced_x86_rust::CC_np) -> CC_np {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_l_to_iced(value: CC_l) -> iced_x86_rust::CC_l {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_l(value: iced_x86_rust::CC_l) -> CC_l {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_ge_to_iced(value: CC_ge) -> iced_x86_rust::CC_ge {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_ge(value: iced_x86_rust::CC_ge) -> CC_ge {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_le_to_iced(value: CC_le) -> iced_x86_rust::CC_le {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_le(value: iced_x86_rust::CC_le) -> CC_le {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn cc_g_to_iced(value: CC_g) -> iced_x86_rust::CC_g {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}

#[allow(dead_code)]
pub(crate) fn iced_to_cc_g(value: iced_x86_rust::CC_g) -> CC_g {
	// SAFETY: the enums are exactly identical
	unsafe { std::mem::transmute(value as u8) }
}
