-- SPDX-License-Identifier: MIT
-- Copyright (C) 2018-present iced project and contributors

-- ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

---@meta
---@diagnostic disable unused-local

---A 16/32/64-bit x86 instruction. Created by `Decoder` or by `Instruction.create*()` methods
---
---@class Instruction
local Instruction = {}

---Creates a new empty instruction
---
---@return Instruction
function Instruction.new() end

---Creates a new instruction that's exactly identical to this one
---
---@return Instruction
function Instruction:copy() end

---Checks if two instructions are equal, comparing all bits, not ignoring anything. `==` ignores some fields.
---
---@param other Instruction #Other instruction
function Instruction:eq_all_bits(other) end

---Gets the 16-bit IP of the instruction
---
---@return integer
function Instruction:ip16() end

---Gets the 16-bit IP of the instruction
---
---@param new_value integer #New value
function Instruction:set_ip16(new_value) end

---Gets the 32-bit IP of the instruction
---
---@return integer
function Instruction:ip32() end

---Gets the 32-bit IP of the instruction
---
---@param new_value integer #New value
function Instruction:set_ip32(new_value) end

---Gets the 64-bit IP of the instruction
---
---@return integer
function Instruction:ip() end

---Gets the 64-bit IP of the instruction
---
---@param new_value integer #New value
function Instruction:set_ip(new_value) end

---Gets the 16-bit IP of the next instruction
---
---@return integer
function Instruction:next_ip16() end

---Gets the 16-bit IP of the next instruction
---
---@param new_value integer #New value
function Instruction:set_next_ip16(new_value) end

---Gets the 32-bit IP of the next instruction
---
---@return integer
function Instruction:next_ip32() end

---Gets the 32-bit IP of the next instruction
---
---@param new_value integer #New value
function Instruction:set_next_ip32(new_value) end

---Gets the 64-bit IP of the next instruction
---
---@return integer
function Instruction:next_ip() end

---Gets the 64-bit IP of the next instruction
---
---@param new_value integer #New value
function Instruction:set_next_ip(new_value) end

---Gets the code size (a `CodeSize` enum value) when the instruction was decoded.
---
---# Note
---This value is informational and can be used by a formatter.
---
---@return integer #A `CodeSize` enum value
function Instruction:code_size() end

---Gets the code size (a `CodeSize` enum value) when the instruction was decoded.
---
---# Note
---This value is informational and can be used by a formatter.
---
---@param new_value integer #New value (A `CodeSize` enum value)
function Instruction:set_code_size(new_value) end

---Checks if it's an invalid instruction (`Instruction:code()` == `Code.INVALID`)
---
---@return boolean
function Instruction:is_invalid() end

---Gets the instruction code (a `Code` enum value), see also `Instruction:mnemonic()`
---
---@return integer #A `Code` enum value
function Instruction:code() end

---Gets the instruction code (a `Code` enum value), see also `Instruction:mnemonic()`
---
---@param new_value integer #New value (A `Code` enum value)
function Instruction:set_code(new_value) end

---Gets the mnemonic (a `Mnemonic` enum value), see also `Instruction:code()`
---
---@return integer #A `Mnemonic` enum value
function Instruction:mnemonic() end

---Gets the operand count. An instruction can have 0-5 operands.
---
---@return integer
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---
----- add [rax],ebx
---local data = "\001\024"
---local decoder = Decoder.new(64, data)
---local instr = decoder:decode()
---
---assert(instr:op_count() == 2)
---```
function Instruction:op_count() end

---Gets the length of the instruction, 0-15 bytes.
---
---You can also call `#instr` to get this value.
---
---# Note
---This is just informational. If you modify the instruction or create a new one, this method could return the wrong value.
---
---@return integer
function Instruction:len() end

---Gets the length of the instruction, 0-15 bytes.
---
---You can also call `#instr` to get this value.
---
---# Note
---This is just informational. If you modify the instruction or create a new one, this method could return the wrong value.
---
---@param new_value integer #New value
function Instruction:set_len(new_value) end

---`true` if the instruction has the `XACQUIRE` prefix (`F2`)
---
---@return boolean
function Instruction:has_xacquire_prefix() end

---`true` if the instruction has the `XACQUIRE` prefix (`F2`)
---
---@param new_value boolean #New value
function Instruction:set_has_xacquire_prefix(new_value) end

---`true` if the instruction has the `XRELEASE` prefix (`F3`)
---
---@return boolean
function Instruction:has_xrelease_prefix() end

---`true` if the instruction has the `XRELEASE` prefix (`F3`)
---
---@param new_value boolean #New value
function Instruction:set_has_xrelease_prefix(new_value) end

---`true` if the instruction has the `REPE` or `REP` prefix (`F3`)
---
---@return boolean
function Instruction:has_rep_prefix() end

---`true` if the instruction has the `REPE` or `REP` prefix (`F3`)
---
---@param new_value boolean #New value
function Instruction:set_has_rep_prefix(new_value) end

---`true` if the instruction has the `REPE` or `REP` prefix (`F3`)
---
---@return boolean
function Instruction:has_repe_prefix() end

---`true` if the instruction has the `REPE` or `REP` prefix (`F3`)
---
---@param new_value boolean #New value
function Instruction:set_has_repe_prefix(new_value) end

---`true` if the instruction has the `REPNE` prefix (`F2`)
---
---@return boolean
function Instruction:has_repne_prefix() end

---`true` if the instruction has the `REPNE` prefix (`F2`)
---
---@param new_value boolean #New value
function Instruction:set_has_repne_prefix(new_value) end

---`true` if the instruction has the `LOCK` prefix (`F0`)
---
---@return boolean
function Instruction:has_lock_prefix() end

---`true` if the instruction has the `LOCK` prefix (`F0`)
---
---@param new_value boolean #New value
function Instruction:set_has_lock_prefix(new_value) end

---Gets operand #0's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op0_kind() end

---Gets operand #0's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op0_kind(new_value) end

---Gets operand #1's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op1_kind() end

---Gets operand #1's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op1_kind(new_value) end

---Gets operand #2's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op2_kind() end

---Gets operand #2's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op2_kind(new_value) end

---Gets operand #3's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op3_kind() end

---Gets operand #3's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op3_kind(new_value) end

---Gets operand #4's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@return integer #An `OpKind` enum value
function Instruction:op4_kind() end

---Gets operand #4's kind (an `OpKind` enum value) if the operand exists (see `Instruction:op_count()` and `Instruction:op_kind()`)
---
---@param new_value integer #New value (An `OpKind` enum value)
function Instruction:set_op4_kind(new_value) end

---Gets an operand's kind (an `OpKind` enum value) if it exists (see `Instruction:op_count()`)
---
---@param operand integer #Operand number, 0-4
---@return integer #An `OpKind` enum value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local OpKind = require("iced_x86.OpKind")
---local Register = require("iced_x86.Register")
---
----- add [rax],ebx
---local data = "\001\024"
---local decoder = Decoder.new(64, data)
---local instr = decoder:decode()
---
---assert(instr:op_count() == 2)
---assert(instr:op_kind(0) == OpKind.Memory)
---assert(instr:memory_base() == Register.RAX)
---assert(instr:memory_index() == Register.None)
---assert(instr:op_kind(1) == OpKind.Register)
---assert(instr:op_register(1) == Register.EBX)
---```
function Instruction:op_kind(operand) end

---Gets an operand's kind (an `OpKind` enum value) if it exists (see `Instruction:op_count()`)
---
---@param operand integer #Operand number, 0-4
---@param op_kind integer #New value (An `OpKind` enum value)
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local OpKind = require("iced_x86.OpKind")
---local Register = require("iced_x86.Register")
---
----- add [rax],ebx
---local data = "\001\024"
---local decoder = Decoder.new(64, data)
---local instr = decoder:decode()
---
---assert(instr:op_count() == 2)
---assert(instr:op_kind(0) == OpKind.Memory)
---assert(instr:memory_base() == Register.RAX)
---assert(instr:memory_index() == Register.None)
---assert(instr:op_kind(1) == OpKind.Register)
---assert(instr:op_register(1) == Register.EBX)
---```
function Instruction:set_op_kind(operand, op_kind) end

---Checks if the instruction has a segment override prefix, see `Instruction:segment_prefix()`
---
---@return boolean
function Instruction:has_segment_prefix() end

---Gets the segment override prefix (a `Register` enum value) or `Register.None` if none.
---
---See also `Instruction:memory_segment()`.
---
---Use this method if the operand has kind `OpKind.Memory`,
---`OpKind.MemorySegSI`, `OpKind.MemorySegESI`, `OpKind.MemorySegRSI`
---
---@return integer #A `Register` enum value
function Instruction:segment_prefix() end

---Gets the segment override prefix (a `Register` enum value) or `Register.None` if none.
---
---See also `Instruction:memory_segment()`.
---
---Use this method if the operand has kind `OpKind.Memory`,
---`OpKind.MemorySegSI`, `OpKind.MemorySegESI`, `OpKind.MemorySegRSI`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_segment_prefix(new_value) end

---Gets the effective segment register used to reference the memory location (a `Register` enum value).
---
---Use this method if the operand has kind `OpKind.Memory`, `OpKind.MemorySegSI`, `OpKind.MemorySegESI`, `OpKind.MemorySegRSI`
---
---@return integer #A `Register` enum value
function Instruction:memory_segment() end

---Gets the size of the memory displacement in bytes.
---
---Valid values are `0`, `1` (16/32/64-bit), `2` (16-bit), `4` (32-bit), `8` (64-bit).
---
---Note that the return value can be 1 and `Instruction:memory_displacement()` may still not fit in
---a signed byte if it's an EVEX/MVEX encoded instruction.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer
function Instruction:memory_displ_size() end

---Gets the size of the memory displacement in bytes.
---
---Valid values are `0`, `1` (16/32/64-bit), `2` (16-bit), `4` (32-bit), `8` (64-bit).
---
---Note that the return value can be 1 and `Instruction:memory_displacement()` may still not fit in
---a signed byte if it's an EVEX/MVEX encoded instruction.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value
function Instruction:set_memory_displ_size(new_value) end

---`true` if the data is broadcast (EVEX instructions only)
---
---@return boolean
function Instruction:is_broadcast() end

---`true` if the data is broadcast (EVEX instructions only)
---
---@param new_value boolean #New value
function Instruction:set_is_broadcast(new_value) end

---`true` if eviction hint bit is set (`{eh}`) (MVEX instructions only)
---
---@return boolean
function Instruction:is_mvex_eviction_hint() end

---`true` if eviction hint bit is set (`{eh}`) (MVEX instructions only)
---
---@param new_value boolean #New value
function Instruction:set_is_mvex_eviction_hint(new_value) end

---(MVEX) Register/memory operand conversion function (an `MvexRegMemConv` enum value)
---
---@return integer #An `MvexRegMemConv` enum value
function Instruction:mvex_reg_mem_conv() end

---(MVEX) Register/memory operand conversion function (an `MvexRegMemConv` enum value)
---
---@param new_value integer #New value (An `MvexRegMemConv` enum value)
function Instruction:set_mvex_reg_mem_conv(new_value) end

---Gets the size of the memory location (a `MemorySize` enum value) that is referenced by the operand.
---
---See also `Instruction:is_broadcast()`.
---
---Use this method if the operand has kind `OpKind.Memory`,
---`OpKind.MemorySegSI`, `OpKind.MemorySegESI`, `OpKind.MemorySegRSI`,
---`OpKind.MemoryESDI`, `OpKind.MemoryESEDI`, `OpKind.MemoryESRDI`
---
---@return integer #A `MemorySize` enum value
function Instruction:memory_size() end

---Gets the index register scale value, valid values are `*1`, `*2`, `*4`, `*8`.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer
function Instruction:memory_index_scale() end

---Gets the index register scale value, valid values are `*1`, `*2`, `*4`, `*8`.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value
function Instruction:set_memory_index_scale(new_value) end

---Gets the memory operand's displacement or the 64-bit absolute address if it's
---an `EIP` or `RIP` relative memory operand.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer
function Instruction:memory_displacement() end

---Gets the memory operand's displacement or the 64-bit absolute address if it's
---an `EIP` or `RIP` relative memory operand.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value
function Instruction:set_memory_displacement(new_value) end

---Gets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@return integer #(`u64`) The immediate
function Instruction:immediate(operand) end

---Sets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #(`i32`) Immediate
function Instruction:set_immediate_i32(operand, new_value) end

---Sets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #(`u32`) Immediate
function Instruction:set_immediate_u32(operand, new_value) end

---Sets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #(`i64`) Immediate
function Instruction:set_immediate_i64(operand, new_value) end

---Sets an operand's immediate value
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #(`u64`) Immediate
function Instruction:set_immediate_u64(operand, new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8`
---
---@return integer
function Instruction:immediate8() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8`
---
---@param new_value integer #New value
function Instruction:set_immediate8(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8_2nd`
---
---@return integer
function Instruction:immediate8_2nd() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8_2nd`
---
---@param new_value integer #New value
function Instruction:set_immediate8_2nd(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate16`
---
---@return integer
function Instruction:immediate16() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate16`
---
---@param new_value integer #New value
function Instruction:set_immediate16(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate32`
---
---@return integer
function Instruction:immediate32() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate32`
---
---@param new_value integer #New value
function Instruction:set_immediate32(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate64`
---
---@return integer
function Instruction:immediate64() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate64`
---
---@param new_value integer #New value
function Instruction:set_immediate64(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To16`
---
---@return integer
function Instruction:immediate8to16() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To16`
---
---@param new_value integer #New value
function Instruction:set_immediate8to16(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To32`
---
---@return integer
function Instruction:immediate8to32() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To32`
---
---@param new_value integer #New value
function Instruction:set_immediate8to32(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To64`
---
---@return integer
function Instruction:immediate8to64() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate8To64`
---
---@param new_value integer #New value
function Instruction:set_immediate8to64(new_value) end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate32To64`
---
---@return integer
function Instruction:immediate32to64() end

---Gets the operand's immediate value.
---
---Use this method if the operand has kind `OpKind.Immediate32To64`
---
---@param new_value integer #New value
function Instruction:set_immediate32to64(new_value) end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch16`
---
---@return integer
function Instruction:near_branch16() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch16`
---
---@param new_value integer #New value
function Instruction:set_near_branch16(new_value) end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch32`
---
---@return integer
function Instruction:near_branch32() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch32`
---
---@param new_value integer #New value
function Instruction:set_near_branch32(new_value) end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch64`
---
---@return integer
function Instruction:near_branch64() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.NearBranch64`
---
---@param new_value integer #New value
function Instruction:set_near_branch64(new_value) end

---Gets the near branch target if it's a `CALL`/`JMP`/`Jcc` near branch instruction
---
---(i.e., if `Instruction:op0_kind()` is `OpKind.NearBranch16`, `OpKind.NearBranch32` or `OpKind.NearBranch64`)
---
---@return integer
function Instruction:near_branch_target() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.FarBranch16`
---
---@return integer
function Instruction:far_branch16() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.FarBranch16`
---
---@param new_value integer #New value
function Instruction:set_far_branch16(new_value) end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.FarBranch32`
---
---@return integer
function Instruction:far_branch32() end

---Gets the operand's branch target.
---
---Use this method if the operand has kind `OpKind.FarBranch32`
---
---@param new_value integer #New value
function Instruction:set_far_branch32(new_value) end

---Gets the operand's branch target selector.
---
---Use this method if the operand has kind `OpKind.FarBranch16` or `OpKind.FarBranch32`
---
---@return integer
function Instruction:far_branch_selector() end

---Gets the operand's branch target selector.
---
---Use this method if the operand has kind `OpKind.FarBranch16` or `OpKind.FarBranch32`
---
---@param new_value integer #New value
function Instruction:set_far_branch_selector(new_value) end

---Gets the memory operand's base register (a `Register` enum value) or `Register.None` if none.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer #A `Register` enum value
function Instruction:memory_base() end

---Gets the memory operand's base register (a `Register` enum value) or `Register.None` if none.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_memory_base(new_value) end

---Gets the memory operand's index register (a `Register` enum value) or `Register.None` if none.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@return integer #A `Register` enum value
function Instruction:memory_index() end

---Gets the memory operand's index register (a `Register` enum value) or `Register.None` if none.
---
---Use this method if the operand has kind `OpKind.Memory`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_memory_index(new_value) end

---Gets operand #0's register value (a `Register` enum value).
---
---Use this method if operand #0 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op0_register() end

---Gets operand #0's register value (a `Register` enum value).
---
---Use this method if operand #0 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op0_register(new_value) end

---Gets operand #1's register value (a `Register` enum value).
---
---Use this method if operand #1 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op1_register() end

---Gets operand #1's register value (a `Register` enum value).
---
---Use this method if operand #1 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op1_register(new_value) end

---Gets operand #2's register value (a `Register` enum value).
---
---Use this method if operand #2 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op2_register() end

---Gets operand #2's register value (a `Register` enum value).
---
---Use this method if operand #2 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op2_register(new_value) end

---Gets operand #3's register value (a `Register` enum value).
---
---Use this method if operand #3 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op3_register() end

---Gets operand #3's register value (a `Register` enum value).
---
---Use this method if operand #3 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op3_register(new_value) end

---Gets operand #4's register value (a `Register` enum value).
---
---Use this method if operand #4 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@return integer #A `Register` enum value
function Instruction:op4_register() end

---Gets operand #4's register value (a `Register` enum value).
---
---Use this method if operand #4 (`Instruction:op0_kind()`) has kind `OpKind.Register`, see `Instruction:op_count()` and `Instruction:op_register()`
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op4_register(new_value) end

---Gets the operand's register value (a `Register` enum value).
---
---Use this method if the operand has kind `OpKind.Register`
---
---@param operand integer #Operand number, 0-4
---@return integer #(A `Register` enum value) The operand's register value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local OpKind = require("iced_x86.OpKind")
---local Register = require("iced_x86.Register")
---
----- add [rax],ebx
---local data = "\001\024"
---local decoder = Decoder.new(64, data)
---local instr = decoder:decode()
---
---assert(instr:op_count() == 2)
---assert(instr:op_kind(0) == OpKind.Memory)
---assert(instr:op_kind(1) == OpKind.Register)
---assert(instr:op_register(1) == Register.EBX)
---```
function Instruction:op_register(operand) end

---Gets the operand's register value (a `Register` enum value).
---
---Use this method if the operand has kind `OpKind.Register`
---
---@param operand integer #Operand number, 0-4
---@param new_value integer #New value ((A `Register` enum value) The operand's register value)
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local OpKind = require("iced_x86.OpKind")
---local Register = require("iced_x86.Register")
---
----- add [rax],ebx
---local data = "\001\024"
---local decoder = Decoder.new(64, data)
---local instr = decoder:decode()
---
---assert(instr:op_count() == 2)
---assert(instr:op_kind(0) == OpKind.Memory)
---assert(instr:op_kind(1) == OpKind.Register)
---assert(instr:op_register(1) == Register.EBX)
---```
function Instruction:set_op_register(operand, new_value) end

---Gets the opmask register (`Register.K1` - `Register.K7`) or `Register.None` if none (a `Register` enum value)
---
---@return integer #A `Register` enum value
function Instruction:op_mask() end

---Gets the opmask register (`Register.K1` - `Register.K7`) or `Register.None` if none (a `Register` enum value)
---
---@param new_value integer #New value (A `Register` enum value)
function Instruction:set_op_mask(new_value) end

---Checks if there's an opmask register (`Instruction:op_mask()`)
---
---@return boolean
function Instruction:has_op_mask() end

---`true` if zeroing-masking, `false` if merging-masking.
---
---Only used by most EVEX encoded instructions that use opmask registers.
---
---@return boolean
function Instruction:zeroing_masking() end

---`true` if zeroing-masking, `false` if merging-masking.
---
---Only used by most EVEX encoded instructions that use opmask registers.
---
---@param new_value boolean #New value
function Instruction:set_zeroing_masking(new_value) end

---`true` if merging-masking, `false` if zeroing-masking.
---
---Only used by most EVEX encoded instructions that use opmask registers.
---
---@return boolean
function Instruction:merging_masking() end

---`true` if merging-masking, `false` if zeroing-masking.
---
---Only used by most EVEX encoded instructions that use opmask registers.
---
---@param new_value boolean #New value
function Instruction:set_merging_masking(new_value) end

---Gets the rounding control (a `RoundingControl` enum value) or `RoundingControl.None` if the instruction doesn't use it.
---
---# Note
---SAE is implied but `Instruction:suppress_all_exceptions()` still returns `false`.
---
---@return integer #A `RoundingControl` enum value
function Instruction:rounding_control() end

---Gets the rounding control (a `RoundingControl` enum value) or `RoundingControl.None` if the instruction doesn't use it.
---
---# Note
---SAE is implied but `Instruction:suppress_all_exceptions()` still returns `false`.
---
---@param new_value integer #New value (A `RoundingControl` enum value)
function Instruction:set_rounding_control(new_value) end

---Gets the number of elements in a `db`/`dw`/`dd`/`dq` directive.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`, `Code.DeclareWord`, `Code.DeclareDword`, `Code.DeclareQword`
---
---@return integer
function Instruction:declare_data_len() end

---Gets the number of elements in a `db`/`dw`/`dd`/`dq` directive.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`, `Code.DeclareWord`, `Code.DeclareDword`, `Code.DeclareQword`
---
---@param new_value integer #New value
function Instruction:set_declare_data_len(new_value) end

---Sets a new `db` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`
---
---@param index integer #Index (0-15)
---@param new_value integer #(`u8`) New value
function Instruction:set_declare_byte_value(index, new_value) end

---Gets a `db` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`
---
---@param index integer #Index (0-15)
---@return integer #(`u8`) The value
function Instruction:get_declare_byte_value(index) end

---Gets a `db` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareByte`
---
---@param index integer #Index (0-15)
---@return integer #(`i8`) The value
function Instruction:get_declare_byte_value_i8(index) end

---Sets a new `dw` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareWord`
---
---@param index integer #Index (0-7)
---@param new_value integer #(`u16`) New value
function Instruction:set_declare_word_value(index, new_value) end

---Gets a `dw` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareWord`
---
---@param index integer #Index (0-7)
---@return integer #(`u16`) The value
function Instruction:get_declare_word_value(index) end

---Gets a `dw` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareWord`
---
---@param index integer #Index (0-7)
---@return integer #(`i16`) The value
function Instruction:get_declare_word_value_i16(index) end

---Sets a new `dd` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareDword`
---
---@param index integer #Index (0-3)
---@param new_value integer #(`u32`) New value
function Instruction:set_declare_dword_value(index, new_value) end

---Gets a `dd` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareDword`
---
---@param index integer #Index (0-3)
---@return integer #(`u32`) The value
function Instruction:get_declare_dword_value(index) end

---Gets a `dd` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareDword`
---
---@param index integer #Index (0-3)
---@return integer #(`i32`) The value
function Instruction:get_declare_dword_value_i32(index) end

---Sets a new `dq` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareQword`
---
---@param index integer #Index (0-1)
---@param new_value integer #(`u64`) New value
function Instruction:set_declare_qword_value(index, new_value) end

---Gets a `dq` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareQword`
---
---@param index integer #Index (0-1)
---@return integer #(`u64`) The value
function Instruction:get_declare_qword_value(index) end

---Gets a `dq` value, see also `Instruction:declare_data_len()`.
---
---Can only be called if `Instruction:code()` is `Code.DeclareQword`
---
---@param index integer #Index (0-1)
---@return integer #(`i64`) The value
function Instruction:get_declare_qword_value_i64(index) end

---Checks if this is a VSIB instruction, see also `Instruction:is_vsib32()`, `Instruction:is_vsib64()`
---
---@return boolean
function Instruction:is_vsib() end

---VSIB instructions only (`Instruction:is_vsib()`): `true` if it's using 32-bit indexes, `false` if it's using 64-bit indexes
---
---@return boolean
function Instruction:is_vsib32() end

---VSIB instructions only (`Instruction:is_vsib()`): `true` if it's using 64-bit indexes, `false` if it's using 32-bit indexes
---
---@return boolean
function Instruction:is_vsib64() end

---Checks if it's a vsib instruction.
---
---- Returns `true` if it's a VSIB instruction with 64-bit indexes
---- Returns `false` if it's a VSIB instruction with 32-bit indexes
---- Returns `nil` if it's not a VSIB instruction.
---
---@return boolean|nil
function Instruction:vsib() end

---Gets the suppress all exceptions flag (EVEX/MVEX encoded instructions). Note that if `Instruction:rounding_control()` is not `RoundingControl.None`, SAE is implied but this method will still return `false`.
---
---@return boolean
function Instruction:suppress_all_exceptions() end

---Gets the suppress all exceptions flag (EVEX/MVEX encoded instructions). Note that if `Instruction:rounding_control()` is not `RoundingControl.None`, SAE is implied but this method will still return `false`.
---
---@param new_value boolean #New value
function Instruction:set_suppress_all_exceptions(new_value) end

---Checks if the memory operand is `RIP`/`EIP` relative
---
---@return boolean
function Instruction:is_ip_rel_memory_operand() end

---Gets the `RIP`/`EIP` releative address (`Instruction:memory_displacement()`).
---
---This method is only valid if there's a memory operand with `RIP`/`EIP` relative addressing, see `Instruction:is_ip_rel_memory_operand()`
---
---@return integer
function Instruction:ip_rel_memory_address() end

---Gets the number of bytes added to `SP`/`ESP`/`RSP` or 0 if it's not an instruction that pushes or pops data.
---
---This method assumes the instruction doesn't change the privilege level (eg. `IRET/D/Q`). If it's the `LEAVE`
---instruction, this method returns 0.
---
---@return integer
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---
----- pushfq
---local data = "\156"
---local decoder = Decoder.new(64, data)
---local instr = decoder:decode()
---
---assert(instr:is_stack_instruction())
---assert(instr:stack_pointer_increment() == -8)
---```
function Instruction:stack_pointer_increment() end

---Gets the FPU status word's `TOP` increment value and whether it's a conditional or unconditional push/pop and whether `TOP` is written.
---
---@return FpuStackIncrementInfo #FPU stack info
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---
----- ficomp dword ptr [rax]
---local data = "\218\024"
---local decoder = Decoder.new(64, data)
---local instr = decoder:decode()
---
---local info = instr:fpu_stack_increment_info()
----- It pops the stack once
---assert(info:increment() == 1)
---assert(not info:conditional())
---assert(info:writes_top())
---```
function Instruction:fpu_stack_increment_info() end

---Instruction encoding, eg. Legacy, 3DNow!, VEX, EVEX, XOP (an `EncodingKind` enum value)
---
---@return integer #An `EncodingKind` enum value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local EncodingKind = require("iced_x86.EncodingKind")
---
----- vmovaps xmm1,xmm5
---local data = "\197\248\040\205"
---local decoder = Decoder.new(64, data)
---local instr = decoder:decode()
---
---assert(instr:encoding() == EncodingKind.VEX)
---```
function Instruction:encoding() end

---Gets the CPU or CPUID feature flags (an array of `CpuidFeature` enum values)
---
---@return integer[] #(A `CpuidFeature` array) CPU or CPUID feature flags
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local CpuidFeature = require("iced_x86.CpuidFeature")
---
----- vmovaps xmm1,xmm5
----- vmovaps xmm10{k3}{z},xmm19
---local data = "\197\248\040\205\098\049\124\139\040\211"
---local decoder = Decoder.new(64, data)
---
----- vmovaps xmm1,xmm5
---local instr = decoder:decode()
---local cpuid = instr:cpuid_features()
---assert(#cpuid == 1)
---assert(cpuid[1] == CpuidFeature.AVX)
---
----- vmovaps xmm10{k3}{z},xmm19
---local instr2 = decoder:decode()
---local cpuid2 = instr2:cpuid_features()
---assert(#cpuid2 == 2)
---assert(cpuid2[1] == CpuidFeature.AVX512VL)
---assert(cpuid2[2] == CpuidFeature.AVX512F)
---```
function Instruction:cpuid_features() end

---Control flow info (a `FlowControl` enum value)
---
---@return integer #A `FlowControl` enum value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local FlowControl = require("iced_x86.FlowControl")
---
----- or ecx,esi
----- ud0 rcx,rsi
----- call rcx
---local data = "\011\206\072\015\255\206\255\209"
---local decoder = Decoder.new(64, data)
---
----- or ecx,esi
---local instr = decoder:decode()
---assert(instr:flow_control() == FlowControl.Next)
---
----- ud0 rcx,rsi
---local instr2 = decoder:decode()
---assert(instr2:flow_control() == FlowControl.Exception)
---
----- call rcx
---local instr3 = decoder:decode()
---assert(instr3:flow_control() == FlowControl.IndirectCall)
---```
function Instruction:flow_control() end

---`true` if it's a privileged instruction (all CPL=0 instructions (except `VMCALL`) and IOPL instructions `IN`, `INS`, `OUT`, `OUTS`, `CLI`, `STI`)
---
---@return boolean
function Instruction:is_privileged() end

---`true` if this is an instruction that implicitly uses the stack pointer (`SP`/`ESP`/`RSP`), eg. `CALL`, `PUSH`, `POP`, `RET`, etc.
---
---See also `Instruction:stack_pointer_increment()`
---
---@return boolean
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---
----- or ecx,esi
----- push rax
---local data = "\011\206\080"
---local decoder = Decoder.new(64, data)
---
----- or ecx,esi
---local instr = decoder:decode()
---assert(not instr:is_stack_instruction())
---
----- push rax
---local instr2 = decoder:decode()
---assert(instr2:is_stack_instruction())
---assert(instr2:stack_pointer_increment() == -8)
---```
function Instruction:is_stack_instruction() end

---`true` if it's an instruction that saves or restores too many registers (eg. `FXRSTOR`, `XSAVE`, etc).
---
---@return boolean
function Instruction:is_save_restore_instruction() end

---`true` if it's a "string" instruction, such as `MOVS`, `LODS`, `SCAS`, etc.
---
---@return boolean
function Instruction:is_string_instruction() end

---All flags that are read by the CPU when executing the instruction.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local RflagsBits = require("iced_x86.RflagsBits")
---
----- adc rsi,rcx
----- xor rdi,5Ah
---local data = "\072\017\206\072\131\247\090"
---local decoder = Decoder.new(64, data)
---
----- adc rsi,rcx
---local instr = decoder:decode()
---assert(instr:rflags_read() == RflagsBits.CF)
---assert(instr:rflags_written() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---assert(instr:rflags_cleared() == RflagsBits.None)
---assert(instr:rflags_set() == RflagsBits.None)
---assert(instr:rflags_undefined() == RflagsBits.None)
---assert(instr:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---
----- xor rdi,5Ah
---local instr2 = decoder:decode()
---assert(instr2:rflags_read() == RflagsBits.None)
---assert(instr2:rflags_written() == RflagsBits.SF + RflagsBits.ZF + RflagsBits.PF)
---assert(instr2:rflags_cleared() == RflagsBits.OF + RflagsBits.CF)
---assert(instr2:rflags_set() == RflagsBits.None)
---assert(instr2:rflags_undefined() == RflagsBits.AF)
---assert(instr2:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---```
function Instruction:rflags_read() end

---All flags that are written by the CPU, except those flags that are known to be undefined, always set or always cleared.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local RflagsBits = require("iced_x86.RflagsBits")
---
----- adc rsi,rcx
----- xor rdi,5Ah
---local data = "\072\017\206\072\131\247\090"
---local decoder = Decoder.new(64, data)
---
----- adc rsi,rcx
---local instr = decoder:decode()
---assert(instr:rflags_read() == RflagsBits.CF)
---assert(instr:rflags_written() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---assert(instr:rflags_cleared() == RflagsBits.None)
---assert(instr:rflags_set() == RflagsBits.None)
---assert(instr:rflags_undefined() == RflagsBits.None)
---assert(instr:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---
----- xor rdi,5Ah
---local instr2 = decoder:decode()
---assert(instr2:rflags_read() == RflagsBits.None)
---assert(instr2:rflags_written() == RflagsBits.SF + RflagsBits.ZF + RflagsBits.PF)
---assert(instr2:rflags_cleared() == RflagsBits.OF + RflagsBits.CF)
---assert(instr2:rflags_set() == RflagsBits.None)
---assert(instr2:rflags_undefined() == RflagsBits.AF)
---assert(instr2:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---```
function Instruction:rflags_written() end

---All flags that are always cleared by the CPU.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local RflagsBits = require("iced_x86.RflagsBits")
---
----- adc rsi,rcx
----- xor rdi,5Ah
---local data = "\072\017\206\072\131\247\090"
---local decoder = Decoder.new(64, data)
---
----- adc rsi,rcx
---local instr = decoder:decode()
---assert(instr:rflags_read() == RflagsBits.CF)
---assert(instr:rflags_written() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---assert(instr:rflags_cleared() == RflagsBits.None)
---assert(instr:rflags_set() == RflagsBits.None)
---assert(instr:rflags_undefined() == RflagsBits.None)
---assert(instr:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---
----- xor rdi,5Ah
---local instr2 = decoder:decode()
---assert(instr2:rflags_read() == RflagsBits.None)
---assert(instr2:rflags_written() == RflagsBits.SF + RflagsBits.ZF + RflagsBits.PF)
---assert(instr2:rflags_cleared() == RflagsBits.OF + RflagsBits.CF)
---assert(instr2:rflags_set() == RflagsBits.None)
---assert(instr2:rflags_undefined() == RflagsBits.AF)
---assert(instr2:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---```
function Instruction:rflags_cleared() end

---All flags that are always set by the CPU.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local RflagsBits = require("iced_x86.RflagsBits")
---
----- adc rsi,rcx
----- xor rdi,5Ah
---local data = "\072\017\206\072\131\247\090"
---local decoder = Decoder.new(64, data)
---
----- adc rsi,rcx
---local instr = decoder:decode()
---assert(instr:rflags_read() == RflagsBits.CF)
---assert(instr:rflags_written() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---assert(instr:rflags_cleared() == RflagsBits.None)
---assert(instr:rflags_set() == RflagsBits.None)
---assert(instr:rflags_undefined() == RflagsBits.None)
---assert(instr:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---
----- xor rdi,5Ah
---local instr2 = decoder:decode()
---assert(instr2:rflags_read() == RflagsBits.None)
---assert(instr2:rflags_written() == RflagsBits.SF + RflagsBits.ZF + RflagsBits.PF)
---assert(instr2:rflags_cleared() == RflagsBits.OF + RflagsBits.CF)
---assert(instr2:rflags_set() == RflagsBits.None)
---assert(instr2:rflags_undefined() == RflagsBits.AF)
---assert(instr2:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---```
function Instruction:rflags_set() end

---All flags that are undefined after executing the instruction.
---
---This method returns an `RflagsBits` value. See also `Instruction:rflags_modified()`.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local RflagsBits = require("iced_x86.RflagsBits")
---
----- adc rsi,rcx
----- xor rdi,5Ah
---local data = "\072\017\206\072\131\247\090"
---local decoder = Decoder.new(64, data)
---
----- adc rsi,rcx
---local instr = decoder:decode()
---assert(instr:rflags_read() == RflagsBits.CF)
---assert(instr:rflags_written() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---assert(instr:rflags_cleared() == RflagsBits.None)
---assert(instr:rflags_set() == RflagsBits.None)
---assert(instr:rflags_undefined() == RflagsBits.None)
---assert(instr:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---
----- xor rdi,5Ah
---local instr2 = decoder:decode()
---assert(instr2:rflags_read() == RflagsBits.None)
---assert(instr2:rflags_written() == RflagsBits.SF + RflagsBits.ZF + RflagsBits.PF)
---assert(instr2:rflags_cleared() == RflagsBits.OF + RflagsBits.CF)
---assert(instr2:rflags_set() == RflagsBits.None)
---assert(instr2:rflags_undefined() == RflagsBits.AF)
---assert(instr2:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---```
function Instruction:rflags_undefined() end

---All flags that are modified by the CPU. This is `rflags_written + rflags_cleared + rflags_set + rflags_undefined`.
---
---This method returns an `RflagsBits` value.
---
---@return integer #An `RflagsBits` enum value
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local RflagsBits = require("iced_x86.RflagsBits")
---
----- adc rsi,rcx
----- xor rdi,5Ah
---local data = "\072\017\206\072\131\247\090"
---local decoder = Decoder.new(64, data)
---
----- adc rsi,rcx
---local instr = decoder:decode()
---assert(instr:rflags_read() == RflagsBits.CF)
---assert(instr:rflags_written() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---assert(instr:rflags_cleared() == RflagsBits.None)
---assert(instr:rflags_set() == RflagsBits.None)
---assert(instr:rflags_undefined() == RflagsBits.None)
---assert(instr:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---
----- xor rdi,5Ah
---local instr2 = decoder:decode()
---assert(instr2:rflags_read() == RflagsBits.None)
---assert(instr2:rflags_written() == RflagsBits.SF + RflagsBits.ZF + RflagsBits.PF)
---assert(instr2:rflags_cleared() == RflagsBits.OF + RflagsBits.CF)
---assert(instr2:rflags_set() == RflagsBits.None)
---assert(instr2:rflags_undefined() == RflagsBits.AF)
---assert(instr2:rflags_modified() == RflagsBits.OF + RflagsBits.SF + RflagsBits.ZF + RflagsBits.AF + RflagsBits.CF + RflagsBits.PF)
---```
function Instruction:rflags_modified() end

---Checks if it's a `Jcc SHORT` or `Jcc NEAR` instruction
---
---@return boolean
function Instruction:is_jcc_short_or_near() end

---Checks if it's a `Jcc NEAR` instruction
---
---@return boolean
function Instruction:is_jcc_near() end

---Checks if it's a `Jcc SHORT` instruction
---
---@return boolean
function Instruction:is_jcc_short() end

---Checks if it's a `JMP SHORT` instruction
---
---@return boolean
function Instruction:is_jmp_short() end

---Checks if it's a `JMP NEAR` instruction
---
---@return boolean
function Instruction:is_jmp_near() end

---Checks if it's a `JMP SHORT` or a `JMP NEAR` instruction
---
---@return boolean
function Instruction:is_jmp_short_or_near() end

---Checks if it's a `JMP FAR` instruction
---
---@return boolean
function Instruction:is_jmp_far() end

---Checks if it's a `CALL NEAR` instruction
---
---@return boolean
function Instruction:is_call_near() end

---Checks if it's a `CALL FAR` instruction
---
---@return boolean
function Instruction:is_call_far() end

---Checks if it's a `JMP NEAR reg/[mem]` instruction
---
---@return boolean
function Instruction:is_jmp_near_indirect() end

---Checks if it's a `JMP FAR [mem]` instruction
---
---@return boolean
function Instruction:is_jmp_far_indirect() end

---Checks if it's a `CALL NEAR reg/[mem]` instruction
---
---@return boolean
function Instruction:is_call_near_indirect() end

---Checks if it's a `CALL FAR [mem]` instruction
---
---@return boolean
function Instruction:is_call_far_indirect() end

---Checks if it's a `JKccD SHORT` or `JKccD NEAR` instruction
---
---@return boolean
function Instruction:is_jkcc_short_or_near() end

---Checks if it's a `JKccD NEAR` instruction
---
---@return boolean
function Instruction:is_jkcc_near() end

---Checks if it's a `JKccD SHORT` instruction
---
---@return boolean
function Instruction:is_jkcc_short() end

---Checks if it's a `JCXZ SHORT`, `JECXZ SHORT` or `JRCXZ SHORT` instruction
---
---@return boolean
function Instruction:is_jcx_short() end

---Checks if it's a `LOOPcc SHORT` instruction
---
---@return boolean
function Instruction:is_loopcc() end

---Checks if it's a `LOOP SHORT` instruction
---
---@return boolean
function Instruction:is_loop() end

---Negates the condition code, eg. `JE` -> `JNE`.
---
---Can be used if it's `Jcc`, `SETcc`, `CMOVcc`, `CMPccXADD`, `LOOPcc` and does nothing if the instruction doesn't have a condition code.
---
---# Examples
---
---```lua
---local Code = require("iced_x86.Code")
---local ConditionCode = require("iced_x86.ConditionCode")
---local Decoder = require("iced_x86.Decoder")
---
----- setbe al
---local data = "\015\150\192"
---local decoder = Decoder.new(64, data)
---
---local instr = decoder:decode()
---assert(instr:code() == Code.Setbe_rm8)
---assert(instr:condition_code() == ConditionCode.be)
---instr:negate_condition_code()
---assert(instr:code() == Code.Seta_rm8)
---assert(instr:condition_code() == ConditionCode.a)
---```
function Instruction:negate_condition_code() end

---Converts `Jcc/JMP NEAR` to `Jcc/JMP SHORT` and does nothing if it's not a `Jcc/JMP NEAR` instruction
---
---# Examples
---
---```lua
---local Code = require("iced_x86.Code")
---local Decoder = require("iced_x86.Decoder")
---
----- jbe near ptr label
---local data = "\015\134\090\165\018\052"
---local decoder = Decoder.new(64, data)
---
---local instr = decoder:decode()
---assert(instr:code() == Code.Jbe_rel32_64)
---instr:as_short_branch()
---assert(instr:code() == Code.Jbe_rel8_64)
---instr:as_short_branch()
---assert(instr:code() == Code.Jbe_rel8_64)
---```
function Instruction:as_short_branch() end

---Converts `Jcc/JMP SHORT` to `Jcc/JMP NEAR` and does nothing if it's not a `Jcc/JMP SHORT` instruction
---
---# Examples
---
---```lua
---local Code = require("iced_x86.Code")
---local Decoder = require("iced_x86.Decoder")
---
----- jbe short label
---local data = "\118\090"
---local decoder = Decoder.new(64, data)
---
---local instr = decoder:decode()
---assert(instr:code() == Code.Jbe_rel8_64)
---instr:as_near_branch()
---assert(instr:code() == Code.Jbe_rel32_64)
---instr:as_near_branch()
---assert(instr:code() == Code.Jbe_rel32_64)
---```
function Instruction:as_near_branch() end

---Gets the condition code (a `ConditionCode` enum value) if it's `Jcc`, `SETcc`, `CMOVcc`, `CMPccXADD`, `LOOPcc` else `ConditionCode.None` is returned
---
---@return integer #A `ConditionCode` enum value
---
---# Examples
---
---```lua
---local ConditionCode = require("iced_x86.ConditionCode")
---local Decoder = require("iced_x86.Decoder")
---
----- setbe al
----- jl short label
----- cmovne ecx,esi
----- nop
---local data = "\015\150\192\124\090\015\069\206\144"
---local decoder = Decoder.new(64, data)
---
----- setbe al
---local instr = decoder:decode()
---assert(instr:condition_code() == ConditionCode.be)
---
----- jl short label
---local instr2 = decoder:decode()
---assert(instr2:condition_code() == ConditionCode.l)
---
----- cmovne ecx,esi
---local instr3 = decoder:decode()
---assert(instr3:condition_code() == ConditionCode.ne)
---
----- nop
---local instr4 = decoder:decode()
---assert(instr4:condition_code() == ConditionCode.None)
---```
function Instruction:condition_code() end

---Gets the `OpCodeInfo`
---
---@return OpCodeInfo #Op code info
function Instruction:op_code() end

---Gets all used registers
---
---See also `Instruction:used_memory()`, `Instruction:op_accesses()`, `Instruction:used_regs_mem()`, `Instruction:used_values()`
---
---@return UsedRegister[] #All used registers
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local OpAccess = require("iced_x86.OpAccess")
---local Register = require("iced_x86.Register")
---
---local decoder = Decoder.new(64, "\196\227\073\072\016\065")
---local instr = decoder:decode()
---
---local used_registers = instr:used_registers()
---assert(#used_registers == 4)
---assert(used_registers[1]:register() == Register.ZMM2)
---assert(used_registers[1]:access() == OpAccess.Write)
---assert(used_registers[2]:register() == Register.XMM6)
---assert(used_registers[2]:access() == OpAccess.Read)
---assert(used_registers[3]:register() == Register.RAX)
---assert(used_registers[3]:access() == OpAccess.Read)
---assert(used_registers[4]:register() == Register.XMM4)
---assert(used_registers[4]:access() == OpAccess.Read)
---```
function Instruction:used_registers() end

---Gets all used memory locations
---
---See also `Instruction:used_registers()`, `Instruction:op_accesses()`, `Instruction:used_regs_mem()`, `Instruction:used_values()`
---
---@return UsedMemory[] #All used memory locations
---
---# Examples
---
---```lua
---local CodeSize = require("iced_x86.CodeSize")
---local Decoder = require("iced_x86.Decoder")
---local MemorySize = require("iced_x86.MemorySize")
---local OpAccess = require("iced_x86.OpAccess")
---local Register = require("iced_x86.Register")
---
---local decoder = Decoder.new(64, "\196\227\073\072\016\065")
---local instr = decoder:decode()
---
---local used_memory = instr:used_memory()
---assert(#used_memory == 1)
---local mem = used_memory[1]
---assert(mem:segment() == Register.DS)
---assert(mem:base() == Register.RAX)
---assert(mem:index() == Register.None)
---assert(mem:scale() == 1)
---assert(mem:displacement() == 0)
---assert(mem:memory_size() == MemorySize.Packed128_Float32)
---assert(mem:access() == OpAccess.Read)
---assert(mem:address_size() == CodeSize.Code64)
---assert(mem:vsib_size() == 0)
---```
function Instruction:used_memory() end

---Gets all operand accesses (Array of `OpAccess` values)
---
---See also `Instruction:used_registers()`, `Instruction:used_memory()`, `Instruction:used_regs_mem()`, `Instruction:used_values()`
---
---@return integer[] #Array of `OpAccess` values
---
---# Examples
---
---```lua
---local Decoder = require("iced_x86.Decoder")
---local OpAccess = require("iced_x86.OpAccess")
---
---local decoder = Decoder.new(64, "\196\227\073\072\016\065")
---local instr = decoder:decode()
---
---local op_accesses = instr:op_accesses()
---assert(#op_accesses == 5)
---assert(op_accesses[1] == OpAccess.Write)
---assert(op_accesses[2] == OpAccess.Read)
---assert(op_accesses[3] == OpAccess.Read)
---assert(op_accesses[4] == OpAccess.Read)
---assert(op_accesses[5] == OpAccess.Read)
---```
function Instruction:op_accesses() end

---Gets all used registers and all used memory locations
---
---See also `Instruction:used_registers()`, `Instruction:used_memory()`, `Instruction:op_accesses()`, `Instruction:used_values()`
---
---@return UsedRegister[], UsedMemory[] #Used registers, used memory locations
---
---# Examples
---
---```lua
---local CodeSize = require("iced_x86.CodeSize")
---local Decoder = require("iced_x86.Decoder")
---local MemorySize = require("iced_x86.MemorySize")
---local OpAccess = require("iced_x86.OpAccess")
---local Register = require("iced_x86.Register")
---
---local decoder = Decoder.new(64, "\196\227\073\072\016\065")
---local instr = decoder:decode()
---
---local used_registers, used_memory = instr:used_regs_mem()
---
---assert(#used_registers == 4)
---assert(used_registers[1]:register() == Register.ZMM2)
---assert(used_registers[1]:access() == OpAccess.Write)
---assert(used_registers[2]:register() == Register.XMM6)
---assert(used_registers[2]:access() == OpAccess.Read)
---assert(used_registers[3]:register() == Register.RAX)
---assert(used_registers[3]:access() == OpAccess.Read)
---assert(used_registers[4]:register() == Register.XMM4)
---assert(used_registers[4]:access() == OpAccess.Read)
---
---assert(#used_memory == 1)
---local mem = used_memory[1]
---assert(mem:segment() == Register.DS)
---assert(mem:base() == Register.RAX)
---assert(mem:index() == Register.None)
---assert(mem:scale() == 1)
---assert(mem:displacement() == 0)
---assert(mem:memory_size() == MemorySize.Packed128_Float32)
---assert(mem:access() == OpAccess.Read)
---assert(mem:address_size() == CodeSize.Code64)
---assert(mem:vsib_size() == 0)
---```
function Instruction:used_regs_mem() end

---Gets all used registers, all used memory locations and all operand accesses
---
---See also `Instruction:used_registers()`, `Instruction:used_memory()`, `Instruction:op_accesses()`, `Instruction:used_regs_mem()`
---
---@return UsedRegister[], UsedMemory[], integer[] #Used registers, used memory locations and `OpAccess`[]
---
---# Examples
---
---```lua
---local CodeSize = require("iced_x86.CodeSize")
---local Decoder = require("iced_x86.Decoder")
---local MemorySize = require("iced_x86.MemorySize")
---local OpAccess = require("iced_x86.OpAccess")
---local Register = require("iced_x86.Register")
---
---local decoder = Decoder.new(64, "\196\227\073\072\016\065")
---local instr = decoder:decode()
---
---local used_registers, used_memory, op_accesses = instr:used_values()
---
---assert(#used_registers == 4)
---assert(used_registers[1]:register() == Register.ZMM2)
---assert(used_registers[1]:access() == OpAccess.Write)
---assert(used_registers[2]:register() == Register.XMM6)
---assert(used_registers[2]:access() == OpAccess.Read)
---assert(used_registers[3]:register() == Register.RAX)
---assert(used_registers[3]:access() == OpAccess.Read)
---assert(used_registers[4]:register() == Register.XMM4)
---assert(used_registers[4]:access() == OpAccess.Read)
---
---assert(#used_memory == 1)
---local mem = used_memory[1]
---assert(mem:segment() == Register.DS)
---assert(mem:base() == Register.RAX)
---assert(mem:index() == Register.None)
---assert(mem:scale() == 1)
---assert(mem:displacement() == 0)
---assert(mem:memory_size() == MemorySize.Packed128_Float32)
---assert(mem:access() == OpAccess.Read)
---assert(mem:address_size() == CodeSize.Code64)
---assert(mem:vsib_size() == 0)
---
---assert(#op_accesses == 5)
---assert(op_accesses[1] == OpAccess.Write)
---assert(op_accesses[2] == OpAccess.Read)
---assert(op_accesses[3] == OpAccess.Read)
---assert(op_accesses[4] == OpAccess.Read)
---assert(op_accesses[5] == OpAccess.Read)
---```
function Instruction:used_values() end

---Creates a `db`/`.byte` asm directive
---
---- If the single arg is a string, the length must be 1-16 bytes
---- If the single arg is a table, it must be an array with 1-16 i8/u8 integer elements
---- Else it must be 1-16 i8/u8 integer args
---
---# Examples
---
---```lua
---local Instruction = require("iced_x86.Instruction")
---
---local instr1 = Instruction.db("abc")
---local instr2 = Instruction.db({ 0x12, 0x34 })
---local instr3 = Instruction.db(0x12, 0x34, 0x56)
---```
---
---@return Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer, a9:integer, a10:integer, a11:integer, a12:integer, a13:integer, a14:integer, a15:integer, a16:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer, a9:integer, a10:integer, a11:integer, a12:integer, a13:integer, a14:integer, a15:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer, a9:integer, a10:integer, a11:integer, a12:integer, a13:integer, a14:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer, a9:integer, a10:integer, a11:integer, a12:integer, a13:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer, a9:integer, a10:integer, a11:integer, a12:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer, a9:integer, a10:integer, a11:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer, a9:integer, a10:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer, a9:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer): Instruction
---@overload fun(a1: integer, a2:integer): Instruction
---@overload fun(a1: integer): Instruction
---@overload fun(values: integer[]): Instruction
---@overload fun(bytes: string): Instruction
function Instruction.db() end

---Creates a `dw`/`.word` asm directive
---
---- If the single arg is a string, the length must be 2-16 bytes and a multiple of 2 bytes
---- If the single arg is a table, it must be an array with 1-8 i16/u16 integer elements
---- Else it must be 1-8 i16/u16 integer args
---
---# Examples
---
---```lua
---local Instruction = require("iced_x86.Instruction")
---
---local instr1 = Instruction.dw("abcd")
---local instr2 = Instruction.dw({ 0x1234, 0x5678 })
---local instr3 = Instruction.dw(0x1234, 0x5678, 0x9ABC)
---```
---
---@return Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer, a8:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer, a7:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer, a6:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer, a5:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer): Instruction
---@overload fun(a1: integer, a2:integer): Instruction
---@overload fun(a1: integer): Instruction
---@overload fun(values: integer[]): Instruction
---@overload fun(bytes: string): Instruction
function Instruction.dw() end

---Creates a `dd`/`.int` asm directive
---
---- If the single arg is a string, the length must be 4-16 bytes and a multiple of 4 bytes
---- If the single arg is a table, it must be an array with 1-4 i32/u32 integer elements
---- Else it must be 1-4 i32/u32 integer args
---
---# Examples
---
---```lua
---local Instruction = require("iced_x86.Instruction")
---
---local instr1 = Instruction.dd("abcdefgh")
---local instr2 = Instruction.dd({ 0x12345678, 0x9ABCDEF0 })
---local instr3 = Instruction.dd(1, 2, 3, 4)
---```
---
---@return Instruction
---@overload fun(a1: integer, a2:integer, a3:integer, a4:integer): Instruction
---@overload fun(a1: integer, a2:integer, a3:integer): Instruction
---@overload fun(a1: integer, a2:integer): Instruction
---@overload fun(a1: integer): Instruction
---@overload fun(values: integer[]): Instruction
---@overload fun(bytes: string): Instruction
function Instruction.dd() end

---Creates a `dq`/`.quad` asm directive
---
---- If the single arg is a string, the length must be 8-16 bytes and a multiple of 8 bytes
---- If the single arg is a table, it must be an array with 1-2 i64/u64 integer elements
---- Else it must be 1-2 i64/u64 integer args
---
---# Examples
---
---```lua
---local Instruction = require("iced_x86.Instruction")
---
---local instr1 = Instruction.dq("abcdefgh")
---local instr2 = Instruction.dq({ 0x12345678, 0x9ABCDEF0 })
---local instr3 = Instruction.dq(1, 2)
---```
---
---@return Instruction
---@overload fun(a1: integer, a2:integer): Instruction
---@overload fun(a1: integer): Instruction
---@overload fun(values: integer[]): Instruction
---@overload fun(bytes: string): Instruction
function Instruction.dq() end

---Creates an instruction. All immediate values are assumed to be signed
---
---@param code integer #(A `Code` enum variant) Code value
---@return Instruction
---@overload fun(code: integer, register1: integer, register2: integer, register3: integer, memory: MemoryOperand, immediate: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, memory: MemoryOperand, register3: integer, immediate: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, register3: integer, register4: integer, immediate: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, immediate1: integer, immediate2: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, register3: integer, memory: MemoryOperand): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, memory: MemoryOperand, immediate: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, register3: integer, immediate: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, memory: MemoryOperand, register3: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, register3: integer, register4: integer): Instruction
---@overload fun(code: integer, register: integer, immediate1: integer, immediate2: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, memory: MemoryOperand): Instruction
---@overload fun(code: integer, register: integer, memory: MemoryOperand, immediate: integer): Instruction
---@overload fun(code: integer, register1: integer, memory: MemoryOperand, register2: integer): Instruction
---@overload fun(code: integer, memory: MemoryOperand, register: integer, immediate: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, immediate: integer): Instruction
---@overload fun(code: integer, memory: MemoryOperand, register1: integer, register2: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer, register3: integer): Instruction
---@overload fun(code: integer, immediate1: integer, immediate2: integer): Instruction
---@overload fun(code: integer, immediate: integer, register: integer): Instruction
---@overload fun(code: integer, register: integer, memory: MemoryOperand): Instruction
---@overload fun(code: integer, memory: MemoryOperand, immediate: integer): Instruction
---@overload fun(code: integer, register: integer, immediate: integer): Instruction
---@overload fun(code: integer, memory: MemoryOperand, register: integer): Instruction
---@overload fun(code: integer, register1: integer, register2: integer): Instruction
---@overload fun(code: integer, immediate: integer): Instruction
---@overload fun(code: integer, memory: MemoryOperand): Instruction
---@overload fun(code: integer, register: integer): Instruction
---@overload fun(code: integer): Instruction
function Instruction.create(code) end

---Creates a new near/short branch instruction
---
---@param code integer #(A `Code` enum variant) Code value
---@param target integer #(`u64`) Target address
---@return Instruction
function Instruction.create_branch(code, target) end

---Creates a new far branch instruction
---
---@param code integer #(A `Code` enum variant) Code value
---@param selector integer #(`u16`) Selector/segment value
---@param offset integer #(`u32`) Offset
---@return Instruction
function Instruction.create_far_branch(code, selector, offset) end

---Creates a new `XBEGIN` instruction
---
---@param bitness integer #(`u32`) 16, 32, or 64
---@param target integer #(`u64`) Target address
---@return Instruction
function Instruction.create_xbegin(bitness, target) end

---Creates a `OUTSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_outsb(address_size, segment_prefix, rep_prefix) end

---Creates a `REP OUTSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_outsb(address_size) end

---Creates a `OUTSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_outsw(address_size, segment_prefix, rep_prefix) end

---Creates a `REP OUTSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_outsw(address_size) end

---Creates a `OUTSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_outsd(address_size, segment_prefix, rep_prefix) end

---Creates a `REP OUTSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_outsd(address_size) end

---Creates a `LODSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_lodsb(address_size, segment_prefix, rep_prefix) end

---Creates a `REP LODSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_lodsb(address_size) end

---Creates a `LODSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_lodsw(address_size, segment_prefix, rep_prefix) end

---Creates a `REP LODSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_lodsw(address_size) end

---Creates a `LODSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_lodsd(address_size, segment_prefix, rep_prefix) end

---Creates a `REP LODSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_lodsd(address_size) end

---Creates a `LODSQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_lodsq(address_size, segment_prefix, rep_prefix) end

---Creates a `REP LODSQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_lodsq(address_size) end

---Creates a `SCASB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_scasb(address_size, rep_prefix) end

---Creates a `REPE SCASB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repe_scasb(address_size) end

---Creates a `REPNE SCASB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repne_scasb(address_size) end

---Creates a `SCASW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_scasw(address_size, rep_prefix) end

---Creates a `REPE SCASW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repe_scasw(address_size) end

---Creates a `REPNE SCASW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repne_scasw(address_size) end

---Creates a `SCASD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_scasd(address_size, rep_prefix) end

---Creates a `REPE SCASD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repe_scasd(address_size) end

---Creates a `REPNE SCASD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repne_scasd(address_size) end

---Creates a `SCASQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_scasq(address_size, rep_prefix) end

---Creates a `REPE SCASQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repe_scasq(address_size) end

---Creates a `REPNE SCASQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repne_scasq(address_size) end

---Creates a `INSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_insb(address_size, rep_prefix) end

---Creates a `REP INSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_insb(address_size) end

---Creates a `INSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_insw(address_size, rep_prefix) end

---Creates a `REP INSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_insw(address_size) end

---Creates a `INSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_insd(address_size, rep_prefix) end

---Creates a `REP INSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_insd(address_size) end

---Creates a `STOSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_stosb(address_size, rep_prefix) end

---Creates a `REP STOSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_stosb(address_size) end

---Creates a `STOSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_stosw(address_size, rep_prefix) end

---Creates a `REP STOSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_stosw(address_size) end

---Creates a `STOSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_stosd(address_size, rep_prefix) end

---Creates a `REP STOSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_stosd(address_size) end

---Creates a `STOSQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_stosq(address_size, rep_prefix) end

---Creates a `REP STOSQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_stosq(address_size) end

---Creates a `CMPSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_cmpsb(address_size, segment_prefix, rep_prefix) end

---Creates a `REPE CMPSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repe_cmpsb(address_size) end

---Creates a `REPNE CMPSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repne_cmpsb(address_size) end

---Creates a `CMPSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_cmpsw(address_size, segment_prefix, rep_prefix) end

---Creates a `REPE CMPSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repe_cmpsw(address_size) end

---Creates a `REPNE CMPSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repne_cmpsw(address_size) end

---Creates a `CMPSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_cmpsd(address_size, segment_prefix, rep_prefix) end

---Creates a `REPE CMPSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repe_cmpsd(address_size) end

---Creates a `REPNE CMPSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repne_cmpsd(address_size) end

---Creates a `CMPSQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_cmpsq(address_size, segment_prefix, rep_prefix) end

---Creates a `REPE CMPSQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repe_cmpsq(address_size) end

---Creates a `REPNE CMPSQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_repne_cmpsq(address_size) end

---Creates a `MOVSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_movsb(address_size, segment_prefix, rep_prefix) end

---Creates a `REP MOVSB` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_movsb(address_size) end

---Creates a `MOVSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_movsw(address_size, segment_prefix, rep_prefix) end

---Creates a `REP MOVSW` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_movsw(address_size) end

---Creates a `MOVSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_movsd(address_size, segment_prefix, rep_prefix) end

---Creates a `REP MOVSD` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_movsd(address_size) end

---Creates a `MOVSQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@param rep_prefix? integer #(default = `None`) (A `RepPrefixKind` enum variant) Rep prefix or `RepPrefixKind.None`
---@return Instruction
function Instruction.create_movsq(address_size, segment_prefix, rep_prefix) end

---Creates a `REP MOVSQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@return Instruction
function Instruction.create_rep_movsq(address_size) end

---Creates a `MASKMOVQ` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param register1 integer #(A `Register` enum variant) Register
---@param register2 integer #(A `Register` enum variant) Register
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@return Instruction
function Instruction.create_maskmovq(address_size, register1, register2, segment_prefix) end

---Creates a `MASKMOVDQU` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param register1 integer #(A `Register` enum variant) Register
---@param register2 integer #(A `Register` enum variant) Register
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@return Instruction
function Instruction.create_maskmovdqu(address_size, register1, register2, segment_prefix) end

---Creates a `VMASKMOVDQU` instruction
---
---@param address_size integer #(`u32`) 16, 32, or 64
---@param register1 integer #(A `Register` enum variant) Register
---@param register2 integer #(A `Register` enum variant) Register
---@param segment_prefix? integer #(default = `None`) (A `Register` enum variant) Segment override or `Register.None`
---@return Instruction
function Instruction.create_vmaskmovdqu(address_size, register1, register2, segment_prefix) end

return Instruction
